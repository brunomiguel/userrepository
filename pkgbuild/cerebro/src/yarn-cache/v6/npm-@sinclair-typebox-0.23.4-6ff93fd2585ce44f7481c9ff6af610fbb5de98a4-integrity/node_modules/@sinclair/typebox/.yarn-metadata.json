{
  "manifest": {
    "name": "@sinclair/typebox",
    "version": "0.23.4",
    "description": "JSONSchema Type Builder with Static Type Resolution for TypeScript",
    "keywords": [
      "json-schema",
      "typescript",
      "static-types",
      "runtime-typechecking"
    ],
    "author": {
      "name": "sinclairzx81"
    },
    "license": "MIT",
    "main": "./typebox.js",
    "types": "./typebox.d.ts",
    "repository": {
      "type": "git",
      "url": "https://github.com/sinclairzx81/typebox"
    },
    "scripts": {
      "clean": "hammer task clean",
      "build": "hammer task build",
      "example": "hammer task example",
      "spec": "hammer task spec",
      "spec:types": "hammer task spec_types",
      "spec:schemas": "hammer task spec_schemas",
      "test": "npm run spec"
    },
    "devDependencies": {
      "@sinclair/hammer": "^0.16.3",
      "@types/chai": "^4.3.0",
      "@types/mocha": "^9.1.0",
      "@types/node": "^17.0.12",
      "ajv": "^8.9.0",
      "ajv-formats": "^2.1.1",
      "chai": "^4.3.5",
      "mocha": "^9.2.0",
      "tsd": "^0.19.1",
      "typescript": "^4.5.5"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-@sinclair-typebox-0.23.4-6ff93fd2585ce44f7481c9ff6af610fbb5de98a4-integrity/node_modules/@sinclair/typebox/package.json",
    "readmeFilename": "readme.md",
    "readme": "<div align='center'>\n\n<h1>TypeBox</h1>\n\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\n\n<p>JSON Schema Type Builder with Static Type Resolution for TypeScript</p>\n\n\n\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox) [![GitHub CI](https://github.com/sinclairzx81/typebox/workflows/GitHub%20CI/badge.svg)](https://github.com/sinclairzx81/typebox/actions)\n\n</div>\n\n<a name=\"Install\"></a>\n\n## Install\n\n#### Node\n\n```bash\n$ npm install @sinclair/typebox --save\n```\n\n#### Deno\n\n```typescript\nimport { Static, Type } from 'https://deno.land/x/typebox/src/typebox.ts'\n```\n\n## Example\n\n```typescript\nimport { Static, Type } from '@sinclair/typebox'\n\nconst T = Type.String()     // const T = { \"type\": \"string\" }\n\ntype T = Static<typeof T>   // type T = string\n```\n\n<a name=\"Overview\"></a>\n\n## Overview\n\nTypeBox is a library that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox allows one to create a unified type that can be both statically asserted by the TypeScript compiler and runtime asserted using standard JSON Schema validation.\n\nTypeBox can be used as a simple tool to build up complex schemas or integrated into RPC or REST services to help validate JSON data received over the wire. TypeBox does not provide any JSON schema validation. Please use libraries such as AJV to validate schemas built with this library.\n\nRequires TypeScript 4.3.5 and above.\n\nLicense MIT\n\n## Contents\n- [Install](#Install)\n- [Overview](#Overview)\n- [Usage](#Usage)\n- [Types](#Types)\n- [Modifiers](#Modifiers)\n- [Options](#Options)\n- [Generic Types](#Generic-Types)\n- [Reference Types](#Reference-Types)\n- [Recursive Types](#Recursive-Types)\n- [Extended Types](#Extended-Types)\n- [Strict](#Strict)\n- [Validation](#Validation)\n- [OpenAPI](#OpenAPI)\n\n<a name=\"Example\"></a>\n\n## Usage\n\nThe following demonstrates TypeBox's general usage.\n\n```typescript\n\nimport { Static, Type } from '@sinclair/typebox'\n\n//--------------------------------------------------------------------------------------------\n//\n// Let's say you have the following type ...\n//\n//--------------------------------------------------------------------------------------------\n\ntype T = {\n    id: string,\n    name: string,\n    timestamp: number\n}\n\n//--------------------------------------------------------------------------------------------\n//\n// ... you can express this type in the following way.\n//\n//--------------------------------------------------------------------------------------------\n\nconst T = Type.Object({               // const T = {\n    id: Type.String(),                //   type: 'object',\n    name: Type.String(),              //   properties: { \n    timestamp: Type.Integer()         //      id: { \n})                                    //         type: 'string' \n                                      //      },\n                                      //      name: { \n                                      //         type: 'string' \n                                      //      },\n                                      //      timestamp: { \n                                      //         type: 'integer' \n                                      //      }\n                                      //   }, \n                                      //   required: [\n                                      //      \"id\",\n                                      //      \"name\",\n                                      //      \"timestamp\"\n                                      //   ]\n                                      // } \n\n//--------------------------------------------------------------------------------------------\n//\n// ... then infer back to the original static type this way.\n//\n//--------------------------------------------------------------------------------------------\n\ntype T = Static<typeof T>             // type T = {\n                                      //    id: string,\n                                      //    name: string,\n                                      //    timestamp: number\n                                      // }\n\n//--------------------------------------------------------------------------------------------\n//\n// ... then use the type both as JSON schema and as a TypeScript type.\n//\n//--------------------------------------------------------------------------------------------\n\nfunction receive(value: T) {         // ... as a Type\n\n    if(JSON.validate(T, value)) {    // ... as a Schema\n\n        // ok...\n    }\n}\n```\n\n<a name=\"Types\"></a>\n\n## Types\n\nThe following table outlines the TypeBox mappings between TypeScript and JSON schema.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\n│                                │                             │    type: 'string'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\n│                                │                             │    type: 'number'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\n│                                │                             │    type: 'integer'             │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\n│                                │                             │    type: 'boolean'             │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\n│                                │                             │    type: 'null'                │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.RegEx(/foo/)    │ type T = string             │ const T = {                    │\n│                                │                             │    type: 'string',             │\n│                                │                             │    pattern: 'foo'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\n│                                │                             │    const: 42                   │\n│                                │                             │    type: 'number'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\n│    Type.Number()               │                             │    type: 'array',              │\n│ )                              │                             │    items: {                    │\n│                                │                             │      type: 'number'            │\n│                                │                             │    }                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   x: Type.Number(),            │    x: number,               │   type: 'object',              │\n│   y: Type.Number()             │    y: number                │   properties: {                │\n│ })                             │ }                           │      x: {                      │\n│                                │                             │        type: 'number'          │\n│                                │                             │      },                        │\n│                                │                             │      y: {                      │\n│                                │                             │        type: 'number'          │\n│                                │                             │      }                         │\n│                                │                             │   },                           │\n│                                │                             │   required: ['x', 'y']         │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\n│   Type.Number(),               │                             │    type: 'array',              │\n│   Type.Number()                │                             │    items: [                    │\n│ ])                             │                             │       {                        │\n│                                │                             │         type: 'number'         │\n│                                │                             │       }, {                     │\n│                                │                             │         type: 'number'         │\n│                                │                             │       }                        │\n│                                │                             │    ],                          │\n│                                │                             │    additionalItems: false,     │\n│                                │                             │    minItems: 2,                │\n│                                │                             │    maxItems: 2,                │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\n│   A,                           │   A,                        │   anyOf: [{                    │\n│   B                            │   B                         │     type: 'number',            │\n│ }                              │ }                           │     const: 0                   │\n│                                │                             │   }, {                         │\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\n│                                │                             │     const: 1                   │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\n│   Type.Object({                │   x: number,                │    enum: ['x', 'y'],           │\n│     x: Type.Number(),          │   y: number                 │    type: 'string'              │\n│     y: Type.Number()           │ }                           │ }                              │\n│   })                           │                             │                                │\n│ )                              │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\n│   Type.String(),               │                             │    anyOf: [{                   │\n│   Type.Number()                │                             │       type: 'string'           │\n│ ])                             │                             │    }, {                        │\n│                                │                             │       type: 'number'           │\n│                                │                             │    }]                          │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\n│    Type.Object({               │    x: number                │    allOf: [{                   │\n│       x: Type.Number()         │ } & {                       │       type: 'object',          │\n│    }),                         │    y: number                │       properties: {            │\n│    Type.Object({               │ }                           │          x: {                  │\n│       y: Type.Number()         │                             │            type: 'number'      │\n│   })                           │                             │          }                     │\n│ })                             │                             │       },                       │\n│                                │                             │       required: ['x']          │\n│                                │                             │    }, {                        │\n│                                │                             │       type: 'object',          │\n│                                │                             │       properties: {            │\n│                                │                             │          y: {                  │\n│                                │                             │            type: 'number'      │\n│                                │                             │          }                     │\n│                                │                             │       },                       │\n│                                │                             │       required: ['y']          │\n│                                │                             │    }]                          │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Record(         │ type T = {                  │ const T = {                    │\n│    Type.String(),              │    [key: string]: number    │    type: 'object',             │\n│    Type.Number()               │ }                           │    patternProperties: {        │\n│ )                              │                             │      '^.*$': {                 │\n│                                │                             │         type: 'number'         │\n│                                │                             │      }                         │\n│                                │                             │    }                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\n│    Type.Object({               │    x: number,               │   type: 'object',              │\n│         x: Type.Number(),      │    y: number                │   properties: {                │\n│         y: Type.Number()       | }>                          │     x: {                       │\n│    })                          │                             │        type: 'number'          │\n│ )                              │                             │     },                         │\n│                                │                             │     y: {                       │\n│                                │                             │        type: 'number'          │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\n│    Type.Object({               │    x?: number,              │   type: 'object',              │\n│       x: Type.Optional(        │    y?: number               │   properties: {                │\n│          Type.Number()         | }>                          │     x: {                       │\n│       ),                       │                             │        type: 'number'          │\n│       y: Type.Optional(        │                             │     },                         │\n│          Type.Number()         │                             │     y: {                       │\n│       )                        │                             │        type: 'number'          │\n│    })                          │                             │     }                          │\n│ )                              │                             │   },                           │\n│                                │                             │   required: ['x', 'y']         │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\n│    Type.Object({               │    x: number,               │   type: 'object',              │\n│       x: Type.Number(),        │    y: number                │   properties: {                │\n│       y: Type.Number(),        | }, 'x'>                     │     x: {                       │\n│     }), ['x']                  │                             │        type: 'number'          │\n│ )                              │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['x']              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\n│    Type.Object({               │    x: number,               │   type: 'object',              │\n│       x: Type.Number(),        │    y: number                │   properties: {                │\n│       y: Type.Number(),        | }, 'x'>                     │     y: {                       │\n│     }), ['x']                  │                             │        type: 'number'          │\n│ )                              │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['y']              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n<a name=\"Modifiers\"></a>\n\n### Modifiers\n\nTypeBox provides modifiers that can be applied to an objects properties. This allows for `optional` and `readonly` to be applied to that property. The following table illustates how they map between TypeScript and JSON Schema.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.Optional(         │    name?: string,           │   type: 'object',              │\n│      Type.String(),            │ }                           │   properties: {                │\n│   )                            │                             │      name: {                   │\n│ })  \t                         │                             │        type: 'string'          │\n│                                │                             │      }                         │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.Readonly(         │    readonly name: string,   │   type: 'object',              │\n│      Type.String(),            │ }                           │   properties: {                │\n│   )                            │                             │      name: {                   │\n│ })  \t                         │                             │        type: 'string'          │\n│                                │                             │      }                         │\n│                                │                             │   },                           │\n│                                │                             │   required: ['name']           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.ReadonlyOptional( │    readonly name?: string,  │   type: 'object',              │\n│      Type.String(),            │ }                           │   properties: {                │\n│   )                            │                             │      name: {                   │\n│ })  \t                         │                             │        type: 'string'          │\n│                                │                             │      }                         │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n<a name=\"Options\"></a>\n\n### Options\n\nYou can pass additional JSON schema options on the last argument of any given type. The following are some examples.\n\n```typescript\n// string must be an email\nconst T = Type.String({ format: 'email' })\n\n// number must be a multiple of 2\nconst T = Type.Number({ multipleOf: 2 })\n\n// array must have at least 5 integer values\nconst T = Type.Array(Type.Integer(), { minItems: 5 })\n```\n<a name=\"Generic-Types\"></a>\n\n### Generic Types\n\nGeneric types can be created using functions. The following creates a generic `Nullable<T>` type. \n\n```typescript\nimport { Type, Static, TSchema } from '@sinclair/typebox'\n\n// type Nullable<T> = T | null\n\nconst Nullable = <T extends TSchema>(type: T) => Type.Union([type, Type.Null()])\n\nconst T = Nullable(Type.String())              // const T = {\n                                               //   \"anyOf\": [{\n                                               //      type: 'string'\n                                               //   }, {\n                                               //      type: 'null'\n                                               //   }]\n                                               // }\n\ntype T = Static<typeof T>                      // type T = string | null\n\nconst U = Nullable(Type.Number())              // const U = {\n                                               //   \"anyOf\": [{\n                                               //      type: 'number'\n                                               //   }, {\n                                               //      type: 'null'\n                                               //   }]\n                                               // }\n\ntype U = Static<typeof U>                      // type U = number | null\n```\n\n<a name=\"Reference-Types\"></a>\n\n### Reference Types\n\nTypes can be referenced with `Type.Ref(...)`. To reference a type, the target type must specify an `$id`.\n\n```typescript\nconst T = Type.String({ $id: 'T' })            // const T = {\n                                               //    $id: 'T',\n                                               //    type: 'string'\n                                               // }\n                                             \nconst R = Type.Ref(T)                          // const R = {\n                                               //    $ref: 'T'\n                                               // }\n```\n\nIt can sometimes be helpful to organize shared referenced types under a common namespace. The `Type.Namespace(...)` function can be used to create a shared definition container for related types. The following creates a `Math3D` container and a `Vertex` structure that references types in the container.\n\n```typescript\nconst Math3D = Type.Namespace({                 //  const Math3D = {\n  Vector4: Type.Object({                        //    $id: 'Math3D',\n    x: Type.Number(),                           //    $defs: {\n    y: Type.Number(),                           //      Vector4: {\n    z: Type.Number(),                           //        type: 'object',\n    w: Type.Number()                            //        properties: {\n  }),                                           //          x: { type: 'number' },\n  Vector3: Type.Object({                        //          y: { type: 'number' },\n    x: Type.Number(),                           //          z: { type: 'number' },\n    y: Type.Number(),                           //          w: { type: 'number' }\n    z: Type.Number()                            //        },\n  }),                                           //        required: ['x', 'y', 'z', 'w']\n  Vector2: Type.Object({                        //      },\n    x: Type.Number(),                           //      Vector3: {\n    y: Type.Number()                            //        type: 'object',\n  })                                            //        properties: {\n}, { $id: 'Math3D' })                           //          x: { 'type': 'number' },\n                                                //          y: { 'type': 'number' },\n                                                //          z: { 'type': 'number' }\n                                                //        },\n                                                //        required: ['x', 'y', 'z']\n                                                //      },\n                                                //      Vector2: {\n                                                //        type: 'object',\n                                                //        properties: {\n                                                //          x: { 'type': 'number' },\n                                                //          y: { 'type': 'number' },\n                                                //        },\n                                                //        required: ['x', 'y']\n                                                //      }\n                                                //    }\n                                                //  }\n\t\t\t\t\t\t\t\t\t\t\t\t\t \nconst Vertex = Type.Object({                    //  const Vertex = {\n    position: Type.Ref(Math3D, 'Vector4'),      //    type: 'object',\n    normal:   Type.Ref(Math3D, 'Vector3'),      //    properties: {\n    uv:       Type.Ref(Math3D, 'Vector2')       //      position: { $ref: 'Math3D#/$defs/Vector4' },\n})                                              //      normal: { $ref: 'Math3D#/$defs/Vector3' },\n                                                //      uv: { $ref: 'Math3D#/$defs/Vector2' }\n                                                //    },\n                                                //    required: ['position', 'normal', 'uv']\n                                                //  }\n```\n\n<a name=\"Recursive-Types\"></a>\n\n### Recursive Types\n\nRecursive types can be created with the `Type.Rec(...)` function. The following creates a `Node` type that contains an array of inner Nodes. Note that due to current restrictions on TypeScript inference, it is not possible for TypeBox to statically infer for recursive types. TypeBox will infer the inner recursive type as `any`.\n\n```typescript\nconst Node = Type.Rec(Self => Type.Object({    // const Node = {\n  id:    Type.String(),                        //   $id: 'Node',\n  nodes: Type.Array(Self),                     //   $ref: 'Node#/$defs/self',\n}), { $id: 'Node' })                           //   $defs: {\n                                               //     self: {\n                                               //       type: 'object',\n                                               //       properties: {\n                                               //         id: {\n                                               //           type: 'string'\n                                               //         },\n                                               //         nodes: {\n                                               //            type: 'array',\n                                               //            items: {\n                                               //              $ref: 'Node#/$defs/self'\n                                               //            }\n                                               //         }\n                                               //      }\n                                               //    }\n                                               // }\n\ntype Node = Static<typeof Node>                // type Node = {\n                                               //   id: string\n                                               //   nodes: any[]\n                                               // }\n\nfunction visit(node: Node) {\n    for(const inner of node.nodes) {\n        visit(inner as Node)                   // Assert inner as Node\n    }\n}\n```\n\n<a name=\"Extended-Types\"></a>\n\n### Extended Types\n\nIn addition to JSON schema types, TypeBox provides several extended types that allow for `function` and `constructor` types to be composed. These additional types are not valid JSON Schema and will not validate using typical JSON Schema validation. However, these types can be used to frame JSON schema and describe callable interfaces that may receive JSON validated data. These types are as follows.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\n│    Type.String(),              │  arg0: string,              │   type: 'constructor'          │\n│    Type.Number(),              │  arg1: number               │   arguments: [{                │\n│ ], Type.Boolean())             │ ) => boolean                │      type: 'string'            │\n│                                │                             │   }, {                         │\n│                                │                             │      type: 'number'            │\n│                                │                             │   }],                          │\n│                                │                             │   returns: {                   │\n│                                │                             │      type: 'boolean'           │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\n|    Type.String(),              │  arg0: string,              │   type : 'function',           │\n│    Type.Number(),              │  arg1: number               │   arguments: [{                │\n│ ], Type.Boolean())             │ ) => boolean                │      type: 'string'            │\n│                                │                             │   }, {                         │\n│                                │                             │      type: 'number'            │\n│                                │                             │   }],                          │\n│                                │                             │   returns: {                   │\n│                                │                             │      type: 'boolean'           │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\n│    Type.String()               │                             │   type: 'promise',             │\n│ )                              │                             │   item: {                      │\n│                                │                             │      type: 'string'            │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\n│                                │                             │   type: 'undefined'            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\n│                                │                             │   type: 'void'                 │\n│                                │                             │ }                              │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n<a name=\"Strict\"></a>\n\n### Strict\n\nTypeBox schemas contain the properties `kind` and `modifier`. These properties are provided to enable runtime type reflection on schemas, as well as helping TypeBox apply the appropriate static type inference rules. These properties are not strictly valid JSON schema so in some cases it may be desirable to omit them. TypeBox provides a `Type.Strict()` function that will omit these properties if necessary.\n\n```typescript\nconst T = Type.Object({                       // const T = {\n    name: Type.Optional(Type.String())        //   kind: Symbol(ObjectKind),\n})                                            //   type: 'object',\n                                              //   properties: {\n                                              //     name: {\n                                              //       kind: Symbol(StringKind),\n                                              //       type: 'string',\n                                              //       modifier: Symbol(OptionalModifier)\n                                              //     }\n                                              //   }\n                                              // }\n\nconst U = Type.Strict(T)                      // const U = {\n                                              //     type: 'object', \n                                              //     properties: { \n                                              //         name: { \n                                              //             type: 'string' \n                                              //         } \n                                              //     } \n                                              // }\n```\n\n<a name=\"Validation\"></a>\n\n### Validation\n\nTypeBox does not provide JSON schema validation so users will need to select an appropriate JSON Schema validator for their needs. TypeBox schemas target JSON Schema draft `2019-09` so any validator capable of draft `2019-09` should be fine. A good library to use for validation in JavaScript environments is [AJV](https://www.npmjs.com/package/ajv). The following example shows setting up AJV 7 to work with TypeBox.\n\n```bash\n$ npm install ajv ajv-formats --save\n```\n\n```typescript\n//--------------------------------------------------------------------------------------------\n//\n// Import the 2019 compliant validator from AJV\n//\n//--------------------------------------------------------------------------------------------\n\nimport { Type }   from '@sinclair/typebox'\nimport addFormats from 'ajv-formats'\nimport Ajv        from 'ajv/dist/2019'\n\n//--------------------------------------------------------------------------------------------\n//\n// Setup AJV validator with the following options and formats\n//\n//--------------------------------------------------------------------------------------------\n\nconst ajv = addFormats(new Ajv({}), [\n    'date-time', \n    'time', \n    'date', \n    'email',  \n    'hostname', \n    'ipv4', \n    'ipv6', \n    'uri', \n    'uri-reference', \n    'uuid',\n    'uri-template', \n    'json-pointer', \n    'relative-json-pointer', \n    'regex'\n]).addKeyword('kind')\n  .addKeyword('modifier')\n\n//--------------------------------------------------------------------------------------------\n//\n// Create a TypeBox type\n//\n//--------------------------------------------------------------------------------------------\n\nconst User = Type.Object({\n    userId: Type.String({ format: 'uuid' }),\n    email:  Type.String({ format: 'email' }),\n    online: Type.Boolean(),\n}, { additionalProperties: false })\n\n//--------------------------------------------------------------------------------------------\n//\n// Validate Data\n//\n//--------------------------------------------------------------------------------------------\n\nconst ok = ajv.validate(User, { \n    userId: '68b4b1d8-0db6-468d-b551-02069a692044', \n    email:  'dave@domain.com',\n    online:  true\n}) // -> ok\n```\n\nPlease refer to the official AJV [documentation](https://ajv.js.org/guide/getting-started.html) for additional information on using AJV.\n\n### OpenAPI\n\nTypeBox can be used to create schemas for OpenAPI, however users should be mindful of some disparities between the JSON Schema and OpenAPI for versions prior to OpenAPI 3.1. Two common instances where OpenAPI diverges is the handling nullable and string enum schemas types. The following shows how you can use TypeBox to construct these types.\n\n```typescript\nimport { Type, Static, TNull, TLiteral, TUnion, TSchema } from '@sinclair/typebox'\n\n//--------------------------------------------------------------------------------------------\n//\n// Nullable<T>\n//\n//--------------------------------------------------------------------------------------------\n\nfunction Nullable<T extends TSchema>(schema: T): TUnion<[T, TNull]> {\n    return { ...schema, nullable: true } as any\n}\n\nconst T = Nullable(Type.String())              // const T = {\n                                               //   type: 'string',\n                                               //   nullable: true\n                                               // }\n\ntype T = Static<typeof T>                      // type T = string | null\n\n//--------------------------------------------------------------------------------------------\n//\n// StringUnion<[...]>\n//\n//--------------------------------------------------------------------------------------------\n\ntype IntoStringUnion<T> = {[K in keyof T]: T[K] extends string ? TLiteral<T[K]>: never }\n\nfunction StringUnion<T extends string[]>(values: [...T]): TUnion<IntoStringUnion<T>> {\n    return { enum: values } as any\n}\n\nconst T = StringUnion(['A', 'B', 'C'])          // const T = {\n                                                //    enum: ['A', 'B', 'C']\n                                                // }\n\ntype T = Static<typeof T>                       // type T = 'A' | 'B' | 'C'\n```\n",
    "licenseText": "TypeBox: JSON Schema Type Builder with Static Type Resolution for TypeScript \n\nThe MIT License (MIT)\n\nCopyright (c) 2021 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@sinclair/typebox/-/typebox-0.23.4.tgz#6ff93fd2585ce44f7481c9ff6af610fbb5de98a4",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@sinclair/typebox/-/typebox-0.23.4.tgz",
    "hash": "6ff93fd2585ce44f7481c9ff6af610fbb5de98a4",
    "integrity": "sha512-0/WqSvpVbCBAV1yPeko7eAczKbs78dNVAaX14quVlwOb2wxfKuXCx91h4NrEfkYK9zEnyVSW4JVI/trP3iS+Qg==",
    "registry": "npm",
    "packageName": "@sinclair/typebox",
    "cacheIntegrity": "sha512-0/WqSvpVbCBAV1yPeko7eAczKbs78dNVAaX14quVlwOb2wxfKuXCx91h4NrEfkYK9zEnyVSW4JVI/trP3iS+Qg== sha1-b/k/0lhc5E90gcn/avYQ+7XemKQ="
  },
  "registry": "npm",
  "hash": "6ff93fd2585ce44f7481c9ff6af610fbb5de98a4"
}