{
  "manifest": {
    "name": "@sinclair/typebox",
    "version": "0.24.34",
    "description": "JSONSchema Type Builder with Static Type Resolution for TypeScript",
    "keywords": [
      "typescript",
      "json-schema",
      "validate",
      "typecheck"
    ],
    "author": {
      "name": "sinclairzx81"
    },
    "license": "MIT",
    "main": "./typebox.js",
    "types": "./typebox.d.ts",
    "repository": {
      "type": "git",
      "url": "https://github.com/sinclairzx81/typebox"
    },
    "scripts": {
      "clean": "hammer task clean",
      "format": "hammer task format",
      "start": "hammer task start",
      "test": "hammer task test",
      "benchmark": "hammer task benchmark",
      "build": "hammer task build",
      "publish": "hammer task publish"
    },
    "devDependencies": {
      "@sinclair/hammer": "^0.17.1",
      "@types/chai": "^4.3.3",
      "@types/mocha": "^9.1.1",
      "@types/node": "^18.7.13",
      "ajv": "^8.11.0",
      "ajv-formats": "^2.1.1",
      "chai": "^4.3.6",
      "mocha": "^9.2.2",
      "prettier": "^2.7.1",
      "typescript": "^4.8.2"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-@sinclair-typebox-0.24.34-35b799cf98a203d1940c8ce06688f9a09fbc0f50-integrity/node_modules/@sinclair/typebox/package.json",
    "readmeFilename": "readme.md",
    "readme": "<div align='center'>\n\n<h1>TypeBox</h1>\n\n<p>JSON Schema Type Builder with Static Type Resolution for TypeScript</p>\n\t\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\n\n<br />\n<br />\n\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\n[![GitHub CI](https://github.com/sinclairzx81/typebox/workflows/GitHub%20CI/badge.svg)](https://github.com/sinclairzx81/typebox/actions)\n\n</div>\n\n<a name=\"Install\"></a>\n\n## Install\n\nNode\n\n```bash\n$ npm install @sinclair/typebox --save\n```\n\nDeno and ESM\n\n```typescript\nimport { Static, Type } from 'https://esm.sh/@sinclair/typebox'\n```\n\n## Example\n\n```typescript\nimport { Static, Type } from '@sinclair/typebox'\n\nconst T = Type.String()     // const T = { type: 'string' }\n\ntype T = Static<typeof T>   // type T = string\n```\n\n<a name=\"Overview\"></a>\n\n## Overview\n\nTypeBox is a type builder library that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\n\nTypeBox is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used either as a simple tool to build up complex schemas or integrated into REST and RPC services to help validate data received over the wire. \n\nLicense MIT\n\n## Contents\n- [Install](#install)\n- [Overview](#overview)\n- [Usage](#usage)\n- [Types](#types)\n- [Modifiers](#modifiers)\n- [Options](#options)\n- [Extended Types](#extended-types)\n- [Reference Types](#reference-types)\n- [Recursive Types](#recursive-types)\n- [Generic Types](#generic-types)\n- [Unsafe Types](#unsafe-types)\n- [Conditional Types](#conditional-types)\n- [Values](#values)\n- [Formats](#formats)\n- [Guards](#guards)\n- [Strict](#strict)\n- [Validation](#validation)\n- [Compiler](#compiler)\n- [Benchmark](#benchmark)\n- [Contribute](#contribute)\n\n<a name=\"Example\"></a>\n\n## Usage\n\nThe following demonstrates TypeBox's general usage.\n\n```typescript\n\nimport { Static, Type } from '@sinclair/typebox'\n\n//--------------------------------------------------------------------------------------------\n//\n// Let's say you have the following type ...\n//\n//--------------------------------------------------------------------------------------------\n\ntype T = {\n  id: string,\n  name: string,\n  timestamp: number\n}\n\n//--------------------------------------------------------------------------------------------\n//\n// ... you can express this type in the following way.\n//\n//--------------------------------------------------------------------------------------------\n\nconst T = Type.Object({                              // const T = {\n  id: Type.String(),                                 //   type: 'object',\n  name: Type.String(),                               //   properties: { \n  timestamp: Type.Integer()                          //     id: { \n})                                                   //       type: 'string' \n                                                     //     },\n                                                     //     name: { \n                                                     //       type: 'string' \n                                                     //     },\n                                                     //     timestamp: { \n                                                     //       type: 'integer' \n                                                     //     }\n                                                     //   }, \n                                                     //   required: [\n                                                     //     'id',\n                                                     //     'name',\n                                                     //     'timestamp'\n                                                     //   ]\n                                                     // } \n\n//--------------------------------------------------------------------------------------------\n//\n// ... then infer back to the original static type this way.\n//\n//--------------------------------------------------------------------------------------------\n\ntype T = Static<typeof T>                            // type T = {\n                                                     //   id: string,\n                                                     //   name: string,\n                                                     //   timestamp: number\n                                                     // }\n\n//--------------------------------------------------------------------------------------------\n//\n// ... then use the type both as JSON schema and as a TypeScript type.\n//\n//--------------------------------------------------------------------------------------------\n\nfunction receive(value: T) {                         // ... as a Type\n\n  if(JSON.validate(T, value)) {                      // ... as a Schema\n  \n    // ok...\n  }\n}\n```\n\n## Types\n\nThe following table outlines the TypeBox mappings between TypeScript and JSON schema.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\n│                                │                             │   type: 'string'               │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\n│                                │                             │   type: 'number'               │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\n│                                │                             │   type: 'integer'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\n│                                │                             │   type: 'boolean'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\n│                                │                             │    type: 'null'                │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.RegEx(/foo/)    │ type T = string             │ const T = {                    │\n│                                │                             │    type: 'string',             │\n│                                │                             │    pattern: 'foo'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\n│                                │                             │    const: 42,                  │\n│                                │                             │    type: 'number'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\n│   Type.Number()                │                             │   type: 'array',               │\n│ )                              │                             │   items: {                     │\n│                                │                             │     type: 'number'             │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\n│   y: Type.Number()             │   y: number                 │   properties: {                │\n│ })                             │ }                           │      x: {                      │\n│                                │                             │        type: 'number'          │\n│                                │                             │      },                        │\n│                                │                             │      y: {                      │\n│                                │                             │        type: 'number'          │\n│                                │                             │      }                         │\n│                                │                             │   },                           │\n│                                │                             │   required: ['x', 'y']         │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\n│   Type.Number(),               │                             │   type: 'array',               │\n│   Type.Number()                │                             │   items: [{                    │\n│ ])                             │                             │      type: 'number'            │\n│                                │                             │    }, {                        │\n│                                │                             │      type: 'number'            │\n│                                │                             │    }],                         │\n│                                │                             │    additionalItems: false,     │\n│                                │                             │    minItems: 2,                │\n│                                │                             │    maxItems: 2                 │\n│                                │                             │ }                              │\n│                                │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\n│   A,                           │   A,                        │   anyOf: [{                    │\n│   B                            │   B                         │     type: 'number',            │\n│ }                              │ }                           │     const: 0                   │\n│                                │                             │   }, {                         │\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\n│                                │                             │     const: 1                   │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\n│   })                           │                             │   }, {                         │\n│ )                              │                             │     type: 'string',            │\n│                                │                             │     const: 'y'                 │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\n│   Type.String(),               │                             │   anyOf: [{                    │\n│   Type.Number()                │                             │      type: 'string'            │\n│ ])                             │                             │   }, {                         │\n│                                │                             │      type: 'number'            │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\n│   Type.Object({                │   x: number                 │   type: 'object',              │\n│     x: Type.Number()           │ } & {                       │   properties: {                │\n│   }),                          │   y: number                 │     x: {                       │\n│   Type.Object({                │ }                           │       type: 'number'           │\n│     y: Type.Number()           │                             │     },                         │\n│   })                           │                             │     y: {                       │\n│ ])                             │                             │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['x', 'y']         │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\n│   Type.String(),               │   string,                   │   type: 'object',              │\n│   Type.Number()                │   number,                   │   patternProperties: {         │\n│ )                              │ >                           │     '^.*$': {                  │\n│                                │                             │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\n│   Type.Object({                │   x: number,                │   type: 'object',              │\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\n│     y: Type.Number()           | }>                          │     x: {                       │\n│   })                           │                             │       type: 'number'           │\n│ )                              │                             │     },                         │\n│                                │                             │     y: {                       │\n│                                │                             │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\n│     x: Type.Optional(          │   y?: number                │   properties: {                │\n│       Type.Number()            | }>                          │     x: {                       │\n│     ),                         │                             │       type: 'number'           │\n│     y: Type.Optional(          │                             │     },                         │\n│       Type.Number()            │                             │     y: {                       │\n│     )                          │                             │       type: 'number'           │\n│   })                           │                             │     }                          │\n│ )                              │                             │   },                           │\n│                                │                             │   required: ['x', 'y']         │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\n│   Type.Object({                │   x: number,                │   type: 'object',              │\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\n│     y: Type.Number()           | }, 'x'>                     │     x: {                       │\n│   }), ['x']                    │                             │       type: 'number'           │\n│ )                              │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['x']              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\n│   Type.Object({                │   x: number,                │   type: 'object',              │\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\n│     y: Type.Number()           | }, 'x'>                     │     y: {                       │\n│   }), ['x']                    │                             │       type: 'number'           │\n│ )                              │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['y']              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n## Modifiers\n\nTypeBox provides modifiers that can be applied to an objects properties. This allows for `optional` and `readonly` to be applied to that property. The following table illustates how they map between TypeScript and JSON Schema.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\n│     Type.String()              │ }                           │   properties: {                │\n│   )                            │                             │      name: {                   │\n│ })  \t                         │                             │        type: 'string'          │\n│                                │                             │      }                         │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\n│     Type.String()              │ }                           │   properties: {                │\n│   )                            │                             │     name: {                    │\n│ })  \t                         │                             │       type: 'string'           │\n│                                │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['name']           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\n│     Type.String()              │ }                           │   properties: {                │\n│   )                            │                             │     name: {                    │\n│ })  \t                         │                             │       type: 'string'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n## Options\n\nYou can pass additional JSON schema options on the last argument of any given type. The following are some examples.\n\n```typescript\n// string must be an email\nconst T = Type.String({ format: 'email' })\n\n// number must be a multiple of 2\nconst T = Type.Number({ multipleOf: 2 })\n\n// array must have at least 5 integer values\nconst T = Type.Array(Type.Integer(), { minItems: 5 })\n```\n\n## Extended Types\n\nIn addition to JSON schema types, TypeBox provides several extended types that allow for `function` and `constructor` types to be composed. These additional types are not valid JSON Schema and will not validate using typical JSON Schema validation. However, these types can be used to frame JSON schema and describe callable interfaces that may receive JSON validated data. These types are as follows.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\n│   Type.String(),               │  arg0: string,              │   type: 'constructor'          │\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\n│                                │                             │   }, {                         │\n│                                │                             │     type: 'number'             │\n│                                │                             │   }],                          │\n│                                │                             │   return: {                    │\n│                                │                             │     type: 'boolean'            │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\n|   Type.String(),               │  arg0: string,              │   type : 'function',           │\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\n│                                │                             │   }, {                         │\n│                                │                             │     type: 'number'             │\n│                                │                             │   }],                          │\n│                                │                             │   return: {                    │\n│                                │                             │     type: 'boolean'            │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\n│                                │                             │   type: 'object',              │\n│                                │                             │   specialized: 'Uint8Array'    │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\n│   Type.String()                │                             │   type: 'promise',             │\n│ )                              │                             │   item: {                      │\n│                                │                             │     type: 'string'             │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\n│                                │                             │   type: 'object',              │\n│                                │                             │   specialized: 'Undefined'     │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\n│                                │                             │   type: 'null'                 │\n│                                │                             │ }                              │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n## Reference Types\n\nUse `Type.Ref(...)` to create referenced types. The target type must specify an `$id`.\n\n```typescript\nconst T = Type.String({ $id: 'T' })                  // const T = {\n                                                     //    $id: 'T',\n                                                     //    type: 'string'\n                                                     // }\n                                             \nconst R = Type.Ref(T)                                // const R = {\n                                                     //    $ref: 'T'\n                                                     // }\n```\n\n## Recursive Types\n\nUse `Type.Recursive(...)` to create recursive types.\n\n```typescript\nconst Node = Type.Recursive(Node => Type.Object({    // const Node = {\n  id: Type.String(),                                 //   $id: 'Node',\n  nodes: Type.Array(Node)                            //   type: 'object',\n}), { $id: 'Node' })                                 //   properties: {\n                                                     //     id: {\n                                                     //       type: 'string'\n                                                     //     },\n                                                     //     nodes: {\n                                                     //       type: 'array',\n                                                     //       items: {\n                                                     //         $ref: 'Node'\n                                                     //       }\n                                                     //     }\n                                                     //   },\n                                                     //   required: [\n                                                     //     'id',\n                                                     //     'nodes'\n                                                     //   ]\n                                                     // }\n\ntype Node = Static<typeof Node>                      // type Node = {\n                                                     //   id: string\n                                                     //   nodes: Node[]\n                                                     // }\n\nfunction test(node: Node) {\n  const id = node.nodes[0].nodes[0]                  // id is string\n                 .nodes[0].nodes[0]\n                 .id\n}\n```\n\n## Generic Types\n\nUse functions to create generic types. The following creates a generic `Nullable<T>` type. \n\n```typescript\nimport { Type, Static, TSchema } from '@sinclair/typebox'\n\nconst Nullable = <T extends TSchema>(type: T) => Type.Union([type, Type.Null()])\n\nconst T = Nullable(Type.String())                    // const T = {\n                                                     //   anyOf: [{\n                                                     //     type: 'string'\n                                                     //   }, {\n                                                     //     type: 'null'\n                                                     //   }]\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = string | null\n\nconst U = Nullable(Type.Number())                    // const U = {\n                                                     //   anyOf: [{\n                                                     //     type: 'number'\n                                                     //   }, {\n                                                     //     type: 'null'\n                                                     //   }]\n                                                     // }\n\ntype U = Static<typeof U>                            // type U = number | null\n```\n\n## Unsafe Types\n\nUse `Type.Unsafe(...)` to create custom schemas with user defined inference rules.\n\n```typescript\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\n                                                     //   type: 'number'\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = string\n```\n\nThis function can be used to create custom schemas for validators that require specific schema representations. An example of this might be OpenAPI's `nullable` and `enum` schemas which are not provided by TypeBox. The following demonstrates using `Type.Unsafe(...)` to create these types.\n\n```typescript\nimport { Type, Static, TSchema } from '@sinclair/typebox'\n\n//--------------------------------------------------------------------------------------------\n//\n// Nullable<T>\n//\n//--------------------------------------------------------------------------------------------\n\nfunction Nullable<T extends TSchema>(schema: T) {\n  return Type.Unsafe<Static<T> | null>({ ...schema, nullable: true })\n}\n\nconst T = Nullable(Type.String())                    // const T = {\n                                                     //   type: 'string',\n                                                     //   nullable: true\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = string | null\n\n\n//--------------------------------------------------------------------------------------------\n//\n// StringEnum<string[]>\n//\n//--------------------------------------------------------------------------------------------\n\nfunction StringEnum<T extends string[]>(values: [...T]) {\n  return Type.Unsafe<T[number]>({ type: 'string', enum: values })\n}\n\nconst T = StringEnum(['A', 'B', 'C'])                // const T = {\n                                                     //   enum: ['A', 'B', 'C']\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = 'A' | 'B' | 'C'\n```\n\n## Conditional Types\n\nUse the conditional module to create [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html). This module implements TypeScript's structural equivalence checks to enable TypeBox types to be conditionally inferred at runtime. This module also provides the [Extract](https://www.typescriptlang.org/docs/handbook/utility-types.html#extracttype-union) and [Exclude](https://www.typescriptlang.org/docs/handbook/utility-types.html#excludeuniontype-excludedmembers) utility types which are expressed as conditional types in TypeScript. \n\nThe conditional module is provided as an optional import.\n\n```typescript\nimport { Conditional } from '@sinclair/typebox/conditional'\n```\nThe following table shows the TypeBox mappings between TypeScript and JSON schema.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Conditional.Extends( │ type T =                    │ const T = {                    │\n│   Type.String(),               │  string extends number      │   const: false,                │\n│   Type.Number(),               │  true : false               │   type: 'boolean'              │\n│   Type.Literal(true),          │                             │ }                              │\n│   Type.Literal(false)          │                             │                                │\n│ )                              │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Conditional.Extract( │ type T = Extract<           │ const T = {                    │\n│   Type.Union([                 │   'a' | 'b' | 'c',          │   anyOf: [{                    │\n│     Type.Literal('a'),         │   'a' | 'f'                 │     const: 'a'                 │\n│     Type.Literal('b'),         │ >                           │     type: 'string'             │\n│     Type.Literal('c')          │                             │   }]                           │\n│   ]),                          │                             │ }                              │\n│   Type.Union([                 │                             │                                │\n│     Type.Literal('a'),         │                             │                                │\n│     Type.Literal('f')          │                             │                                │\n│   ])                           │                             │                                │\n│ )                              │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Conditional.Exclude( │ type T = Exclude<           │ const T = {                    │\n│   Type.Union([                 │   'a' | 'b' | 'c',          │   anyOf: [{                    │\n│     Type.Literal('a'),         │   'a'                       │     const: 'b',                │\n│     Type.Literal('b'),         │ >                           │     type: 'string'             │\n│     Type.Literal('c')          │                             │   }, {                         │\n│   ]),                          │                             │     const: 'c',                │\n│   Type.Union([                 │                             │     type: 'string'             │\n│     Type.Literal('a')          │                             │   }]                           │\n│   ])                           │                             │ }                              │\n│ )                              │                             │                                │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n## Values\n\nUse the value module to perform common type operations on values. This module provides functionality to create, check and cast values into a given type. Note that this module internally uses dynamic type checking to perform these operations. For faster type checking performance, consider using either Ajv or the TypeBox [TypeCompiler](#compiler).\n\n The value module is provided as an optional import.\n\n```typescript\nimport { Value } from '@sinclair/typebox/value'\n```\nThe following demonstrates its use.\n```typescript\n\n\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\n\n//--------------------------------------------------------------------------------------------\n//\n// Use Value.Create(T) to create a value from T.\n//\n//--------------------------------------------------------------------------------------------\n\nconst V = Value.Create(T)                            // const V = { x: 0, y: 0 }\n\n//--------------------------------------------------------------------------------------------\n//\n// Use Value.Check(T, ...) to check if a value is of type T.\n//\n//--------------------------------------------------------------------------------------------\n\nconst R = Value.Check(T, { x: 1 })                   // const R = false\n\n//--------------------------------------------------------------------------------------------\n//\n// Use Value.Cast(T, ...) to immutably cast a value into T.\n//\n//--------------------------------------------------------------------------------------------\n\nconst A = Value.Cast(T, null)                        // const A = { x: 0, y: 0 }\n\nconst B = Value.Cast(T, { x: 1 })                    // const B = { x: 1, y: 0 }\n\nconst C = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const C = { x: 1, y: 2 }\n```\n\n## Formats\n\nUse the format module to create user defined string formats. This module enables programmatic validation of strings that cannot be easily validated with [pattern](https://json-schema.org/understanding-json-schema/reference/regular_expressions.html) expressions. The format module is used by the Value and TypeCompiler modules only. If using Ajv, please refer to the official Ajv format documentation located [here](https://ajv.js.org/guide/formats.html).\n\nThe format module is an optional import.\n\n```typescript\nimport { Format } from '@sinclair/typebox/format'\n```\n\nThe following demonstrates its use.\n\n```typescript\n//--------------------------------------------------------------------------------------------\n//\n// Use Format.Set(format, func) to define custom format\n//\n//--------------------------------------------------------------------------------------------\n\nFormat.Set('palindrome', value => value === value.split('').reverse().join(''))\n\n//--------------------------------------------------------------------------------------------\n//\n// Use the format property on string types\n//\n//--------------------------------------------------------------------------------------------\n\nconst T = Type.String({ format: 'palindrome' })\n\nValue.Check(T, 'kayak')                              // true\n\nValue.Check(T, 'engine')                             // false\n```\n\n## Guards\n\nUse the guard module to test if values are TypeBox types.\n\n```typescript\nimport { TypeGuard } from '@sinclair/typebox/guard'\n\nconst T = Type.String()\n\nif(TypeGuard.TString(T)) {\n    \n  // T is TString\n}\n```\n\n## Strict\n\nTypeBox schemas contain the `Kind` and `Modifier` symbol properties. These properties are provided to enable runtime type reflection on schemas, as well as helping TypeBox internally compose types. These properties are not strictly valid JSON schema; so in some cases it may be desirable to omit them. TypeBox provides a `Type.Strict()` function that will omit these properties if necessary.\n\n```typescript\nconst T = Type.Object({                              // const T = {\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\n})                                                   //   type: 'object',\n                                                     //   properties: {\n                                                     //     name: {\n                                                     //       [Kind]: 'String',\n                                                     //       type: 'string',\n                                                     //       [Modifier]: 'Optional'\n                                                     //     }\n                                                     //   }\n                                                     // }\n\nconst U = Type.Strict(T)                             // const U = {\n                                                     //   type: 'object', \n                                                     //   properties: { \n                                                     //     name: { \n                                                     //       type: 'string' \n                                                     //     } \n                                                     //   } \n                                                     // }\n```\n\n## Validation\n\nTypeBox schemas target JSON Schema draft 6 so any validator capable of draft 6 should be fine. A good library to use for validation in JavaScript environments is [Ajv](https://www.npmjs.com/package/ajv). The following example shows setting up Ajv to work with TypeBox.\n\n```bash\n$ npm install ajv ajv-formats --save\n```\n\n```typescript\n//--------------------------------------------------------------------------------------------\n//\n// Import TypeBox and Ajv\n//\n//--------------------------------------------------------------------------------------------\n\nimport { Type }   from '@sinclair/typebox'\nimport addFormats from 'ajv-formats'\nimport Ajv        from 'ajv'\n\n//--------------------------------------------------------------------------------------------\n//\n// Setup Ajv validator with the following options and formats\n//\n//--------------------------------------------------------------------------------------------\n\nconst ajv = addFormats(new Ajv({}), [\n  'date-time', \n  'time', \n  'date', \n  'email',  \n  'hostname', \n  'ipv4', \n  'ipv6', \n  'uri', \n  'uri-reference', \n  'uuid',\n  'uri-template', \n  'json-pointer', \n  'relative-json-pointer', \n  'regex'\n])\n\n//--------------------------------------------------------------------------------------------\n//\n// Create a TypeBox type\n//\n//--------------------------------------------------------------------------------------------\n\nconst T = Type.Object({\n  x: Type.Number(),\n  y: Type.Number(),\n  z: Type.Number()\n})\n\n//--------------------------------------------------------------------------------------------\n//\n// Validate Data\n//\n//--------------------------------------------------------------------------------------------\n\nconst R = ajv.validate(T, { x: 1, y: 2, z: 3 })      // const R = true\n```\n\nPlease refer to the official Ajv [documentation](https://ajv.js.org/guide/getting-started.html) for additional information on using Ajv.\n\n## Compiler\n\nTypeBox provides an optional high performance just-in-time (JIT) compiler and type checker that can be used in applications that require extremely fast validation. Note that this compiler is optimized for TypeBox types only where the schematics are known in advance. If defining custom types with `Type.Unsafe<T>` please consider Ajv.\n\nThe compiler module is provided as an optional import.\n\n```typescript\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\n```\n\nUse the `Compile(...)` function to compile a type.\n\n```typescript\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\n  x: Type.Number(),                                  //     x: TNumber;\n  y: Type.Number(),                                  //     y: TNumber;\n  z: Type.Number()                                   //     z: TNumber;\n}))                                                  // }>>\n\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\n```\n\nValidation errors can be read with the `Errors(...)` function.\n\n```typescript\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\n  x: Type.Number(),                                  //     x: TNumber;\n  y: Type.Number(),                                  //     y: TNumber;\n  z: Type.Number()                                   //     z: TNumber;\n}))                                                  // }>>\n\nconst value = { }\n\nconst errors = [...C.Errors(value)]                  // const errors = [{\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/x',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }, {\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/y',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }, {\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/z',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }]\n```\n\nCompiled routines can be inspected with the `.Code()` function.\n\n```typescript\nconst C = TypeCompiler.Compile(Type.String())        // const C: TypeCheck<TString>\n\nconsole.log(C.Code())                                // return function check(value) {\n                                                     //   return (\n                                                     //     (typeof value === 'string')\n                                                     //   )\n                                                     // }\n```\n\n## Benchmark\n\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.11.0. \n\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\n\n### Compile\n\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/compile.ts).\n\n```typescript\n┌──────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\n│     (index)      │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\n├──────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\n│           Number │    2000    │ '    402 ms' │ '      8 ms' │ '   50.25 x' │\n│           String │    2000    │ '    316 ms' │ '      8 ms' │ '   39.50 x' │\n│          Boolean │    2000    │ '    308 ms' │ '      6 ms' │ '   51.33 x' │\n│             Null │    2000    │ '    259 ms' │ '      5 ms' │ '   51.80 x' │\n│            RegEx │    2000    │ '    479 ms' │ '     11 ms' │ '   43.55 x' │\n│          ObjectA │    2000    │ '   2766 ms' │ '     41 ms' │ '   67.46 x' │\n│          ObjectB │    2000    │ '   3062 ms' │ '     29 ms' │ '  105.59 x' │\n│            Tuple │    2000    │ '   1258 ms' │ '     21 ms' │ '   59.90 x' │\n│            Union │    2000    │ '   1449 ms' │ '     29 ms' │ '   49.97 x' │\n│          Vector4 │    2000    │ '   1616 ms' │ '     16 ms' │ '  101.00 x' │\n│          Matrix4 │    2000    │ '    975 ms' │ '      8 ms' │ '  121.88 x' │\n│   Literal_String │    2000    │ '    350 ms' │ '      6 ms' │ '   58.33 x' │\n│   Literal_Number │    2000    │ '    386 ms' │ '      5 ms' │ '   77.20 x' │\n│  Literal_Boolean │    2000    │ '    377 ms' │ '      4 ms' │ '   94.25 x' │\n│     Array_Number │    2000    │ '    737 ms' │ '      7 ms' │ '  105.29 x' │\n│     Array_String │    2000    │ '    765 ms' │ '      7 ms' │ '  109.29 x' │\n│    Array_Boolean │    2000    │ '    783 ms' │ '      8 ms' │ '   97.88 x' │\n│    Array_ObjectA │    2000    │ '   3578 ms' │ '     31 ms' │ '  115.42 x' │\n│    Array_ObjectB │    2000    │ '   3718 ms' │ '     33 ms' │ '  112.67 x' │\n│      Array_Tuple │    2000    │ '   2259 ms' │ '     14 ms' │ '  161.36 x' │\n│      Array_Union │    2000    │ '   1704 ms' │ '     20 ms' │ '   85.20 x' │\n│    Array_Vector4 │    2000    │ '   2293 ms' │ '     17 ms' │ '  134.88 x' │\n│    Array_Matrix4 │    2000    │ '   1575 ms' │ '     12 ms' │ '  131.25 x' │\n└──────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\n```\n\n### Validate\n\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/check.ts).\n\n```typescript\n┌──────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\n│     (index)      │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\n├──────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\n│           Number │  1000000   │ '     38 ms' │ '      6 ms' │ '      5 ms' │ '    1.20 x' │\n│           String │  1000000   │ '     26 ms' │ '     23 ms' │ '     12 ms' │ '    1.92 x' │\n│          Boolean │  1000000   │ '     26 ms' │ '     23 ms' │ '     11 ms' │ '    2.09 x' │\n│             Null │  1000000   │ '     29 ms' │ '     24 ms' │ '     12 ms' │ '    2.00 x' │\n│            RegEx │  1000000   │ '    169 ms' │ '     47 ms' │ '     37 ms' │ '    1.27 x' │\n│          ObjectA │  1000000   │ '    551 ms' │ '     45 ms' │ '     23 ms' │ '    1.96 x' │\n│          ObjectB │  1000000   │ '    995 ms' │ '     49 ms' │ '     39 ms' │ '    1.26 x' │\n│            Tuple │  1000000   │ '    115 ms' │ '     30 ms' │ '     14 ms' │ '    2.14 x' │\n│            Union │  1000000   │ '    294 ms' │ '     30 ms' │ '     14 ms' │ '    2.14 x' │\n│        Recursive │  1000000   │ '   3308 ms' │ '    429 ms' │ '    174 ms' │ '    2.47 x' │\n│          Vector4 │  1000000   │ '    145 ms' │ '     25 ms' │ '     13 ms' │ '    1.92 x' │\n│          Matrix4 │  1000000   │ '    663 ms' │ '     42 ms' │ '     34 ms' │ '    1.24 x' │\n│   Literal_String │  1000000   │ '     46 ms' │ '     21 ms' │ '     11 ms' │ '    1.91 x' │\n│   Literal_Number │  1000000   │ '     50 ms' │ '     26 ms' │ '     11 ms' │ '    2.36 x' │\n│  Literal_Boolean │  1000000   │ '     45 ms' │ '     24 ms' │ '     11 ms' │ '    2.18 x' │\n│     Array_Number │  1000000   │ '    411 ms' │ '     35 ms' │ '     19 ms' │ '    1.84 x' │\n│     Array_String │  1000000   │ '    438 ms' │ '     33 ms' │ '     20 ms' │ '    1.65 x' │\n│    Array_Boolean │  1000000   │ '    444 ms' │ '     38 ms' │ '     24 ms' │ '    1.58 x' │\n│    Array_ObjectA │  1000000   │ '  13714 ms' │ '   2819 ms' │ '   1791 ms' │ '    1.57 x' │\n│    Array_ObjectB │  1000000   │ '  15855 ms' │ '   2965 ms' │ '   2066 ms' │ '    1.44 x' │\n│      Array_Tuple │  1000000   │ '   1682 ms' │ '     94 ms' │ '     71 ms' │ '    1.32 x' │\n│      Array_Union │  1000000   │ '   4575 ms' │ '    239 ms' │ '     86 ms' │ '    2.78 x' │\n│  Array_Recursive │  1000000   │ '  51970 ms' │ '   7192 ms' │ '   2617 ms' │ '    2.75 x' │\n│    Array_Vector4 │  1000000   │ '   2097 ms' │ '    100 ms' │ '     54 ms' │ '    1.85 x' │\n│    Array_Matrix4 │  1000000   │ '  11596 ms' │ '    381 ms' │ '    327 ms' │ '    1.17 x' │\n└──────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\n```\n\n### Compression\n\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\n\n```typescript\n┌──────────────────────┬────────────┬────────────┬─────────────┐\n│       (index)        │  Compiled  │  Minified  │ Compression │\n├──────────────────────┼────────────┼────────────┼─────────────┤\n│ typebox/compiler     │ '   48 kb' │ '   24 kb' │  '2.00 x'   │\n│ typebox/conditional  │ '   41 kb' │ '   16 kb' │  '2.47 x'   │\n│ typebox/format       │ '    0 kb' │ '    0 kb' │  '2.68 x'   │\n│ typebox/guard        │ '   20 kb' │ '    9 kb' │  '2.08 x'   │\n│ typebox/value        │ '   55 kb' │ '   25 kb' │  '2.15 x'   │\n│ typebox              │ '   11 kb' │ '    5 kb' │  '1.91 x'   │\n└──────────────────────┴────────────┴────────────┴─────────────┘\n```\n\n## Contribute\n\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\n",
    "licenseText": "TypeBox: JSON Schema Type Builder with Static Type Resolution for TypeScript \n\nThe MIT License (MIT)\n\nCopyright (c) 2022 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@sinclair/typebox/-/typebox-0.24.34.tgz#35b799cf98a203d1940c8ce06688f9a09fbc0f50",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@sinclair/typebox/-/typebox-0.24.34.tgz",
    "hash": "35b799cf98a203d1940c8ce06688f9a09fbc0f50",
    "integrity": "sha512-x3ejWKw7rpy30Bvm6U0AQMOHdjqe2E3YJrBHlTxH0KFsp77bBa+MH324nJxtXZFpnTy/JW2h5HPYVm0vG2WPnw==",
    "registry": "npm",
    "packageName": "@sinclair/typebox",
    "cacheIntegrity": "sha512-x3ejWKw7rpy30Bvm6U0AQMOHdjqe2E3YJrBHlTxH0KFsp77bBa+MH324nJxtXZFpnTy/JW2h5HPYVm0vG2WPnw== sha1-NbeZz5iiA9GUDIzgZoj5oJ+8D1A="
  },
  "registry": "npm",
  "hash": "35b799cf98a203d1940c8ce06688f9a09fbc0f50"
}