{
  "manifest": {
    "name": "memoize-one",
    "version": "6.0.0",
    "description": "A memoization library which only remembers the latest invocation",
    "main": "dist/memoize-one.cjs.js",
    "types": "dist/memoize-one.d.ts",
    "module": "dist/memoize-one.esm.js",
    "sideEffects": false,
    "author": {
      "name": "Alex Reardon",
      "email": "alexreardon@gmail.com"
    },
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/alexreardon/memoize-one.git"
    },
    "files": [
      "/dist",
      "/src"
    ],
    "size-limit": [
      {
        "path": "dist/memoize-one.min.js",
        "limit": "234B"
      },
      {
        "path": "dist/memoize-one.js",
        "limit": "234B"
      },
      {
        "path": "dist/memoize-one.cjs.js",
        "limit": "230B"
      },
      {
        "path": "dist/memoize-one.esm.js",
        "limit": "246B"
      }
    ],
    "keywords": [
      "memoize",
      "memoization",
      "cache",
      "performance"
    ],
    "dependencies": {},
    "devDependencies": {
      "@size-limit/preset-small-lib": "^5.0.4",
      "@types/benchmark": "^2.1.1",
      "@types/jest": "^27.0.2",
      "@types/lodash.isequal": "^4.5.5",
      "@types/lodash.memoize": "^4.1.6",
      "@types/node": "^16.10.1",
      "@typescript-eslint/eslint-plugin": "^4.31.2",
      "@typescript-eslint/parser": "^4.31.2",
      "benchmark": "^2.1.4",
      "cross-env": "^7.0.3",
      "eslint": "7.32.0",
      "eslint-config-prettier": "^8.3.0",
      "eslint-plugin-jest": "^24.4.2",
      "eslint-plugin-prettier": "^4.0.0",
      "expect-type": "^0.12.0",
      "fast-memoize": "^2.5.2",
      "jest": "^27.2.2",
      "lodash.isequal": "^4.5.0",
      "lodash.memoize": "^4.1.2",
      "markdown-table": "^3.0.1",
      "mem": "^9.0.1",
      "memoizee": "^0.4.15",
      "moize": "^6.1.0",
      "nanocolors": "^0.2.9",
      "ora": "^6.0.1",
      "prettier": "2.4.1",
      "rimraf": "3.0.2",
      "rollup": "^2.57.0",
      "rollup-plugin-replace": "^2.2.0",
      "rollup-plugin-terser": "^7.0.2",
      "rollup-plugin-typescript": "^1.0.1",
      "size-limit": "^5.0.4",
      "ts-jest": "^27.0.5",
      "ts-node": "^10.2.1",
      "tslib": "^2.3.1",
      "typescript": "^4.4.3"
    },
    "config": {
      "prettier_target": "src/**/*.{ts,js,jsx,md,json} test/**/*.{ts,js,jsx,md,json}"
    },
    "scripts": {
      "validate": "yarn prettier:check && yarn eslint:check && yarn typescript:check",
      "test": "yarn jest",
      "test:size": "yarn build && yarn size-limit",
      "typescript:check": "yarn tsc --noEmit",
      "prettier:check": "yarn prettier --debug-check $npm_package_config_prettier_target",
      "prettier:write": "yarn prettier --write $npm_package_config_prettier_target",
      "eslint:check": "eslint $npm_package_config_prettier_target",
      "build": "yarn build:clean && yarn build:dist && yarn build:typescript && yarn build:flow",
      "build:clean": "yarn rimraf dist",
      "build:dist": "yarn rollup -c",
      "build:typescript": "yarn tsc ./src/memoize-one.ts --emitDeclarationOnly --declaration --outDir ./dist",
      "build:flow": "cp src/memoize-one.js.flow dist/memoize-one.cjs.js.flow",
      "perf": "yarn ts-node ./benchmarks/shallow-equal.ts",
      "perf:library-comparison": "yarn build && node ./benchmarks/library-comparison.js",
      "prepublishOnly": "yarn build"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-memoize-one-6.0.0-b2591b871ed82948aee4727dc6abceeeac8c1045-integrity/node_modules/memoize-one/package.json",
    "readmeFilename": "README.md",
    "readme": "# memoize-one\n\nA memoization library that only caches the result of the most recent arguments.\n\n[![npm](https://img.shields.io/npm/v/memoize-one.svg)](https://www.npmjs.com/package/memoize-one)\n![types](https://img.shields.io/badge/types-typescript%20%7C%20flow-blueviolet)\n[![minzip](https://img.shields.io/bundlephobia/minzip/memoize-one.svg)](https://www.npmjs.com/package/memoize-one)\n[![Downloads per month](https://img.shields.io/npm/dm/memoize-one.svg)](https://www.npmjs.com/package/memoize-one)\n\n## Rationale\n\nUnlike other memoization libraries, `memoize-one` only remembers the latest arguments and result. No need to worry about cache busting mechanisms such as `maxAge`, `maxSize`, `exclusions` and so on, which can be prone to memory leaks. A function memoized with `memoize-one` simply remembers the last arguments, and if the memoized function is next called with the same arguments then it returns the previous result.\n\n> For working with promises, [@Kikobeats](https://github.com/Kikobeats) has built [async-memoize-one](https://github.com/microlinkhq/async-memoize-one).\n\n## Usage\n\n```js\n// memoize-one uses the default import\nimport memoizeOne from 'memoize-one';\n\nfunction add(a, b) {\n  return a + b;\n}\nconst memoizedAdd = memoizeOne(add);\n\nmemoizedAdd(1, 2);\n// add function: is called\n// [new value returned: 3]\n\nmemoizedAdd(1, 2);\n// add function: not called\n// [cached result is returned: 3]\n\nmemoizedAdd(2, 3);\n// add function: is called\n// [new value returned: 5]\n\nmemoizedAdd(2, 3);\n// add function: not called\n// [cached result is returned: 5]\n\nmemoizedAdd(1, 2);\n// add function: is called\n// [new value returned: 3]\n// 👇\n// While the result of `add(1, 2)` was previously cached\n// `(1, 2)` was not the *latest* arguments (the last call was `(2, 3)`)\n// so the previous cached result of `(1, 3)` was lost\n```\n\n## Installation\n\n```bash\n# yarn\nyarn add memoize-one\n\n# npm\nnpm install memoize-one --save\n```\n\n## Function argument equality\n\nBy default, we apply our own _fast_ and _relatively naive_ equality function to determine whether the arguments provided to your function are equal. You can see the full code here: [are-inputs-equal.ts](https://github.com/alexreardon/memoize-one/blob/master/src/are-inputs-equal.ts).\n\n(By default) function arguments are considered equal if:\n\n1. there is same amount of arguments\n2. each new argument has strict equality (`===`) with the previous argument\n3. **[special case]** if two arguments are not `===` and they are both `NaN` then the two arguments are treated as equal\n\nWhat this looks like in practice:\n\n```js\nimport memoizeOne from 'memoize-one';\n\n// add all numbers provided to the function\nconst add = (...args = []) =>\n  args.reduce((current, value) => {\n    return current + value;\n  }, 0);\nconst memoizedAdd = memoizeOne(add);\n```\n\n> 1. there is same amount of arguments\n\n```js\nmemoizedAdd(1, 2);\n// the amount of arguments has changed, so underlying add function is called\nmemoizedAdd(1, 2, 3);\n```\n\n> 2. new arguments have strict equality (`===`) with the previous argument\n\n```js\nmemoizedAdd(1, 2);\n// each argument is `===` to the last argument, so cache is used\nmemoizedAdd(1, 2);\n// second argument has changed, so add function is called again\nmemoizedAdd(1, 3);\n// the first value is not `===` to the previous first value (1 !== 3)\n// so add function is called again\nmemoizedAdd(3, 1);\n```\n\n> 3. **[special case]** if the arguments are not `===` and they are both `NaN` then the argument is treated as equal\n\n```js\nmemoizedAdd(NaN);\n// Even though NaN !== NaN these arguments are\n// treated as equal as they are both `NaN`\nmemoizedAdd(NaN);\n```\n\n## Custom equality function\n\nYou can also pass in a custom function for checking the equality of two sets of arguments\n\n```js\nconst memoized = memoizeOne(fn, isEqual);\n```\n\nAn equality function should return `true` if the arguments are equal. If `true` is returned then the wrapped function will not be called.\n\n**Tip**: A custom equality function needs to compare `Arrays`. The `newArgs` array will be a new reference every time so a simple `newArgs === lastArgs` will always return `false`.\n\nEquality functions are not called if the `this` context of the function has changed (see below).\n\nHere is an example that uses a [lodash.isEqual](https://lodash.com/docs/4.17.15#isEqual) deep equal equality check\n\n> `lodash.isequal` correctly handles deep comparing two arrays\n\n```js\nimport memoizeOne from 'memoize-one';\nimport isDeepEqual from 'lodash.isequal';\n\nconst identity = (x) => x;\n\nconst shallowMemoized = memoizeOne(identity);\nconst deepMemoized = memoizeOne(identity, isDeepEqual);\n\nconst result1 = shallowMemoized({ foo: 'bar' });\nconst result2 = shallowMemoized({ foo: 'bar' });\n\nresult1 === result2; // false - different object reference\n\nconst result3 = deepMemoized({ foo: 'bar' });\nconst result4 = deepMemoized({ foo: 'bar' });\n\nresult3 === result4; // true - arguments are deep equal\n```\n\nThe equality function needs to conform to the `EqualityFn` `type`:\n\n```ts\n// TFunc is the function being memoized\ntype EqualityFn<TFunc extends (...args: any[]) => any> = (\n  newArgs: Parameters<TFunc>,\n  lastArgs: Parameters<TFunc>,\n) => boolean;\n\n// You can import this type\nimport type { EqualityFn } from 'memoize-one';\n```\n\nThe `EqualityFn` type allows you to create equality functions that are extremely typesafe. You are welcome to provide your own less type safe equality functions.\n\nHere are some examples of equality functions which are ordered by most type safe, to least type safe:\n\n<details>\n  <summary>Example equality function types</summary>\n  <p>\n\n```ts\n// the function we are going to memoize\nfunction add(first: number, second: number): number {\n  return first + second;\n}\n\n// Some options for our equality function\n// ↑ stronger types\n// ↓ weaker types\n\n// ✅ exact parameters of `add`\n{\n  const isEqual = function (first: Parameters<typeof add>, second: Parameters<typeof add>) {\n    return true;\n  };\n  expectTypeOf<typeof isEqual>().toMatchTypeOf<EqualityFn<typeof add>>();\n}\n\n// ✅ tuple of the correct types\n{\n  const isEqual = function (first: [number, number], second: [number, number]) {\n    return true;\n  };\n  expectTypeOf<typeof isEqual>().toMatchTypeOf<EqualityFn<typeof add>>();\n}\n\n// ❌ tuple of incorrect types\n{\n  const isEqual = function (first: [number, string], second: [number, number]) {\n    return true;\n  };\n  expectTypeOf<typeof isEqual>().not.toMatchTypeOf<EqualityFn<typeof add>>();\n}\n\n// ✅ array of the correct types\n{\n  const isEqual = function (first: number[], second: number[]) {\n    return true;\n  };\n  expectTypeOf<typeof isEqual>().toMatchTypeOf<EqualityFn<typeof add>>();\n}\n\n// ❌ array of incorrect types\n{\n  const isEqual = function (first: string[], second: number[]) {\n    return true;\n  };\n  expectTypeOf<typeof isEqual>().not.toMatchTypeOf<EqualityFn<typeof add>>();\n}\n\n// ✅ tuple of 'unknown'\n{\n  const isEqual = function (first: [unknown, unknown], second: [unknown, unknown]) {\n    return true;\n  };\n  expectTypeOf<typeof isEqual>().toMatchTypeOf<EqualityFn<typeof add>>();\n}\n\n// ❌ tuple of 'unknown' of incorrect length\n{\n  const isEqual = function (first: [unknown, unknown, unknown], second: [unknown, unknown]) {\n    return true;\n  };\n  expectTypeOf<typeof isEqual>().not.toMatchTypeOf<EqualityFn<typeof add>>();\n}\n\n// ✅ array of 'unknown'\n{\n  const isEqual = function (first: unknown[], second: unknown[]) {\n    return true;\n  };\n  expectTypeOf<typeof isEqual>().toMatchTypeOf<EqualityFn<typeof add>>();\n}\n\n// ✅ spread of 'unknown'\n{\n  const isEqual = function (...first: unknown[]) {\n    return !!first;\n  };\n  expectTypeOf<typeof isEqual>().toMatchTypeOf<EqualityFn<typeof add>>();\n}\n\n// ✅ tuple of 'any'\n{\n  const isEqual = function (first: [any, any], second: [any, any]) {\n    return true;\n  };\n  expectTypeOf<typeof isEqual>().toMatchTypeOf<EqualityFn<typeof add>>();\n}\n\n// ❌ tuple of 'any' or incorrect size\n{\n  const isEqual = function (first: [any, any, any], second: [any, any]) {\n    return true;\n  };\n  expectTypeOf<typeof isEqual>().not.toMatchTypeOf<EqualityFn<typeof add>>();\n}\n\n// ✅ array of 'any'\n{\n  const isEqual = function (first: any[], second: any[]) {\n    return true;\n  };\n  expectTypeOf<typeof isEqual>().toMatchTypeOf<EqualityFn<typeof add>>();\n}\n\n// ✅ two arguments of type any\n{\n  const isEqual = function (first: any, second: any) {\n    return true;\n  };\n  expectTypeOf<typeof isEqual>().toMatchTypeOf<EqualityFn<typeof add>>();\n}\n\n// ✅ a single argument of type any\n{\n  const isEqual = function (first: any) {\n    return true;\n  };\n  expectTypeOf<typeof isEqual>().toMatchTypeOf<EqualityFn<typeof add>>();\n}\n\n// ✅ spread of any type\n{\n  const isEqual = function (...first: any[]) {\n    return true;\n  };\n  expectTypeOf<typeof isEqual>().toMatchTypeOf<EqualityFn<typeof add>>();\n}\n```\n\n  </p>\n</details>\n\n## `this`\n\n### `memoize-one` correctly respects `this` control\n\nThis library takes special care to maintain, and allow control over the the `this` context for **both** the original function being memoized as well as the returned memoized function. Both the original function and the memoized function's `this` context respect [all the `this` controlling techniques](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md):\n\n- new bindings (`new`)\n- explicit binding (`call`, `apply`, `bind`);\n- implicit binding (call site: `obj.foo()`);\n- default binding (`window` or `undefined` in `strict mode`);\n- fat arrow binding (binding to lexical `this`)\n- ignored this (pass `null` as `this` to explicit binding)\n\n### Changes to `this` is considered an argument change\n\nChanges to the running context (`this`) of a function can result in the function returning a different value even though its arguments have stayed the same:\n\n```js\nfunction getA() {\n  return this.a;\n}\n\nconst temp1 = {\n  a: 20,\n};\nconst temp2 = {\n  a: 30,\n};\n\ngetA.call(temp1); // 20\ngetA.call(temp2); // 30\n```\n\nTherefore, in order to prevent against unexpected results, `memoize-one` takes into account the current execution context (`this`) of the memoized function. If `this` is different to the previous invocation then it is considered a change in argument. [further discussion](https://github.com/alexreardon/memoize-one/issues/3).\n\nGenerally this will be of no impact if you are not explicity controlling the `this` context of functions you want to memoize with [explicit binding](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md#explicit-binding) or [implicit binding](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch2.md#implicit-binding). `memoize-One` will detect when you are manipulating `this` and will then consider the `this` context as an argument. If `this` changes, it will re-execute the original function even if the arguments have not changed.\n\n## Clearing the memoization cache\n\nA `.clear()` property is added to memoized functions to allow you to clear it's memoization cache.\n\nThis is helpful if you want to:\n\n- Release memory\n- Allow the underlying function to be called again without having to change arguments\n\n```ts\nimport memoizeOne from 'memoize-one';\n\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\nconst memoizedAdd = memoizeOne(add);\n\n// first call - not memoized\nconst first = memoizedAdd(1, 2);\n\n// second call - cache hit (underlying function not called)\nconst second = memoizedAdd(1, 2);\n\n// 👋 clearing memoization cache\nmemoizedAdd.clear();\n\n// third call - not memoized (cache was cleared)\nconst third = memoizedAdd(1, 2);\n```\n\n## When your result function `throw`s\n\n> There is no caching when your result function throws\n\nIf your result function `throw`s then the memoized function will also throw. The throw will not break the memoized functions existing argument cache. It means the memoized function will pretend like it was never called with arguments that made it `throw`.\n\n```js\nconst canThrow = (name: string) => {\n  console.log('called');\n  if (name === 'throw') {\n    throw new Error(name);\n  }\n  return { name };\n};\n\nconst memoized = memoizeOne(canThrow);\n\nconst value1 = memoized('Alex');\n// console.log => 'called'\nconst value2 = memoized('Alex');\n// result function not called\n\nconsole.log(value1 === value2);\n// console.log => true\n\ntry {\n  memoized('throw');\n  // console.log => 'called'\n} catch (e) {\n  firstError = e;\n}\n\ntry {\n  memoized('throw');\n  // console.log => 'called'\n  // the result function was called again even though it was called twice\n  // with the 'throw' string\n} catch (e) {\n  secondError = e;\n}\n\nconsole.log(firstError !== secondError);\n\nconst value3 = memoized('Alex');\n// result function not called as the original memoization cache has not been busted\nconsole.log(value1 === value3);\n// console.log => true\n```\n\n## Function properties\n\nFunctions memoized with `memoize-one` do not preserve any properties on the function object.\n\n> This behaviour correctly reflected in the TypeScript types\n\n```ts\nimport memoizeOne from 'memoize-one';\n\nfunction add(a, b) {\n  return a + b;\n}\nadd.hello = 'hi';\n\nconsole.log(typeof add.hello); // string\n\nconst memoized = memoizeOne(add);\n\n// hello property on the `add` was not preserved\nconsole.log(typeof memoized.hello); // undefined\n```\n\nIf you feel strongly that `memoize-one` _should_ preserve function properties, please raise an issue. This decision was made in order to keep `memoize-one` as light as possible.\n\nFor _now_, the `.length` property of a function is not preserved on the memoized function\n\n```ts\nimport memoizeOne from 'memoize-one';\n\nfunction add(a, b) {\n  return a + b;\n}\n\nconsole.log(add.length); // 2\n\nconst memoized = memoizeOne(add);\n\nconsole.log(memoized.length); // 0\n```\n\nThere is no (great) way to correctly set the `.length` property of the memoized function while also supporting ie11. Once we [remove ie11 support](https://github.com/alexreardon/memoize-one/issues/125) then we will set the `.length` property of the memoized function to match the original function\n\n[→ discussion](https://github.com/alexreardon/memoize-one/pull/124).\n\n## Memoized function `type`\n\nThe resulting function you get back from `memoize-one` has *almost* the same `type` as the function that you are memoizing\n\n```ts\ndeclare type MemoizedFn<TFunc extends (this: any, ...args: any[]) => any> = {\n  clear: () => void;\n  (this: ThisParameterType<TFunc>, ...args: Parameters<TFunc>): ReturnType<TFunc>;\n};\n```\n\n- the same call signature as the function being memoized\n- a `.clear()` function property added\n- other function object properties on `TFunc` as not carried over\n\nYou are welcome to use the `MemoizedFn` generic directly from `memoize-one` if you like:\n\n```ts\nimport memoize, { MemoizedFn } from 'memoize-one';\nimport isDeepEqual from 'lodash.isequal';\nimport { expectTypeOf } from 'expect-type';\n\n// Takes any function: TFunc, and returns a Memoized<TFunc>\nfunction withDeepEqual<TFunc extends (...args: any[]) => any>(fn: TFunc): MemoizedFn<TFunc> {\n  return memoize(fn, isDeepEqual);\n}\n\nfunction add(first: number, second: number): number {\n  return first + second;\n}\n\nconst memoized = withDeepEqual(add);\n\nexpectTypeOf<typeof memoized>().toEqualTypeOf<MemoizedFn<typeof add>>();\n```\n\nIn this specific example, this type would have been correctly inferred too\n\n```ts\nimport memoize, { MemoizedFn } from 'memoize-one';\nimport isDeepEqual from 'lodash.isequal';\nimport { expectTypeOf } from 'expect-type';\n\n// return type of MemoizedFn<TFunc> is inferred\nfunction withDeepEqual<TFunc extends (...args: any[]) => any>(fn: TFunc) {\n  return memoize(fn, isDeepEqual);\n}\n\nfunction add(first: number, second: number): number {\n  return first + second;\n}\n\nconst memoized = withDeepEqual(add);\n\n// type test still passes\nexpectTypeOf<typeof memoized>().toEqualTypeOf<MemoizedFn<typeof add>>();\n```\n\n## Performance 🚀\n\n### Tiny\n\n`memoize-one` is super lightweight at [![min](https://img.shields.io/bundlephobia/min/memoize-one.svg?label=)](https://www.npmjs.com/package/memoize-one) minified and [![minzip](https://img.shields.io/bundlephobia/minzip/memoize-one.svg?label=)](https://www.npmjs.com/package/memoize-one) gzipped. (`1KB` = `1,024 Bytes`)\n\n### Extremely fast\n\n`memoize-one` performs better or on par with than other popular memoization libraries for the purpose of remembering the latest invocation.\n\nThe comparisons are not exhaustive and are primarily to show that `memoize-one` accomplishes remembering the latest invocation really fast. There is variability between runs. The benchmarks do not take into account the differences in feature sets, library sizes, parse time, and so on.\n\n<details>\n  <summary>Expand for results</summary>\n  <p>\n\nnode version `16.11.1`\n\nYou can run this test in the repo by:\n\n1. Add `\"type\": \"module\"` to the `package.json` (why is things so hard)\n2. Run `yarn perf:library-comparison`\n\n**no arguments**\n\n| Position | Library                                      | Operations per second |\n| -------- | -------------------------------------------- | --------------------- |\n| 1        | memoize-one                                  | 80,112,981            |\n| 2        | moize                                        | 72,885,631            |\n| 3        | memoizee                                     | 35,550,009            |\n| 4        | mem (JSON.stringify strategy)                | 4,610,532             |\n| 5        | lodash.memoize (JSON.stringify key resolver) | 3,708,945             |\n| 6        | no memoization                               | 505                   |\n| 7        | fast-memoize                                 | 504                   |\n\n**single primitive argument**\n\n| Position | Library                                      | Operations per second |\n| -------- | -------------------------------------------- | --------------------- |\n| 1        | fast-memoize                                 | 45,482,711            |\n| 2        | moize                                        | 34,810,659            |\n| 3        | memoize-one                                  | 29,030,828            |\n| 4        | memoizee                                     | 23,467,065            |\n| 5        | mem (JSON.stringify strategy)                | 3,985,223             |\n| 6        | lodash.memoize (JSON.stringify key resolver) | 3,369,297             |\n| 7        | no memoization                               | 507                   |\n\n**single complex argument**\n\n| Position | Library                                      | Operations per second |\n| -------- | -------------------------------------------- | --------------------- |\n| 1        | moize                                        | 27,660,856            |\n| 2        | memoize-one                                  | 22,407,916            |\n| 3        | memoizee                                     | 19,546,835            |\n| 4        | mem (JSON.stringify strategy)                | 2,068,038             |\n| 5        | lodash.memoize (JSON.stringify key resolver) | 1,911,335             |\n| 6        | fast-memoize                                 | 1,633,855             |\n| 7        | no memoization                               | 504                   |\n\n**multiple primitive arguments**\n\n| Position | Library                                      | Operations per second |\n| -------- | -------------------------------------------- | --------------------- |\n| 1        | moize                                        | 22,366,497            |\n| 2        | memoize-one                                  | 17,241,995            |\n| 3        | memoizee                                     | 9,789,442             |\n| 4        | mem (JSON.stringify strategy)                | 3,065,328             |\n| 5        | lodash.memoize (JSON.stringify key resolver) | 2,663,599             |\n| 6        | fast-memoize                                 | 1,219,548             |\n| 7        | no memoization                               | 504                   |\n\n**multiple complex arguments**\n\n| Position | Library                                      | Operations per second |\n| -------- | -------------------------------------------- | --------------------- |\n| 1        | moize                                        | 21,788,081            |\n| 2        | memoize-one                                  | 17,321,248            |\n| 3        | memoizee                                     | 9,595,420             |\n| 4        | lodash.memoize (JSON.stringify key resolver) | 873,283               |\n| 5        | mem (JSON.stringify strategy)                | 850,779               |\n| 6        | fast-memoize                                 | 687,863               |\n| 7        | no memoization                               | 504                   |\n\n**multiple complex arguments (spreading arguments)**\n\n| Position | Library                                      | Operations per second |\n| -------- | -------------------------------------------- | --------------------- |\n| 1        | moize                                        | 21,701,537            |\n| 2        | memoizee                                     | 19,463,942            |\n| 3        | memoize-one                                  | 17,027,544            |\n| 4        | lodash.memoize (JSON.stringify key resolver) | 887,816               |\n| 5        | mem (JSON.stringify strategy)                | 849,244               |\n| 6        | fast-memoize                                 | 691,512               |\n| 7        | no memoization                               | 504                   |\n\n  </p>\n</details>\n\n## Code health 👍\n\n- Tested with all built in [JavaScript types](https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/types%20%26%20grammar/ch1.md)\n- Written in `Typescript`\n- Correct typing for `Typescript` and `flow` type systems\n- No dependencies\n",
    "licenseText": "MIT License\n\nCopyright (c) 2019 Alexander Reardon\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/memoize-one/-/memoize-one-6.0.0.tgz#b2591b871ed82948aee4727dc6abceeeac8c1045",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/memoize-one/-/memoize-one-6.0.0.tgz",
    "hash": "b2591b871ed82948aee4727dc6abceeeac8c1045",
    "integrity": "sha512-rkpe71W0N0c0Xz6QD0eJETuWAJGnJ9afsl1srmwPrI+yBCkge5EycXXbYRyvL29zZVUWQCY7InPRCv3GDXuZNw==",
    "registry": "npm",
    "packageName": "memoize-one",
    "cacheIntegrity": "sha512-rkpe71W0N0c0Xz6QD0eJETuWAJGnJ9afsl1srmwPrI+yBCkge5EycXXbYRyvL29zZVUWQCY7InPRCv3GDXuZNw== sha1-slkbhx7YKUiu5HJ9xqvO7qyMEEU="
  },
  "registry": "npm",
  "hash": "b2591b871ed82948aee4727dc6abceeeac8c1045"
}