{
  "manifest": {
    "name": "fraction.js",
    "title": "fraction.js",
    "version": "4.2.0",
    "homepage": "https://www.xarg.org/2014/03/rational-numbers-in-javascript/",
    "bugs": {
      "url": "https://github.com/infusion/Fraction.js/issues"
    },
    "description": "A rational number library",
    "keywords": [
      "math",
      "fraction",
      "rational",
      "rationals",
      "number",
      "parser",
      "rational numbers"
    ],
    "author": {
      "name": "Robert Eisele",
      "email": "robert@xarg.org",
      "url": "http://www.xarg.org/"
    },
    "main": "fraction",
    "types": "./fraction.d.ts",
    "private": false,
    "readmeFilename": "README.md",
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "git://github.com/infusion/Fraction.js.git"
    },
    "funding": {
      "type": "patreon",
      "url": "https://www.patreon.com/infusion"
    },
    "engines": {
      "node": "*"
    },
    "scripts": {
      "test": "mocha tests/*.js"
    },
    "devDependencies": {
      "mocha": "*"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-fraction-js-4.2.0-448e5109a313a3527f5a3ab2119ec4cf0e0e2950-integrity/node_modules/fraction.js/package.json",
    "readme": "# Fraction.js - ℚ in JavaScript\n\n[![NPM Package](https://nodei.co/npm-dl/fraction.js.png?months=6&height=1)](https://npmjs.org/package/fraction.js)\n\n[![Build Status](https://travis-ci.org/infusion/Fraction.js.svg?branch=master)](https://travis-ci.org/infusion/Fraction.js)\n[![MIT license](http://img.shields.io/badge/license-MIT-brightgreen.svg)](http://opensource.org/licenses/MIT)\n\n\nTired of inprecise numbers represented by doubles, which have to store rational and irrational numbers like PI or sqrt(2) the same way? Obviously the following problem is preventable:\n\n```javascript\n1 / 98 * 98 // = 0.9999999999999999\n```\n\nIf you need more precision or just want a fraction as a result, have a look at *Fraction.js*:\n\n```javascript\nvar Fraction = require('fraction.js');\n\nFraction(1).div(98).mul(98) // = 1\n```\n\nInternally, numbers are represented as *numerator / denominator*, which adds just a little overhead. However, the library is written with performance in mind and outperforms any other implementation, as you can see [here](http://jsperf.com/convert-a-rational-number-to-a-babylonian-fractions/28). This basic data-type makes it the perfect basis for [Polynomial.js](https://github.com/infusion/Polynomial.js) and [Math.js](https://github.com/josdejong/mathjs).\n\nConvert decimal to fraction\n===\nThe simplest job for fraction.js is to get a fraction out of a decimal:\n```javascript\nvar x = new Fraction(1.88);\nvar res = x.toFraction(true); // String \"1 22/25\"\n```\n\nExamples / Motivation\n===\nA simple example might be\n\n```javascript\nvar f = new Fraction(\"9.4'31'\"); // 9.4313131313131...\nf.mul([-4, 3]).mod(\"4.'8'\"); // 4.88888888888888...\n```\nThe result is\n\n```javascript\nconsole.log(f.toFraction()); // -4154 / 1485\n```\nYou could of course also access the sign (s), numerator (n) and denominator (d) on your own:\n```javascript\nf.s * f.n / f.d = -1 * 4154 / 1485 = -2.797306...\n```\n\nIf you would try to calculate it yourself, you would come up with something like:\n\n```javascript\n(9.4313131 * (-4 / 3)) % 4.888888 = -2.797308133...\n```\n\nQuite okay, but yea - not as accurate as it could be.\n\n\nLaplace Probability\n===\nSimple example. What's the probability of throwing a 3, and 1 or 4, and 2 or 4 or 6 with a fair dice?\n\nP({3}):\n```javascript\nvar p = new Fraction([3].length, 6).toString(); // 0.1(6)\n```\n\nP({1, 4}):\n```javascript\nvar p = new Fraction([1, 4].length, 6).toString(); // 0.(3)\n```\n\nP({2, 4, 6}):\n```javascript\nvar p = new Fraction([2, 4, 6].length, 6).toString(); // 0.5\n```\n\nConvert degrees/minutes/seconds to precise rational representation:\n===\n\n57+45/60+17/3600\n```javascript\nvar deg = 57; // 57°\nvar min = 45; // 45 Minutes\nvar sec = 17; // 17 Seconds\n\nnew Fraction(deg).add(min, 60).add(sec, 3600).toString() // -> 57.7547(2)\n```\n\nRounding a fraction to the closest tape measure value\n=== \n\nA tape measure is usually divided in parts of `1/16`. Rounding a given fraction to the closest value on a tape measure can be determined by\n\n```javascript\nfunction closestTapeMeasure(frac) {\n\n    /*\n    k/16 ≤ a/b < (k+1)/16\n    ⇔ k ≤ 16*a/b < (k+1)\n    ⇔ k = floor(16*a/b)\n    */\n    return new Fraction(Math.round(16 * Fraction(frac).valueOf()), 16);\n}\n// closestTapeMeasure(\"1/3\") // 5/16\n```\n\nRational approximation of irrational numbers\n===\n\nNow it's getting messy ;d To approximate a number like *sqrt(5) - 2* with a numerator and denominator, you can reformat the equation as follows: *pow(n / d + 2, 2) = 5*.\n\nThen the following algorithm will generate the rational number besides the binary representation.\n\n```javascript\nvar x = \"/\", s = \"\";\n\nvar a = new Fraction(0),\n    b = new Fraction(1);\nfor (var n = 0; n <= 10; n++) {\n\n  var c = a.add(b).div(2);\n\n  console.log(n + \"\\t\" + a + \"\\t\" + b + \"\\t\" + c + \"\\t\" + x);\n\n  if (c.add(2).pow(2) < 5) {\n    a = c;\n    x = \"1\";\n  } else {\n    b = c;\n    x = \"0\";\n  }\n  s+= x;\n}\nconsole.log(s)\n```\n\nThe result is\n\n```\nn   a[n]        b[n]        c[n]            x[n]\n0   0/1         1/1         1/2             /\n1   0/1         1/2         1/4             0\n2   0/1         1/4         1/8             0\n3   1/8         1/4         3/16            1\n4   3/16        1/4         7/32            1\n5   7/32        1/4         15/64           1\n6   15/64       1/4         31/128          1\n7   15/64       31/128      61/256          0\n8   15/64       61/256      121/512         0\n9   15/64       121/512     241/1024        0\n10  241/1024    121/512     483/2048        1\n```\nThus the approximation after 11 iterations of the bisection method is *483 / 2048* and the binary representation is 0.00111100011 (see [WolframAlpha](http://www.wolframalpha.com/input/?i=sqrt%285%29-2+binary))\n\n\nI published another example on how to approximate PI with fraction.js on my [blog](http://www.xarg.org/2014/03/precise-calculations-in-javascript/) (Still not the best idea to approximate irrational numbers, but it illustrates the capabilities of Fraction.js perfectly).\n\n\nGet the exact fractional part of a number\n---\n```javascript\nvar f = new Fraction(\"-6.(3416)\");\nconsole.log(\"\" + f.mod(1).abs()); // Will print 0.(3416)\n```\n\nMathematical correct modulo\n---\nThe behaviour on negative congruences is different to most modulo implementations in computer science. Even the *mod()* function of Fraction.js behaves in the typical way. To solve the problem of having the mathematical correct modulo with Fraction.js you could come up with this:\n\n```javascript\nvar a = -1;\nvar b = 10.99;\n\nconsole.log(new Fraction(a)\n  .mod(b)); // Not correct, usual Modulo\n\nconsole.log(new Fraction(a)\n  .mod(b).add(b).mod(b)); // Correct! Mathematical Modulo\n```\n\nfmod() impreciseness circumvented\n---\nIt turns out that Fraction.js outperforms almost any fmod() implementation, including JavaScript itself, [php.js](http://phpjs.org/functions/fmod/), C++, Python, Java and even Wolframalpha due to the fact that numbers like 0.05, 0.1, ... are infinite decimal in base 2.\n\nThe equation *fmod(4.55, 0.05)* gives *0.04999999999999957*, wolframalpha says *1/20*. The correct answer should be **zero**, as 0.05 divides 4.55 without any remainder.\n\n\nParser\n===\n\nAny function (see below) as well as the constructor of the *Fraction* class parses its input and reduce it to the smallest term.\n\nYou can pass either Arrays, Objects, Integers, Doubles or Strings.\n\nArrays / Objects\n---\n```javascript\nnew Fraction(numerator, denominator);\nnew Fraction([numerator, denominator]);\nnew Fraction({n: numerator, d: denominator});\n```\n\nIntegers\n---\n```javascript\nnew Fraction(123);\n```\n\nDoubles\n---\n```javascript\nnew Fraction(55.4);\n```\n\n**Note:** If you pass a double as it is, Fraction.js will perform a number analysis based on Farey Sequences. If you concern performance, cache Fraction.js objects and pass arrays/objects.\n\nThe method is really precise, but too large exact numbers, like 1234567.9991829 will result in a wrong approximation. If you want to keep the number as it is, convert it to a string, as the string parser will not perform any further observations. If you have problems with the approximation, in the file `examples/approx.js` is a different approximation algorithm, which might work better in some more specific use-cases.\n\n\nStrings\n---\n```javascript\nnew Fraction(\"123.45\");\nnew Fraction(\"123/45\"); // A rational number represented as two decimals, separated by a slash\nnew Fraction(\"123:45\"); // A rational number represented as two decimals, separated by a colon\nnew Fraction(\"4 123/45\"); // A rational number represented as a whole number and a fraction\nnew Fraction(\"123.'456'\"); // Note the quotes, see below!\nnew Fraction(\"123.(456)\"); // Note the brackets, see below!\nnew Fraction(\"123.45'6'\"); // Note the quotes, see below!\nnew Fraction(\"123.45(6)\"); // Note the brackets, see below!\n```\n\nTwo arguments\n---\n```javascript\nnew Fraction(3, 2); // 3/2 = 1.5\n```\n\nRepeating decimal places\n---\n*Fraction.js* can easily handle repeating decimal places. For example *1/3* is *0.3333...*. There is only one repeating digit. As you can see in the examples above, you can pass a number like *1/3* as \"0.'3'\" or \"0.(3)\", which are synonym. There are no tests to parse something like 0.166666666 to 1/6! If you really want to handle this number, wrap around brackets on your own with the function below for example: 0.1(66666666)\n\nAssume you want to divide 123.32 / 33.6(567). [WolframAlpha](http://www.wolframalpha.com/input/?i=123.32+%2F+%2812453%2F370%29) states that you'll get a period of 1776 digits. *Fraction.js* comes to the same result. Give it a try:\n\n```javascript\nvar f = new Fraction(\"123.32\");\nconsole.log(\"Bam: \" + f.div(\"33.6(567)\"));\n```\n\nTo automatically make a number like \"0.123123123\" to something more Fraction.js friendly like \"0.(123)\", I hacked this little brute force algorithm in a 10 minutes. Improvements are welcome...\n\n```javascript\nfunction formatDecimal(str) {\n\n  var comma, pre, offset, pad, times, repeat;\n\n  if (-1 === (comma = str.indexOf(\".\")))\n    return str;\n\n  pre = str.substr(0, comma + 1);\n  str = str.substr(comma + 1);\n\n  for (var i = 0; i < str.length; i++) {\n\n    offset = str.substr(0, i);\n\n    for (var j = 0; j < 5; j++) {\n\n      pad = str.substr(i, j + 1);\n\n      times = Math.ceil((str.length - offset.length) / pad.length);\n\n      repeat = new Array(times + 1).join(pad); // Silly String.repeat hack\n\n      if (0 === (offset + repeat).indexOf(str)) {\n        return pre + offset + \"(\" + pad + \")\";\n      }\n    }\n  }\n  return null;\n}\n\nvar f, x = formatDecimal(\"13.0123123123\"); // = 13.0(123)\nif (x !== null) {\n  f = new Fraction(x);\n}\n```\n\nAttributes\n===\n\nThe Fraction object allows direct access to the numerator, denominator and sign attributes. It is ensured that only the sign-attribute holds sign information so that a sign comparison is only necessary against this attribute.\n\n```javascript\nvar f = new Fraction('-1/2');\nconsole.log(f.n); // Numerator: 1\nconsole.log(f.d); // Denominator: 2\nconsole.log(f.s); // Sign: -1\n```\n\n\nFunctions\n===\n\nFraction abs()\n---\nReturns the actual number without any sign information\n\nFraction neg()\n---\nReturns the actual number with flipped sign in order to get the additive inverse\n\nFraction add(n)\n---\nReturns the sum of the actual number and the parameter n\n\nFraction sub(n)\n---\nReturns the difference of the actual number and the parameter n\n\nFraction mul(n)\n---\nReturns the product of the actual number and the parameter n\n\nFraction div(n)\n---\nReturns the quotient of the actual number and the parameter n\n\nFraction pow(exp)\n---\nReturns the power of the actual number, raised to an possible rational exponent. If the result becomes non-rational the function returns `null`.\n\nFraction mod(n)\n---\nReturns the modulus (rest of the division) of the actual object and n (this % n). It's a much more precise [fmod()](#fmod-impreciseness-circumvented) if you will. Please note that *mod()* is just like the modulo operator of most programming languages. If you want a mathematical correct modulo, see [here](#mathematical-correct-modulo).\n\nFraction mod()\n---\nReturns the modulus (rest of the division) of the actual object (numerator mod denominator)\n\nFraction gcd(n)\n---\nReturns the fractional greatest common divisor\n\nFraction lcm(n)\n---\nReturns the fractional least common multiple\n\nFraction ceil([places=0-16])\n---\nReturns the ceiling of a rational number with Math.ceil\n\nFraction floor([places=0-16])\n---\nReturns the floor of a rational number with Math.floor\n\nFraction round([places=0-16])\n---\nReturns the rational number rounded with Math.round\n\nFraction inverse()\n---\nReturns the multiplicative inverse of the actual number (n / d becomes d / n) in order to get the reciprocal\n\nFraction simplify([eps=0.001])\n---\nSimplifies the rational number under a certain error threshold. Ex. `0.333` will be `1/3` with `eps=0.001`\n\nboolean equals(n)\n---\nCheck if two numbers are equal\n\nint compare(n)\n---\nCompare two numbers.\n```\nresult < 0: n is greater than actual number\nresult > 0: n is smaller than actual number\nresult = 0: n is equal to the actual number\n```\n\nboolean divisible(n)\n---\nCheck if two numbers are divisible (n divides this)\n\ndouble valueOf()\n---\nReturns a decimal representation of the fraction\n\nString toString([decimalPlaces=15])\n---\nGenerates an exact string representation of the actual object. For repeated decimal places all digits are collected within brackets, like `1/3 = \"0.(3)\"`. For all other numbers, up to `decimalPlaces` significant digits are collected - which includes trailing zeros if the number is getting truncated. However, `1/2 = \"0.5\"` without trailing zeros of course.\n\n**Note:** As `valueOf()` and `toString()` are provided, `toString()` is only called implicitly in a real string context. Using the plus-operator like `\"123\" + new Fraction` will call valueOf(), because JavaScript tries to combine two primitives first and concatenates them later, as string will be the more dominant type. `alert(new Fraction)` or `String(new Fraction)` on the other hand will do what you expect. If you really want to have control, you should call `toString()` or `valueOf()` explicitly!\n\nString toLatex(excludeWhole=false)\n---\nGenerates an exact LaTeX representation of the actual object. You can see a [live demo](http://www.xarg.org/2014/03/precise-calculations-in-javascript/) on my blog.\n\nThe optional boolean parameter indicates if you want to exclude the whole part. \"1 1/3\" instead of \"4/3\"\n\nString toFraction(excludeWhole=false)\n---\nGets a string representation of the fraction\n\nThe optional boolean parameter indicates if you want to exclude the whole part. \"1 1/3\" instead of \"4/3\"\n\nArray toContinued()\n---\nGets an array of the fraction represented as a continued fraction. The first element always contains the whole part.\n\n```javascript\nvar f = new Fraction('88/33');\nvar c = f.toContinued(); // [2, 1, 2]\n```\n\nFraction clone()\n---\nCreates a copy of the actual Fraction object\n\n\nExceptions\n===\nIf a really hard error occurs (parsing error, division by zero), *fraction.js* throws exceptions! Please make sure you handle them correctly.\n\n\n\nInstallation\n===\nInstalling fraction.js is as easy as cloning this repo or use one of the following commands:\n\n```\nbower install fraction.js\n```\nor\n\n```\nnpm install fraction.js\n```\n\nUsing Fraction.js with the browser\n===\n```html\n<script src=\"fraction.js\"></script>\n<script>\n    console.log(Fraction(\"123/456\"));\n</script>\n```\n\nUsing Fraction.js with require.js\n===\n```html\n<script src=\"require.js\"></script>\n<script>\nrequirejs(['fraction.js'],\nfunction(Fraction) {\n    console.log(Fraction(\"123/456\"));\n});\n</script>\n```\n\nUsing Fraction.js with TypeScript\n===\n```js\nimport Fraction from \"fraction.js\";\nconsole.log(Fraction(\"123/456\"));\n```\n\nCoding Style\n===\nAs every library I publish, fraction.js is also built to be as small as possible after compressing it with Google Closure Compiler in advanced mode. Thus the coding style orientates a little on maxing-out the compression rate. Please make sure you keep this style if you plan to extend the library.\n\n\nPrecision\n===\nFraction.js tries to circumvent floating point errors, by having an internal representation of numerator and denominator. As it relies on JavaScript, there is also a limit. The biggest number representable is `Number.MAX_SAFE_INTEGER / 1` and the smallest is `-1 / Number.MAX_SAFE_INTEGER`, with `Number.MAX_SAFE_INTEGER=9007199254740991`. If this is not enough, there is `bigfraction.js` shipped experimentally, which relies on `BigInt` and should become the new Fraction.js eventually. \n\nTesting\n===\nIf you plan to enhance the library, make sure you add test cases and all the previous tests are passing. You can test the library with\n\n```\nnpm test\n```\n\n\nCopyright and licensing\n===\nCopyright (c) 2014-2019, [Robert Eisele](https://www.xarg.org/)\nDual licensed under the MIT or GPL Version 2 licenses.\n",
    "licenseText": "MIT License\n\nCopyright (c) 2017 Robert Eisele\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/fraction.js/-/fraction.js-4.2.0.tgz#448e5109a313a3527f5a3ab2119ec4cf0e0e2950",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/fraction.js/-/fraction.js-4.2.0.tgz",
    "hash": "448e5109a313a3527f5a3ab2119ec4cf0e0e2950",
    "integrity": "sha512-MhLuK+2gUcnZe8ZHlaaINnQLl0xRIGRfcGk2yl8xoQAfHrSsL3rYu6FCmBdkdbhc9EPlwyGHewaRsvwRMJtAlA==",
    "registry": "npm",
    "packageName": "fraction.js",
    "cacheIntegrity": "sha512-MhLuK+2gUcnZe8ZHlaaINnQLl0xRIGRfcGk2yl8xoQAfHrSsL3rYu6FCmBdkdbhc9EPlwyGHewaRsvwRMJtAlA== sha1-RI5RCaMTo1J/WjqyEZ7Ezw4OKVA="
  },
  "registry": "npm",
  "hash": "448e5109a313a3527f5a3ab2119ec4cf0e0e2950"
}