{
  "manifest": {
    "name": "@bugsnag/cuid",
    "version": "3.0.0",
    "description": "Collision-resistant ids optimized for horizontal scaling and performance. For node and browsers.",
    "author": {
      "name": "Bugsnag",
      "url": "https://bugsnag.com"
    },
    "main": "index.js",
    "browser": {
      "./lib/fingerprint.js": "./lib/fingerprint.browser.js"
    },
    "react-native": {
      "./lib/fingerprint.js": "./lib/fingerprint.react-native.js"
    },
    "keywords": [
      "id",
      "guid",
      "uid",
      "unique id",
      "uuid"
    ],
    "repository": {
      "type": "git",
      "url": "https://github.com/bugsnag/cuid.git"
    },
    "license": "MIT",
    "devDependencies": {
      "browserify": "14.4.0",
      "eslint": "^3.9.1",
      "karma": "^1.7.0",
      "karma-browserify": "^5.1.1",
      "karma-chrome-launcher": "^2.2.0",
      "karma-tap": "^3.1.1",
      "mkdirp": "^0.5.1",
      "tape": "^4.6.2",
      "uglify-js": "^2.7.4",
      "watchify": "3.9.0",
      "webworkify": "^1.4.0"
    },
    "scripts": {
      "build": "mkdirp dist && browserify index.js -s cuid -o dist/cuid.js && uglifyjs dist/cuid.js -c -m -o dist/cuid.min.js",
      "lint": "eslint index.js lib test",
      "test": "npm run lint && npm run test:server && npm run test:browser",
      "test:browser": "karma start test/karma.conf.js",
      "test:server": "tape test/**/*.js",
      "prepublish": "npm run build"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-@bugsnag-cuid-3.0.0-integrity/node_modules/@bugsnag/cuid/package.json",
    "readmeFilename": "README.md",
    "readme": "# cuid\n[![Travis-CI](https://travis-ci.org/ericelliott/cuid.svg)](https://travis-ci.org/ericelliott/cuid)\n\nCollision-resistant ids optimized for horizontal scaling and binary search lookup performance.\n\nCurrently available for Node, browsers, Ruby, .Net, Go, PHP and Elixir (see ports below -- more ports are welcome).\n\n`cuid()` returns a short random string with some collision-busting measures. Safe to use as HTML element ID's, and unique server-side record lookups.\n\n## Example\n\nNode style. For the browser, either bundle with something like [browserify](https://github.com/substack/node-browserify) or [webpack](http://webpack.github.io/), or use the stand-alone version and leave off the require line.\n\n```js\nvar cuid = require('cuid');\nconsole.log( cuid() );\n\n// ch72gsb320000udocl363eofy\n```\n\n## Installing\n\n```\n$ npm install --save cuid\n```\n\nor download the stand-alone version from [`./dist`](https://github.com/ericelliott/cuid/tree/master/dist).\n\n\n### Broken down\n\n** c - h72gsb32 - 0000 - udoc - l363eofy **\n\nThe groups, in order, are:\n\n* 'c' - identifies this as a cuid, and allows you to use it in html entity ids.\n* Timestamp\n* Counter - a single process might generate the same random string. The weaker the pseudo-random source, the higher the probability. That problem gets worse as processors get faster. The counter will roll over if the value gets too big.\n* Client fingerprint\n* Pseudo random (`Math.random()` in JavaScript)\n\n## Fingerprints\n\n**In browsers**, the first chars are obtained from the user agent string (which is fairly unique), and the supported mimeTypes (which is also fairly unique, except for IE, which always returns 0).\nThat string is concatenated with a count of variables in the global scope (which is also fairly unique), and the result is trimmed to 4 chars.\n\n**In node**, the first two chars are extracted from the process.pid. The next two chars are extracted from the hostname.\n\n\n## Motivation\n\nModern web applications have different requirements than applications from just a few years ago. Our modern unique identifiers have a stricter list of requirements that cannot all be satisfied by any existing version of the GUID/UUID specifications:\n\n### Horizontal scalability\n\nToday's applications don't run on any single machine.\n\nApplications might need to support online / offline capability, which means we need a way for clients on different hosts to generate ids that won't collide with ids generated by other hosts -- even if they're not connected to the network.\n\nMost pseudo-random algorithms use time in ms as a random seed. Random IDs lack sufficient entropy when running in separate processes (such as cloned virtual machines or client browsers) to guarantee against collisions. Application developers report v4 UUID collisions causing problems in their applications when the ID generation is distributed between lots of machines such that lots of IDs are generated in the same millisecond.\n\nEach new client exponentially increases the chance of collision in the same way that each new character in a random string exponentially reduces the chance of collision. Successful apps scale at hundreds or thousands of new clients per day, so fighting the lack of entropy by adding random characters is a losing strategy.\n\nBecause of the nature of this problem, it's possible to build an app from the ground up and scale it to a million users before this problem rears its head. By the time you notice the problem (when your peak hour use requires dozens of ids to be created per ms), if your db doesn't have unique constraints on the id because you thought your guids were safe, you're in a world of hurt. Your users start to see data that doesn't belong to them because the db just returns the first ID match it finds.\n\nAlternatively, you've played it safe and you only let your database create ids. Writes only happen on a master database, and load is spread out over read replicas. But with this kind of strain, you have to start scaling your database writes horizontally, too, and suddenly your application starts to crawl (if the db is smart enough to guarantee unique ids between write hosts), or you start getting id collisions between different db hosts, so your write hosts don't agree about which ids represent which data.\n\n\n### Performance\n\nBecause entities might need to be generated in high-performance loops, id generation should be fast. That means no waiting around for asynchronous entropy pool requests, or cross-process/cross-network communication. Performance slows to impracticality in the browser. All sources of entropy need to be fast enough for synchronous access.\n\nEven worse, when the database is the only guarantee that ids are unique, that means that clients are forced to send incomplete records to the database, and wait for a network round-trip before they can use the ids in any algorithm. Forget about fast client performance. It simply isn't possible.\n\nThat situation has caused some clients to create ids that are only usable in a single client session (such as an in-memory counter). When the database returns the real id, the client has to do some juggling logic to swap out the id being used.\n\nIf client side ID generation were stronger, the chances of collision would be much smaller, and the client could send complete records to the db for insertion without waiting for a full round-trip request to finish before using the ID.\n\n\n#### Monotonically increasing IDs\n\nCuids generated by the same process are monotonically increasing, when less than 10000 cuids are generated within the same millisecond. Generated by different processes, the cuids will still have an increasing value in time if the process clocks are synchronized.\n\nMonotonically increasing IDs are suitable for use as [high-performance database primary keys](http://code.openark.org/blog/mysql/monotonic-functions-sql-and-mysql), because they can be binary searched. Pure pseudo-random variants don't meet this requirement.\n\n\n#### Tiny\n\nSomewhat related to performance, an algorithm to generate an ID should require a tiny implementation. This is especially important for thick-client JavaScript applications.\n\n\n### Security\n\nClient-visible ids often need to have sufficient random data that it becomes practically impossible to try to guess valid IDs based on an existing, known id. That makes simple sequential ids unusable in the context of client-side generated database keys.\n\n\n#### Portability\n\nMost stronger forms of the UUID / GUID algorithms require access to OS services that are not available in browsers, meaning that they are impossible to implement as specified.\n\n\n# Features of cuids\n\n## Scalable\n\nBecause of the timestamp and the counter, cuid is really good at generating unique IDs on one machine.\n\nBecause of the fingerprints, cuid is also good at preventing collisions between multiple clients.\n\n\n## Fast\n\nBecause cuids can be safely generated synchronously, you can generate a lot of them quickly. Since it's unlikely that you'll get a collision, you don't have to wait for a round trip to the database just to insert a complete record in your database.\n\nBecause cuids are monotonically increasing, database primary key performance gets a significant boost.\n\nWeighing in at less than 1k minified and compressed, the cuid source should be suitable for even the lightest-weight mobile clients, and will not have a significant impact on the download time of your app, particularly if you follow best practices and concatenate it with the rest of your code in order to avoid the latency hit of an extra file request.\n\n## Secure\n\nCuids contain enough random data and moving parts as to make guessing another id based on an existing id practically impossible. It also opens up a way to detect for abuse attempts -- if a client requests large blocks of ids that don't exist, there's a good chance that the client is malicious, or trying to get at data that doesn't belong to it.\n\n\n## Portable\n\nThe only part of a cuid that might be hard to replicate between different clients is the fingerprint. It's easy to override the fingerprint method in order to port to different clients. Cuid already works standalone in browsers, or as a node module, so you can use cuid where you need to use it.\n\nThe algorithm is also easy to reproduce in other languages. You are encouraged to port it to whatever language you see fit.\n\n### Ports:\n\n* JavaScript (Browsers & Node)\n* [cuid for Ruby](https://github.com/iyshannon/cuid) - [Ian Shannon](https://github.com/iyshannon)\n* [cuid for .Net](https://github.com/moonpyk/ncuid ) - [Cl√©ment Bourgeois](https://github.com/moonpyk)\n* [cuid for Go](http://github.com/lucsky/cuid) - [Luc Heinrich](https://github.com/lucsky)\n* [cuid for PHP](https://github.com/endyjasmi/cuid) - [Endy Jasmi](https://github.com/endyjasmi)\n* [cuid for Elixir](https://github.com/duailibe/cuid) - [Lucas Duailibe](https://github.com/duailibe)\n* [cuid for Haskell](https://github.com/crabmusket/hscuid) - [Daniel Buckmaster](https://github.com/crabmusket)\n* [cuid for Python](https://github.com/necaris/cuid.py) - [Rami Chowdhury](https://github.com/necaris)\n* [cuid for Clojure](https://github.com/hden/cuid) - [Hao-kang Den](https://github.com/hden)\n* [cuid for Java](https://github.com/graphcool/cuid-java) - [Nilan Marktanner](https://github.com/marktani)\n\n\n# Short URLs\n\nNeed a smaller ID? `cuid.slug()` is for you. With 7 to 10 characters, `.slug()` is a great solution for short urls. Slugs may grow up to 10 characters as the internal counter increases. They're good for things like URL slug disambiguation (i.e., `example.com/some-post-title-<slug>`) but **absolutely not recommended for database unique IDs**. Stick to the full cuid for database keys.\n\nBe aware, slugs:\n\n* are less likely to be monotonically increasing. Stick to full cuids for database lookups, if possible.\n\n* have less random data, less room for the counter, and less room for the fingerprint, which means that all of them are more likely to collide or be guessed, especially as CPU speeds increase.\n\nDon't use them if guessing an existing ID would expose confidential information to malicious users. For example, if you're providing a service like Google Drive or DropBox, which hosts user's private files, favor `cuid()` over `.slug()`.\n\n\n# Questions\n\n### Is this a replacement for GUID / UUID?\n\nNo. Cuid is great for the use case it was designed for -- to generate ids for applications which need to be scalable past tens or hundreds of new entities per second across multiple id-generating hosts. In other words, if you're building a web or mobile app and want the assurance that your choice of id standards isn't going to slow you down, cuid is for you.\n\nHowever, if you need to obscure the order of id generation, or if it's potentially problematic to know the precise time that an id was generated, you'll want to go with something different.\n\nCuids should not be considered cryptographically secure (but neither should most guid algorithms. Make sure yours is using a crypto library before you rely on it).\n\n\n### Why don't you use sha1, md5, etc?\n\nA sha1 implementation in JavaScript is about 300 lines by itself, uncompressed, and its use would provide little benefit. For contrast, the cuid source code weighs in at less than 100 lines of code, uncompressed. It also comes at considerable performance cost. Md5 has similar issues.\n\n\n### Why are there no dashes?\n\nAlmost all web-technology identifiers allow numbers and letters (though some require you to begin with a letter -- hence the 'c' at the beginning of a cuid). However, dashes are not allowed in some identifier names. Removing dashes between groups allows the ids to be more portable. Also, identifier groupings should not be relied on in your application. Removing them should discourage application developers from trying to extract data from a cuid.\n\nThe cuid specification should not be considered an API contract. Code that relies on the groupings as laid out here should be considered brittle and not be used in production.\n\n\n### [Submit a Question or Comment](https://github.com/dilvie/cuid/issues/new?title=Question)\n\n\n### Credit\n\nCreated by Eric Elliott, Author, [\"Programming JavaScript Applications (O'Reilly)\"](https://ericelliottjs.com/product/programming-javascript-applications-ebook/)\n\nThanks to [Tout](http://tout.com/) for support and production testing.\n",
    "licenseText": "cuid is covered by The MIT License:\n\nCopyright (c) 2012 Eric Elliott\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmjs.org/@bugsnag/cuid/-/cuid-3.0.0.tgz",
    "type": "tarball",
    "reference": "https://registry.npmjs.org/@bugsnag/cuid/-/cuid-3.0.0.tgz",
    "hash": "",
    "integrity": "sha512-LOt8aaBI+KvOQGneBtpuCz3YqzyEAehd1f3nC5yr9TIYW1+IzYKa2xWS4EiMz5pPOnRPHkyyS5t/wmSmN51Gjg==",
    "registry": "npm",
    "packageName": "@bugsnag/cuid",
    "cacheIntegrity": "sha512-LOt8aaBI+KvOQGneBtpuCz3YqzyEAehd1f3nC5yr9TIYW1+IzYKa2xWS4EiMz5pPOnRPHkyyS5t/wmSmN51Gjg== sha1-LudkKjCu5tyG9ef4JGU3QeQuXDU="
  },
  "registry": "npm",
  "hash": "2ceb7c69a048f8abce4069de06da6e0b3dd8ab3c8401e85dd5fde70b9cabf532185b5f88cd829adb1592e0488ccf9a4f3a744f1e4cb24b9b7fc264a6379d468e"
}