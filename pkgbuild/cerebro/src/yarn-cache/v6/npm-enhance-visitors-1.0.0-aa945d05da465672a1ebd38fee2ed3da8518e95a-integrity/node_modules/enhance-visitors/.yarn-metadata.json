{
  "manifest": {
    "name": "enhance-visitors",
    "version": "1.0.0",
    "description": "Enhance your ESLint visitors with shared logic",
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/jfmengels/enhance-visitors.git"
    },
    "author": {
      "name": "Jeroen Engels",
      "email": "jfm.engels@gmail.com",
      "url": "github.com/jfmengels"
    },
    "engines": {
      "node": ">=4.0.0"
    },
    "scripts": {
      "test": "xo && nyc ava"
    },
    "files": [
      "index.js"
    ],
    "keywords": [
      "eslint",
      "plugin",
      "eslint-plugin",
      "eslintplugin",
      "enhance",
      "visitor",
      "visitors",
      "ast"
    ],
    "dependencies": {
      "lodash": "^4.13.1"
    },
    "devDependencies": {
      "ava": "^0.15.2",
      "coveralls": "^2.11.9",
      "nyc": "^6.4.0",
      "xo": "^0.16.0"
    },
    "nyc": {
      "reporter": [
        "lcov",
        "text"
      ]
    },
    "xo": {
      "esnext": true,
      "space": 2
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-enhance-visitors-1.0.0-aa945d05da465672a1ebd38fee2ed3da8518e95a-integrity/node_modules/enhance-visitors/package.json",
    "readmeFilename": "readme.md",
    "readme": "# enhance-visitors [![Build Status](https://travis-ci.org/jfmengels/enhance-visitors.svg?branch=master)](https://travis-ci.org/jfmengels/enhance-visitors) [![Coverage Status](https://coveralls.io/repos/github/jfmengels/enhance-visitors/badge.svg?branch=master)](https://coveralls.io/github/jfmengels/enhance-visitors?branch=master)\n\n> Enhance your ESLint visitors with shared logic.\n\n## Install\n\n```\n$ npm install --save enhance-visitors\n```\n\n\n## Purpose\n\nThe purpose of this tool is to simplify the writing of rules with common logic. Extract the common logic into a separate file, and then write rules to build on top.\n\n\n### Traversal order\n\nFor the enhancer, the traversal is done just as usual, one node at a time. The traversal is not done all at once for the enhancer, and then all at once for the rule implementation.\nRather, it's done one Node at a time, first for the enhancer (or rather, whatever you put first )\nbut rather the\n\n## API\n\n### .mergeVisitors([visitors])\n\nMerges multiple visitor objects, so that all visitors for a node type are ran one after the other, in first-to-last order. For `<type>:exit` visitors, they are traversed last-to-first.\n\n#### visitors: `object[]`\n\nAn array of visitor objects, such as `{CallExpression: fn1, Identifier: fn2, ...}`.\n\n#### Example\n\n```js\nconst enhance = require('enhance-visitors');\n\nfunction log(message) {\n  return function() {\n    console.log(message);\n  };\n}\n\nmodule.exports = function(context) {\n  return enhance.mergeVisitors([\n    {\n      'CallExpression': log('1 - CallExpression entry'),\n      'CallExpression:exit': log('1 - CallExpression exit')\n    },\n    {\n      'CallExpression': log('2 - CallExpression entry'),\n      'CallExpression:exit': log('2 - CallExpression exit')\n    }\n  ]);\n}\n```\n\nGiven the following code: `foo()`, it should print\n```\n1 - CallExpression entry\n2 - CallExpression entry\n2 - CallExpression exit\n1 - CallExpression exit\n```\n\n\n#### Usage example: Detection of a package import\n\nLet's say you have a npm package called `unicorn`, and that you are writing an ESLint plugin for it, so that users use it as intended and avoid pitfalls. You will write multiple rules for it, and most or all of them will need to know which variable references `unicorn`.\n\n```js\nimport uni from 'unicorn'; // <-- The variable `uni` references my package\n```\n\nIn order not to have to write the same detection logic in every one of your rules, let's write an enhancer. In this example, we will write it in `<root>/rules/core/unicornSeeker.js`. We'll keep it simple and only detect an import using the `import` keyword and not using `require`, and then only with the `ImportDefaultSpecifier` syntax.\n\n```js\nmodule.exports = function enhance(imports) {\n  return {\n    ImportDeclaration: function (node) {\n      if (node.source.value === 'unicorn') {\n        node.specifiers.forEach(function (specifier) {\n          if (specifier.type === 'ImportDefaultSpecifier') {\n            imports.unicorn = specifier.local.name;\n          }\n        });\n      }\n    }\n  };\n};\n```\n\nThis visitors object will be traversed along and before your rule implementation. What it does is traverse your AST, find `ImportDeclaration` nodes, and store relevant information in `imports`.\nThen in your rule file (`<root>/rules/no-unknown-methods.js`, which detects methods that do not exist in the package), we'll have:\n\n```js\nconst enhance = require('enhance-visitors');\nconst unicornSeeker = require('./core/unicornSeeker');\n\nconst existingMethods = [\n  'makeRainbow', 'trample', 'flyWithGrace'\n];\n\nmodule.exports = function (context) {\n  const imports = {};\n\n  return enhance.mergeVisitors([ // Noteworthy line 1\n    unicornSeekerEnhancer(imports), // Noteworthy line 2\n    {\n      CallExpression: function (node) {\n        const callee = node.callee;\n        if (callee.type === 'MemberExpression' &&\n          callee.object.type === 'Identifier' &&\n          callee.object.name === imports.unicorn && // Noteworthy line 3\n          callee.property.type === 'Identifier' &&\n          existingMethods.indexOf(callee.property.name) === -1\n        ) {\n          context.report({\n            node: node,\n            message: 'Unknown `unicorn` method ' + callee.property.name\n          });\n        }\n      }\n    }\n  ]);\n};\n```\n\nIt looks pretty much like a normal rule implementation, but there are a few differences.\nIn `Noteworthy line 1 & 2`, we are merging the `unicornSeeker` enhancer we wrote earlier with the rule implementation. This will make `unicornSeeker` traverse the AST and collect information that we can then use like we did in `Noteworthy line 3`.\n\n### .visitIf([predicates])\n\nReturns a function `fn` that takes a visitor function `visitor`. When `fn` is called (usually an AST node), `visitor` will get called with the same argument only if all predicates, also called with the same argument, return a truthy value.\n\nThis essentially allows writing less and/or shorter reusable conditions inside your visitor.\n\n#### predicates: `function[]`\n\nAn array of predicate functions, that take a AST node as argument and return a boolean.\n\n#### Example\n\n```js\nconst enhance = require('enhance-visitors');\n\nfunction isRequireCall(node) {\n  return node &&\n    node.callee &&\n    node.callee.type === 'Identifier' &&\n    node.callee.name === 'require' &&\n    node.arguments.length === 1 &&\n    node.arguments[0].type === 'Literal';\n}\n\nmodule.exports = function(context) {\n  return {\n    CallExpression: enhance.visitIf([isRequireCall])(node => {\n      if (node.arguments[0] !== 'unicorn') {\n        context.report({\n          node,\n          message: 'You only need to use `unicorn`'\n        })\n      }\n    })\n  };\n}\n```\n\n## License\n\nMIT Â© [Jeroen Engels](https://github.com/jfmengels)\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) Jeroen Engels <jfm.engels@gmail.com> (github.com/jfmengels)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/enhance-visitors/-/enhance-visitors-1.0.0.tgz#aa945d05da465672a1ebd38fee2ed3da8518e95a",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/enhance-visitors/-/enhance-visitors-1.0.0.tgz",
    "hash": "aa945d05da465672a1ebd38fee2ed3da8518e95a",
    "integrity": "sha512-+29eJLiUixTEDRaZ35Vu8jP3gPLNcQQkQkOQjLp2X+6cZGGPDD/uasbFzvLsJKnGZnvmyZ0srxudwOtskHeIDA==",
    "registry": "npm",
    "packageName": "enhance-visitors",
    "cacheIntegrity": "sha512-+29eJLiUixTEDRaZ35Vu8jP3gPLNcQQkQkOQjLp2X+6cZGGPDD/uasbFzvLsJKnGZnvmyZ0srxudwOtskHeIDA== sha1-qpRdBdpGVnKh69OP7i7T2oUY6Vo="
  },
  "registry": "npm",
  "hash": "aa945d05da465672a1ebd38fee2ed3da8518e95a"
}