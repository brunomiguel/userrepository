{
  "manifest": {
    "name": "regexp-tree",
    "version": "0.1.24",
    "license": "MIT",
    "description": "Regular Expressions parser in JavaScript",
    "repository": {
      "type": "git",
      "url": "https://github.com/DmitrySoshnikov/regexp-tree.git"
    },
    "homepage": "https://github.com/DmitrySoshnikov/regexp-tree",
    "bugs": {
      "url": "https://github.com/DmitrySoshnikov/regexp-tree/issues"
    },
    "scripts": {
      "build": "node scripts/build.js",
      "watch": "node scripts/build.js --watch",
      "test": "jest",
      "prepublish": "npm run build && npm test",
      "eslint": "eslint src/ && eslint bin/regexp-tree"
    },
    "bin": {
      "regexp-tree": "bin/regexp-tree"
    },
    "keywords": [
      "regexp",
      "parser",
      "AST",
      "tree",
      "JavaScript",
      "ECMAScript"
    ],
    "author": {
      "name": "Dmitry Soshnikov"
    },
    "devDependencies": {
      "babel-cli": "^6.26.0",
      "babel-preset-env": "1.6.1",
      "babel-preset-flow": "6.23.0",
      "eslint": "^4.11.0",
      "jest-cli": "^19.0.2",
      "prettier": "^1.17.1",
      "shelljs": "^0.7.8",
      "syntax-cli": "^0.1.11"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-regexp-tree-0.1.24-3d6fa238450a4d66e5bc9c4c14bb720e2196829d-integrity/node_modules/regexp-tree/package.json",
    "readmeFilename": "README.md",
    "readme": "# regexp-tree\n\n[![Build Status](https://travis-ci.org/DmitrySoshnikov/regexp-tree.svg?branch=master)](https://travis-ci.org/DmitrySoshnikov/regexp-tree) [![npm version](https://badge.fury.io/js/regexp-tree.svg)](https://badge.fury.io/js/regexp-tree) [![npm downloads](https://img.shields.io/npm/dt/regexp-tree.svg)](https://www.npmjs.com/package/regexp-tree)\n\nRegular expressions processor in JavaScript\n\nTL;DR: **RegExp Tree** is a _regular expressions processor_, which includes _parser_, _traversal_, _transformer_, _optimizer_, and _interpreter_ APIs.\n\nYou can get an overview of the tool in [this article](https://medium.com/@DmitrySoshnikov/regexp-tree-a-regular-expressions-parser-with-a-simple-ast-format-bcd4d5580df6).\n\n### Table of Contents\n\n- [Installation](#installation)\n- [Development](#development)\n- [Usage as a CLI](#usage-as-a-cli)\n- [Usage from Node](#usage-from-node)\n- [Capturing locations](#capturing-locations)\n- [Parsing options](#parsing-options)\n- [Using traversal API](#using-traversal-api)\n- [Using transform API](#using-transform-api)\n  - [Transform plugins](#transform-plugins)\n- [Using generator API](#using-generator-api)\n- [Using optimizer API](#using-optimizer-api)\n  - [Optimizer ESLint plugin](#optimizer-eslint-plugin)\n- [Using compat-transpiler API](#using-compat-transpiler-api)\n  - [Compat-transpiler Babel plugin](#compat-transpiler-babel-plugin)\n- [RegExp extensions](#regexp-extensions)\n  - [RegExp extensions Babel plugin](#regexp-extensions-babel-plugin)\n- [Creating RegExp objects](#creating-regexp-objects)\n- [Executing regexes](#executing-regexes)\n- [Using interpreter API](#using-interpreter-api)\n  - [Printing NFA/DFA tables](#printing-nfadfa-tables)\n- [AST nodes specification](#ast-nodes-specification)\n\n### Installation\n\nThe parser can be installed as an [npm module](https://www.npmjs.com/package/regexp-tree):\n\n```\nnpm install -g regexp-tree\n```\n\nYou can also [try it online](https://astexplorer.net/#/gist/4ea2b52f0e546af6fb14f9b2f5671c1c/39b55944da3e5782396ffa1fea3ba68d126cd394) using _AST Explorer_.\n\n### Development\n\n1. Fork https://github.com/DmitrySoshnikov/regexp-tree repo\n2. If there is an actual issue from the [issues](https://github.com/DmitrySoshnikov/regexp-tree/issues) list you'd like to work on, feel free to assign it yourself, or comment on it to avoid collisions (open a new issue if needed)\n3. Make your changes\n4. Make sure `npm test` still passes (add new tests if needed)\n5. Submit a PR\n\nThe _regexp-tree_ parser is implemented as an automatic LR parser using [Syntax](https://www.npmjs.com/package/syntax-cli) tool. The parser module is generated from the [regexp grammar](https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/parser/regexp.bnf), which is based on the regular expressions grammar used in ECMAScript.\n\nFor development from the github repository, run `build` command to generate the parser module, and transpile JS code:\n\n```\ngit clone https://github.com/<your-github-account>/regexp-tree.git\ncd regexp-tree\nnpm install\nnpm run build\n```\n\n> NOTE: JS code transpilation is used to support older versions of Node. For faster development cycle you can use `npm run watch` command, which continuously transpiles JS code.\n\n### Usage as a CLI\n\n**Note:** the CLI is exposed as its own [regexp-tree-cli](https://www.npmjs.com/package/regexp-tree-cli) module.\n\nCheck the options available from CLI:\n\n```\nregexp-tree-cli --help\n```\n\n```\nUsage: regexp-tree-cli [options]\n\nOptions:\n   -e, --expression   A regular expression to be parsed\n   -l, --loc          Whether to capture AST node locations\n   -o, --optimize     Applies optimizer on the passed expression\n   -c, --compat       Applies compat-transpiler on the passed expression\n   -t, --table        Print NFA/DFA transition tables (nfa/dfa/all)\n```\n\nTo parse a regular expression, pass `-e` option:\n\n```\nregexp-tree-cli -e '/a|b/i'\n```\n\nWhich produces an AST node corresponding to this regular expression:\n\n```js\n{\n  type: 'RegExp',\n  body: {\n    type: 'Disjunction',\n    left: {\n      type: 'Char',\n      value: 'a',\n      symbol: 'a',\n      kind: 'simple',\n      codePoint: 97\n    },\n    right: {\n      type: 'Char',\n      value: 'b',\n      symbol: 'b',\n      kind: 'simple',\n      codePoint: 98\n    }\n  },\n  flags: 'i',\n}\n```\n\n> NOTE: the format of a regexp is `/ Body / OptionalFlags`.\n\n### Usage from Node\n\nThe parser can also be used as a Node module:\n\n```js\nconst regexpTree = require('regexp-tree');\n\nconsole.log(regexpTree.parse(/a|b/i)); // RegExp AST\n```\n\nNote, _regexp-tree_ supports parsing regexes from strings, and also from actual `RegExp` objects (in general -- from any object which can be coerced to a string). If some feature is not implemented yet in an actual JavaScript RegExp, it should be passed as a string:\n\n```js\n// Pass an actual JS RegExp object.\nregexpTree.parse(/a|b/i);\n\n// Pass a string, since `s` flag may not be supported in older versions.\nregexpTree.parse('/./s');\n```\n\nAlso note, that in string-mode, escaping is done using two slashes `\\\\` per JavaScript:\n\n```js\n// As an actual regexp.\nregexpTree.parse(/\\n/);\n\n// As a string.\nregexpTree.parse('/\\\\n/');\n```\n\n### Capturing locations\n\nFor source code transformation tools it might be useful also to capture _locations_ of the AST nodes. From the command line it's controlled via the `-l` option:\n\n```\nregexp-tree-cli -e '/ab/' -l\n```\n\nThis attaches `loc` object to each AST node:\n\n```js\n{\n  type: 'RegExp',\n  body: {\n    type: 'Alternative',\n    expressions: [\n      {\n        type: 'Char',\n        value: 'a',\n        symbol: 'a',\n        kind: 'simple',\n        codePoint: 97,\n        loc: {\n          start: {\n            line: 1,\n            column: 1,\n            offset: 1,\n          },\n          end: {\n            line: 1,\n            column: 2,\n            offset: 2,\n          },\n        }\n      },\n      {\n        type: 'Char',\n        value: 'b',\n        symbol: 'b',\n        kind: 'simple',\n        codePoint: 98,\n        loc: {\n          start: {\n            line: 1,\n            column: 2,\n            offset: 2,\n          },\n          end: {\n            line: 1,\n            column: 3,\n            offset: 3,\n          },\n        }\n      }\n    ],\n    loc: {\n      start: {\n        line: 1,\n        column: 1,\n        offset: 1,\n      },\n      end: {\n        line: 1,\n        column: 3,\n        offset: 3,\n      },\n    }\n  },\n  flags: '',\n  loc: {\n    start: {\n      line: 1,\n      column: 0,\n      offset: 0,\n    },\n    end: {\n      line: 1,\n      column: 4,\n      offset: 4,\n    },\n  }\n}\n```\n\nFrom Node it's controlled via `setOptions` method exposed on the parser:\n\n```js\nconst regexpTree = require('regexp-tree');\n\nconst parsed = regexpTree\n  .parser\n  .setOptions({captureLocations: true})\n  .parse(/a|b/);\n```\n\nThe `setOptions` method sets global options, which are preserved between calls. It is also possible to provide options per a single `parse` call, which might be more preferred:\n\n```js\nconst regexpTree = require('regexp-tree');\n\nconst parsed = regexpTree.parse(/a|b/, {\n  captureLocations: true,\n});\n```\n\n### Parsing options\n\nThe parser supports several options which can be set globally via the `setOptions` method on the parser, or by passing them with each `parse` method invocation.\n\nExample:\n\n```js\nconst regexpTree = require('regexp-tree');\n\nconst parsed = regexpTree.parse(/a|b/, {\n  allowGroupNameDuplicates: true,\n});\n```\n\nThe following options are supported:\n\n- `captureLocations: boolean` -- whether to capture AST node [locations](#capturing-locations) (`false` by default)\n- `allowGroupNameDuplicates: boolean` -- whether to skip duplicates check of the [named capturing groups](#named-capturing-group)\n\nSet `allowGroupNameDuplicates` would make the following expression possible:\n\n```regexp\n/\n  # YYY-MM-DD date format:\n\n  (?<year>  \\d{4}) -\n  (?<month> \\d{2}) -\n  (?<day>   \\d{2})\n\n  |\n\n  # DD.MM.YYY date format\n\n  (?<day>   \\d{2}) .\n  (?<month> \\d{2}) .\n  (?<year>  \\d{4})\n\n/x\n```\n\n### Using traversal API\n\nThe [traverse](https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/traverse) module allows handling needed AST nodes using the _visitor_ pattern. In Node the module is exposed as the `regexpTree.traverse` method. Handlers receive an instance of the [NodePath](https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/traverse/README.md#nodepath-class) class, which encapsulates `node` itself, its `parent` node, `property`, and `index` (in case the node is part of a collection).\n\nVisiting a node follows this algorithm:\n- call `pre` handler.\n- recurse into node's children.\n- call `post` handler.\n\nFor each node type of interest, you can provide either:\n- a function (`pre`).\n- an object with members `pre` and `post`.\n\nYou can also provide a `*` handler which will be executed on every node.\n\nExample:\n\n```js\nconst regexpTree = require('regexp-tree');\n\n// Get AST.\nconst ast = regexpTree.parse('/[a-z]{1,}/');\n\n// Traverse AST nodes.\nregexpTree.traverse(ast, {\n\n  // Visit every node before any type-specific handlers.\n  '*': function({node}) {\n    ...\n  },\n\n  // Handle \"Quantifier\" node type.\n  Quantifier({node}) {\n    ...\n  },\n\n  // Handle \"Char\" node type, before and after.\n  Char: {\n    pre({node}) {\n      ...\n    },\n    post({node}) {\n      ...\n    }\n  }\n\n});\n\n// Generate the regexp.\nconst re = regexpTree.generate(ast);\n\nconsole.log(re); // '/[a-z]+/'\n```\n\n### Using transform API\n\n> NOTE: you can play with transformation APIs, and write actual transforms for quick tests in AST Explorer. See [this example](http://astexplorer.net/#/gist/d293d22742b42cd1f7ee7b7e5dc6f697/39b0aabc42fb6fb106b9e368341d3300098f08c0).\n\nWhile traverse module provides basic traversal API, which can be used for any purposes of AST handling, _transform_ module focuses mainly on _transformation_ of regular expressions.\n\nIt accepts a regular expressions in different formats (string, an actual `RegExp` object, or an AST), applies a set of transformations, and retuns an instance of [TransformResult](https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/transform/README.md#transformresult). Handles receive as a parameter the same [NodePath](https://github.com/DmitrySoshnikov/regexp-tree/blob/master/src/traverse/README.md#nodepath-class) object used in traverse.\n\nExample:\n\n```js\nconst regexpTree = require('regexp-tree');\n\n// Handle nodes.\nconst re = regexpTree.transform('/[a-z]{1,}/i', {\n\n  /**\n   * Handle \"Quantifier\" node type,\n   * transforming `{1,}` quantifier to `+`.\n   */\n  Quantifier(path) {\n    const {node} = path;\n\n    // {1,} -> +\n    if (\n      node.kind === 'Range' &&\n      node.from === 1 &&\n      !node.to\n    ) {\n      path.replace({\n        type: 'Quantifier',\n        kind: '+',\n        greedy: node.greedy,\n      });\n    }\n  },\n});\n\nconsole.log(re.toString()); // '/[a-z]+/i'\nconsole.log(re.toRegExp()); // /[a-z]+/i\nconsole.log(re.getAST()); // AST for /[a-z]+/i\n```\n\n#### Transform plugins\n\nA _transformation plugin_ is a module which exports a _transformation handler_. We have seen [above](#using-transform-api) how we can pass a handler object directly to the `regexpTree.transform` method, here we extract it into a separate module, so it can be implemented and shared independently:\n\nExample of a plugin:\n\n```js\n// file: ./regexp-tree-a-to-b-transform.js\n\n\n/**\n * This plugin replaces chars 'a' with chars 'b'.\n */\nmodule.exports = {\n  Char({node}) {\n    if (node.kind === 'simple' && node.value === 'a') {\n      node.value = 'b';\n      node.symbol = 'b';\n      node.codePoint = 98;\n    }\n  },\n};\n```\n\nOnce we have this plugin ready, we can require it, and pass to the `transform` function:\n\n```js\nconst regexpTree = require('regexp-tree');\nconst plugin = require('./regexp-tree-a-to-b-transform');\n\nconst re = regexpTree.transform(/(a|c)a+[a-z]/, plugin);\n\nconsole.log(re.toRegExp()); // /(b|c)b+[b-z]/\n```\n\n> NOTE: we can also pass a _list of plugins_ to the `regexpTree.transform`. In this case the plugins are applied in one pass in order. Another approach is to run several sequential calls to `transform`, setting up a pipeline, when a transformed AST is passed further to another plugin, etc.\n\nYou can see other examples of transform plugins in the [optimizer/transforms](https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer/transforms) or in the [compat-transpiler/transforms](https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/compat-transpiler/transforms) directories.\n\n### Using generator API\n\nThe [generator](https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/generator) module generates regular expressions from corresponding AST nodes. In Node the module is exposed as `regexpTree.generate` method.\n\nExample:\n\n```js\nconst regexpTree = require('regexp-tree');\n\nconst re = regexpTree.generate({\n  type: 'RegExp',\n  body: {\n    type: 'Char',\n    value: 'a',\n    symbol: 'a',\n    kind: 'simple',\n    codePoint: 97\n  },\n  flags: 'i',\n});\n\nconsole.log(re); // '/a/i'\n```\n\n### Using optimizer API\n\n[Optimizer](https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer) transforms your regexp into an _optimized_ version, replacing some sub-expressions with their idiomatic patterns. This might be good for different kinds of minifiers, as well as for regexp machines.\n\n> NOTE: the Optimizer is implemented as a set of _regexp-tree_ [plugins](#transform-plugins).\n\nExample:\n\n```js\nconst regexpTree = require('regexp-tree');\n\nconst originalRe = /[a-zA-Z_0-9][A-Z_\\da-z]*\\e{1,}/;\n\nconst optimizedRe = regexpTree\n  .optimize(originalRe)\n  .toRegExp();\n\nconsole.log(optimizedRe); // /\\w+e+/\n```\n\nFrom CLI the optimizer is available via `--optimize` (`-o`) option:\n\n```\nregexp-tree-cli -e '/[a-zA-Z_0-9][A-Z_\\da-z]*\\e{1,}/' -o\n```\n\nResult:\n\n```\nOptimized: /\\w+e+/\n```\n\nSee the [optimizer README](https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer) for more details.\n\n#### Optimizer ESLint plugin\n\nThe [optimizer](https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/optimizer) module is also available as an _ESLint plugin_, which can be installed at: [eslint-plugin-optimize-regex](https://www.npmjs.com/package/eslint-plugin-optimize-regex).\n\n### Using compat-transpiler API\n\nThe [compat-transpiler](https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/compat-transpiler) module translates your regexp in new format or in new syntax, into an equivalent regexp in a legacy representation, so it can be used in engines which don't yet implement the new syntax.\n\n> NOTE: the compat-transpiler is implemented as a set of _regexp-tree_ [plugins](#transform-plugins).\n\nExample, \"dotAll\" `s` flag:\n\n\n```js\n/./s\n```\n\nIs translated into:\n\n```js\n/[\\0-\\uFFFF]/\n```\n\nOr [named capturing groups](#named-capturing-group):\n\n```js\n/(?<value>a)\\k<value>\\1/\n```\n\nBecomes:\n\n```js\n/(a)\\1\\1/\n```\n\nTo use the API from Node:\n\n```js\nconst regexpTree = require('regexp-tree');\n\n// Using new syntax.\nconst originalRe = '/(?<all>.)\\\\k<all>/s';\n\n// For legacy engines.\nconst compatTranspiledRe = regexpTree\n  .compatTranspile(originalRe)\n  .toRegExp();\n\nconsole.log(compatTranspiledRe); // /([\\0-\\uFFFF])\\1/\n```\n\nFrom CLI the compat-transpiler is available via `--compat` (`-c`) option:\n\n```\nregexp-tree-cli -e '/(?<all>.)\\k<all>/s' -c\n```\n\nResult:\n\n```\nCompat: /([\\0-\\uFFFF])\\1/\n```\n\n#### Compat-transpiler Babel plugin\n\nThe [compat-transpiler](https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/compat-transpiler) module is also available as a _Babel plugin_, which can be installed at: [babel-plugin-transform-modern-regexp](https://www.npmjs.com/package/babel-plugin-transform-modern-regexp).\n\nNote, the plugin also includes [extended regexp](#regexp-extensions) features.\n\n### RegExp extensions\n\nSome of the _non-standard_ feature are also supported by _regexp-tree_.\n\n> NOTE: _\"non-standard\"_ means specifically ECMAScript standard, since in other regexp egnines, e.g. PCRE, Python, etc. these features are standard.\n\nOne of such features is the `x` flag, which enables _extended_ mode of regular expressions. In this mode most of whitespaces are ignored, and expressions can use #-comments.\n\nExample:\n\n```regex\n/\n  # A regular expression for date.\n\n  (?<year>\\d{4})-    # year part of a date\n  (?<month>\\d{2})-   # month part of a date\n  (?<day>\\d{2})      # day part of a date\n\n/x\n```\n\nThis is normally parsed by the _regexp-tree_ parser, and [compat-transpiler](#using-compat-transpiler-api) has full support for it; it's translated into:\n\n```regex\n/(\\d{4})-(\\d{2})-(\\d{2})/\n```\n\n#### RegExp extensions Babel plugin\n\nThe regexp extensions are also available as a _Babel plugin_, which can be installed at: [babel-plugin-transform-modern-regexp](https://www.npmjs.com/package/babel-plugin-transform-modern-regexp).\n\nNote, the plugin also includes [compat-transpiler](#using-compat-transpiler-api) features.\n\n### Creating RegExp objects\n\nTo create an actual `RegExp` JavaScript object, we can use `regexpTree.toRegExp` method:\n\n```js\nconst regexpTree = require('regexp-tree');\n\nconst re = regexpTree.toRegExp('/[a-z]/i');\n\nconsole.log(\n  re.test('a'), // true\n  re.test('Z'), // true\n);\n```\n\n### Executing regexes\n\nIt is also possible to execute regular expressions using `exec` API method, which has support for new syntax, and features, such as [named capturing group](#named-capturing-group), etc:\n\n```js\nconst regexpTree = require('regexp-tree');\n\nconst re = `/\n\n  # A regular expression for date.\n\n  (?<year>\\\\d{4})-    # year part of a date\n  (?<month>\\\\d{2})-   # month part of a date\n  (?<day>\\\\d{2})      # day part of a date\n\n/x`;\n\nconst string = '2017-04-14';\n\nconst result = regexpTree.exec(re, string);\n\nconsole.log(result.groups); // {year: '2017', month: '04', day: '14'}\n```\n\n### Using interpreter API\n\n> NOTE: you can read more about implementation details of the interpreter in [this series of articles](https://medium.com/@DmitrySoshnikov/building-a-regexp-machine-part-1-regular-grammars-d4986b585d7e).\n\nIn addition to executing regular expressions using JavaScript built-in RegExp engine, RegExp Tree also implements own [interpreter](https://github.com/DmitrySoshnikov/regexp-tree/tree/master/src/interpreter/finite-automaton) based on classic NFA/DFA finite automaton engine.\n\nCurrently it aims educational purposes -- to trace the regexp matching process, transitioning in NFA/DFA states. It also allows building state transitioning table, which can be used for custom implementation. In API the module is exposed as `fa` (finite-automaton) object.\n\nExample:\n\n```js\nconst {fa} = require('regexp-tree');\n\nconst re = /ab|c*/;\n\nconsole.log(fa.test(re, 'ab')); // true\nconsole.log(fa.test(re, '')); // true\nconsole.log(fa.test(re, 'c')); // true\n\n// NFA, and its transition table.\nconst nfa = fa.toNFA(re);\nconsole.log(nfa.getTransitionTable());\n\n// DFA, and its transition table.\nconst dfa = fa.toDFA(re);\nconsole.log(dfa.getTransitionTable());\n```\n\nFor more granular work with NFA and DFA, `fa` module also exposes convenient builders, so you can build NFA fragments directly:\n\n```js\nconst {fa} = require('regexp-tree');\n\nconst {\n  alt,\n  char,\n  or,\n  rep,\n} = fa.builders;\n\n// ab|c*\nconst re = or(\n  alt(char('a'), char('b')),\n  rep(char('c'))\n);\n\nconsole.log(re.matches('ab')); // true\nconsole.log(re.matches('')); // true\nconsole.log(re.matches('c')); // true\n\n// Build DFA from NFA\nconst {DFA} = fa;\n\nconst reDFA = new DFA(re);\n\nconsole.log(reDFA.matches('ab')); // true\nconsole.log(reDFA.matches('')); // true\nconsole.log(reDFA.matches('c')); // true\n```\n\n#### Printing NFA/DFA tables\n\nThe `--table` option allows displaying NFA/DFA transition tables. RegExp Tree also applies _DFA minimization_ (using _N-equivalence_ algorithm), and produces the minimal transition table as its final result.\n\nIn the example below for the `/a|b|c/` regexp, we first obtain the NFA transition table, which is further converted to the original DFA transition table (down from the 10 non-deterministic states to 4 deterministic states), and eventually minimized to the final DFA table (from 4 to only 2 states).\n\n```\n./bin/regexp-tree-cli -e '/a|b|c/' --table all\n```\n\nResult:\n\n```\n> - starting\nâœ“ - accepting\n\nNFA transition table:\n\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚     â”‚ a â”‚ b â”‚ c  â”‚ Îµ*          â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ 1 > â”‚   â”‚   â”‚    â”‚ {1,2,3,7,9} â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ 2   â”‚   â”‚   â”‚    â”‚ {2,3,7}     â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ 3   â”‚ 4 â”‚   â”‚    â”‚ 3           â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ 4   â”‚   â”‚   â”‚    â”‚ {4,5,6}     â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ 5   â”‚   â”‚   â”‚    â”‚ {5,6}       â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ 6 âœ“ â”‚   â”‚   â”‚    â”‚ 6           â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ 7   â”‚   â”‚ 8 â”‚    â”‚ 7           â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ 8   â”‚   â”‚   â”‚    â”‚ {8,5,6}     â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ 9   â”‚   â”‚   â”‚ 10 â”‚ 9           â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ 10  â”‚   â”‚   â”‚    â”‚ {10,6}      â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n\nDFA: Original transition table:\n\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”\nâ”‚     â”‚ a â”‚ b â”‚ c â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤\nâ”‚ 1 > â”‚ 4 â”‚ 3 â”‚ 2 â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤\nâ”‚ 2 âœ“ â”‚   â”‚   â”‚   â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤\nâ”‚ 3 âœ“ â”‚   â”‚   â”‚   â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤\nâ”‚ 4 âœ“ â”‚   â”‚   â”‚   â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜\n\n\nDFA: Minimized transition table:\n\nâ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”\nâ”‚     â”‚ a â”‚ b â”‚ c â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤\nâ”‚ 1 > â”‚ 2 â”‚ 2 â”‚ 2 â”‚\nâ”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤\nâ”‚ 2 âœ“ â”‚   â”‚   â”‚   â”‚\nâ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜\n```\n\n### AST nodes specification\n\nBelow are the AST node types for different regular expressions patterns:\n\n- [Char](#char)\n  - [Simple char](#simple-char)\n  - [Escaped char](#escaped-char)\n  - [Meta char](#meta-char)\n  - [Control char](#control-char)\n  - [Hex char-code](#hex-char-code)\n  - [Decimal char-code](#decimal-char-code)\n  - [Octal char-code](#octal-char-code)\n  - [Unicode](#unicode)\n- [Character class](#character-class)\n  - [Positive character class](#positive-character-class)\n  - [Negative character class](#negative-character-class)\n  - [Character class ranges](#character-class-ranges)\n- [Unicode properties](#unicode-properties)\n- [Alternative](#alternative)\n- [Disjunction](#disjunction)\n- [Groups](#groups)\n  - [Capturing group](#capturing-group)\n  - [Named capturing group](#named-capturing-group)\n  - [Non-capturing group](#non-capturing-group)\n  - [Backreferences](#backreferences)\n- [Quantifiers](#quantifiers)\n  - [? zero-or-one](#-zero-or-one)\n  - [* zero-or-more](#-zero-or-more)\n  - [+ one-or-more](#-one-or-more)\n  - [Range-based quantifiers](#range-based-quantifiers)\n    - [Exact number of matches](#exact-number-of-matches)\n    - [Open range](#open-range)\n    - [Closed range](#closed-range)\n  - [Non-greedy](#non-greedy)\n- [Assertions](#assertions)\n  - [^ begin marker](#-begin-marker)\n  - [$ end marker](#-end-marker)\n  - [Boundary assertions](#boundary-assertions)\n  - [Lookahead assertions](#lookahead-assertions)\n    - [Positive lookahead assertion](#positive-lookahead-assertion)\n    - [Negative lookahead assertion](#negative-lookahead-assertion)\n  - [Lookbehind assertions](#lookbehind-assertions)\n    - [Positive lookbehind assertion](#positive-lookbehind-assertion)\n    - [Negative lookbehind assertion](#negative-lookbehind-assertion)\n\n#### Char\n\nA basic building block, single character. Can be _escaped_, and be of different _kinds_.\n\n##### Simple char\n\nBasic _non-escaped_ char in a regexp:\n\n```\nz\n```\n\nNode:\n\n```js\n{\n  type: 'Char',\n  value: 'z',\n  symbol: 'z',\n  kind: 'simple',\n  codePoint: 122\n}\n```\n\n> NOTE: to test this from CLI, the char should be in an actual regexp -- `/z/`.\n\n##### Escaped char\n\n```\n\\z\n```\n\nThe same value, `escaped` flag is added:\n\n```js\n{\n  type: 'Char',\n  value: 'z',\n  symbol: 'z',\n  kind: 'simple',\n  codePoint: 122,\n  escaped: true\n}\n```\n\nEscaping is mostly used with meta symbols:\n\n```\n// Syntax error\n*\n```\n\n```\n\\*\n```\n\nOK, node:\n\n```js\n{\n  type: 'Char',\n  value: '*',\n  symbol: '*',\n  kind: 'simple',\n  codePoint: 42,\n  escaped: true\n}\n```\n\n##### Meta char\n\nA _meta character_ should not be confused with an [escaped char](#escaped-char).\n\nExample:\n\n```\n\\n\n```\n\nNode:\n\n```js\n{\n  type: 'Char',\n  value: '\\\\n',\n  symbol: '\\n',\n  kind: 'meta',\n  codePoint: 10\n}\n```\n\nAmong other meta character are: `.`, `\\f`, `\\r`, `\\n`, `\\t`, `\\v`, `\\0`, `[\\b]` (backspace char), `\\s`, `\\S`, `\\w`, `\\W`, `\\d`, `\\D`.\n\n> NOTE: Meta characters representing ranges (like `.`, `\\s`, etc.) have `undefined` value for `symbol` and `NaN` for `codePoint`.\n\n> NOTE: `\\b` and `\\B` are parsed as `Assertion` node type, not `Char`.\n\n##### Control char\n\nA char preceded with `\\c`, e.g. `\\cx`, which stands for `CTRL+x`:\n\n```\n\\cx\n```\n\nNode:\n\n```js\n{\n  type: 'Char',\n  value: '\\\\cx',\n  symbol: undefined,\n  kind: 'control',\n  codePoint: NaN\n}\n```\n\n##### HEX char-code\n\nA char preceded with `\\x`, followed by a HEX-code, e.g. `\\x3B` (symbol `;`):\n\n```\n\\x3B\n```\n\nNode:\n\n```js\n{\n  type: 'Char',\n  value: '\\\\x3B',\n  symbol: ';',\n  kind: 'hex',\n  codePoint: 59\n}\n```\n\n##### Decimal char-code\n\nChar-code:\n\n```\n\\42\n```\n\nNode:\n\n```js\n{\n  type: 'Char',\n  value: '\\\\42',\n  symbol: '*',\n  kind: 'decimal',\n  codePoint: 42\n}\n```\n\n##### Octal char-code\n\nChar-code started with `\\0`, followed by an octal number:\n\n```\n\\073\n```\n\nNode:\n\n```js\n{\n  type: 'Char',\n  value: '\\\\073',\n  symbol: ';',\n  kind: 'oct',\n  codePoint: 59\n}\n```\n\n##### Unicode\n\nUnicode char started with `\\u`, followed by a hex number:\n\n```\n\\u003B\n```\n\nNode:\n\n```js\n{\n  type: 'Char',\n  value: '\\\\u003B',\n  symbol: ';',\n  kind: 'unicode',\n  codePoint: 59\n}\n```\n\nWhen using the `u` flag, unicode chars can also be represented using `\\u` followed by a hex number between curly braces:\n\n```\n\\u{1F680}\n```\n\nNode:\n\n```js\n{\n  type: 'Char',\n  value: '\\\\u{1F680}',\n  symbol: 'ðŸš€',\n  kind: 'unicode',\n  codePoint: 128640\n}\n```\n\nWhen using the `u` flag, unicode chars can also be represented using a surrogate pair:\n\n```\n\\ud83d\\ude80\n```\n\nNode:\n\n```js\n{\n  type: 'Char',\n  value: '\\\\ud83d\\\\ude80',\n  symbol: 'ðŸš€',\n  kind: 'unicode',\n  codePoint: 128640,\n  isSurrogatePair: true\n}\n```\n\n#### Character class\n\nCharacter classes define a _set_ of characters. A set may include as simple characters, as well as _character ranges_. A class can be _positive_ (any from the characters in the class match), or _negative_ (any _but_ the characters from the class match).\n\n##### Positive character class\n\nA positive character class is defined between `[` and `]` brackets:\n\n```\n[a*]\n```\n\nA node:\n\n```js\n{\n  type: 'CharacterClass',\n  expressions: [\n    {\n      type: 'Char',\n      value: 'a',\n      symbol: 'a',\n      kind: 'simple',\n      codePoint: 97\n    },\n    {\n      type: 'Char',\n      value: '*',\n      symbol: '*',\n      kind: 'simple',\n      codePoint: 42\n    }\n  ]\n}\n```\n\n> NOTE: some meta symbols are treated as normal characters in a character class. E.g. `*` is not a repetition quantifier, but a simple char.\n\n##### Negative character class\n\nA negative character class is defined between `[^` and `]` brackets:\n\n```\n[^ab]\n```\n\nAn AST node is the same, just `negative` property is added:\n\n```js\n{\n  type: 'CharacterClass',\n  negative: true,\n  expressions: [\n    {\n      type: 'Char',\n      value: 'a',\n      symbol: 'a',\n      kind: 'simple',\n      codePoint: 97\n    },\n    {\n      type: 'Char',\n      value: 'b',\n      symbol: 'b',\n      kind: 'simple',\n      codePoint: 98\n    }\n  ]\n}\n```\n\n##### Character class ranges\n\nAs mentioned, a character class may also contain _ranges_ of symbols:\n\n```\n[a-z]\n```\n\nA node:\n\n```js\n{\n  type: 'CharacterClass',\n  expressions: [\n    {\n      type: 'ClassRange',\n      from: {\n        type: 'Char',\n        value: 'a',\n        symbol: 'a',\n        kind: 'simple',\n        codePoint: 97\n      },\n      to: {\n        type: 'Char',\n        value: 'z',\n        symbol: 'z',\n        kind: 'simple',\n        codePoint: 122\n      }\n    }\n  ]\n}\n```\n\n> NOTE: it is a _syntax error_ if `to` value is less than `from` value: `/[z-a]/`.\n\nThe range value can be the same for `from` and `to`, and the special range `-` character is treated as a simple character when it stands in a char position:\n\n```\n// from: 'a', to: 'a'\n[a-a]\n\n// from: '-', to: '-'\n[---]\n\n// simple '-' char:\n[-]\n\n// 3 ranges:\n[a-zA-Z0-9]+\n```\n\n#### Unicode properties\n\nUnicode property escapes are a new type of escape sequence available in regular expressions that have the `u` flag set. With this feature it is possible to write Unicode expressions as:\n\n```js\nconst greekSymbolRe = /\\p{Script=Greek}/u;\n\ngreekSymbolRe.test('Ï€'); // true\n```\n\nThe AST node for this expression is:\n\n```js\n{\n  type: 'UnicodeProperty',\n  name: 'Script',\n  value: 'Greek',\n  negative: false,\n  shorthand: false,\n  binary: false,\n  canonicalName: 'Script',\n  canonicalValue: 'Greek'\n}\n```\n\nAll possible property names, values, and their aliases can be found at the [specification](https://tc39.github.io/ecma262/#sec-runtime-semantics-unicodematchproperty-p).\n\nFor `General_Category` it is possible to use a shorthand:\n\n```js\n/\\p{Letter}/u;   // Shorthand\n\n/\\p{General_Category=Letter}/u; // Full notation\n```\n\nBinary names use the single value as well:\n\n```js\n/\\p{ASCII_Hex_Digit}/u; // Same as: /[0-9A-Fa-f]/\n```\n\nThe capitalized `P` defines the negation of the expression:\n\n```js\n/\\P{ASCII_Hex_Digit}/u; // NOT a ASCII Hex digit\n```\n\n#### Alternative\n\nAn _alternative_ (or _concatenation_) defines a chain of patterns followed one after another:\n\n```\nabc\n```\n\nA node:\n\n```js\n{\n  type: 'Alternative',\n  expressions: [\n    {\n      type: 'Char',\n      value: 'a',\n      symbol: 'a',\n      kind: 'simple',\n      codePoint: 97\n    },\n    {\n      type: 'Char',\n      value: 'b',\n      symbol: 'b',\n      kind: 'simple',\n      codePoint: 98\n    },\n    {\n      type: 'Char',\n      value: 'c',\n      symbol: 'c',\n      kind: 'simple',\n      codePoint: 99\n    }\n  ]\n}\n```\n\nAnother examples:\n\n```\n// 'a' with a quantifier, followed by 'b'\na?b\n\n// A group followed by a class:\n(ab)[a-z]\n```\n\n#### Disjunction\n\nThe _disjunction_ defines \"OR\" operation for regexp patterns. It's a _binary_ operation, having `left`, and `right` nodes.\n\nMatches `a` or `b`:\n\n```\na|b\n```\n\nA node:\n\n```js\n{\n  type: 'Disjunction',\n  left: {\n    type: 'Char',\n    value: 'a',\n    symbol: 'a',\n    kind: 'simple',\n    codePoint: 97\n  },\n  right: {\n    type: 'Char',\n    value: 'b',\n    symbol: 'b',\n    kind: 'simple',\n    codePoint: 98\n  }\n}\n```\n\n#### Groups\n\nThe groups play two roles: they define _grouping precedence_, and allow to _capture_ needed sub-expressions in case of a capturing group.\n\n##### Capturing group\n\n_\"Capturing\"_ means the matched string can be referred later by a user, including in the pattern itself -- by using [backreferences](#backreferences).\n\nChar `a`, and `b` are grouped, followed by the `c` char:\n\n```\n(ab)c\n```\n\nA node:\n\n```js\n{\n  type: 'Alternative',\n  expressions: [\n    {\n      type: 'Group',\n      capturing: true,\n      number: 1,\n      expression: {\n        type: 'Alternative',\n        expressions: [\n          {\n            type: 'Char',\n            value: 'a',\n            symbol: 'a',\n            kind: 'simple',\n            codePoint: 97\n          },\n          {\n            type: 'Char',\n            value: 'b',\n            symbol: 'b',\n            kind: 'simple',\n            codePoint: 98\n          }\n        ]\n      }\n    },\n    {\n      type: 'Char',\n      value: 'c',\n      symbol: 'c',\n      kind: 'simple',\n      codePoint: 99\n    }\n  ]\n}\n```\n\nAs we can see, it also tracks the number of the group.\n\nAnother example:\n\n```\n// A grouped disjunction of a symbol, and a character class:\n(5|[a-z])\n```\n\n##### Named capturing group\n\nA capturing group can be given a name using the `(?<name>...)` syntax, for any identifier `name`.\n\nFor example, a regular expressions for a date:\n\n```js\n/(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u\n```\n\nFor the group:\n\n```js\n(?<foo>x)\n```\n\nWe have the following node (the `name` property with value `foo` is added):\n\n```js\n{\n  type: 'Group',\n  capturing: true,\n  name: 'foo',\n  nameRaw: 'foo',\n  number: 1,\n  expression: {\n    type: 'Char',\n    value: 'x',\n    symbol: 'x',\n    kind: 'simple',\n    codePoint: 120\n  }\n}\n```\n\nNote: The `nameRaw` property represents the name *as parsed from the original source*, including escape sequences. The `name` property represents the canonical decoded form of the name.\n\nFor example, given the `/u` flag and the following group:\n\n```regexp\n(?<\\u{03C0}>x)\n```\n\nWe would have the following node:\n\n```js\n{\n  type: 'Group',\n  capturing: true,\n  name: 'Ï€',\n  nameRaw: '\\\\u{03C0}',\n  number: 1,\n  expression: {\n    type: 'Char',\n    value: 'x',\n    symbol: 'x',\n    kind: 'simple',\n    codePoint: 120\n  }\n}\n```\n\n##### Non-capturing group\n\nSometimes we don't need to actually capture the matched string from a group. In this case we can use a _non-capturing_ group:\n\nChar `a`, and `b` are grouped, _but not captured_, followed by the `c` char:\n\n```\n(?:ab)c\n```\n\nThe same node, the `capturing` flag is `false`:\n\n```js\n{\n  type: 'Alternative',\n  expressions: [\n    {\n      type: 'Group',\n      capturing: false,\n      expression: {\n        type: 'Alternative',\n        expressions: [\n          {\n            type: 'Char',\n            value: 'a',\n            symbol: 'a',\n            kind: 'simple',\n            codePoint: 97\n          },\n          {\n            type: 'Char',\n            value: 'b',\n            symbol: 'b',\n            kind: 'simple',\n            codePoint: 98\n          }\n        ]\n      }\n    },\n    {\n      type: 'Char',\n      value: 'c',\n      symbol: 'c',\n      kind: 'simple',\n      codePoint: 99\n    }\n  ]\n}\n```\n\n##### Backreferences\n\nA [capturing group](#capturing-group) can be referenced in the pattern using notation of an escaped group number.\n\nMatches `abab` string:\n\n```\n(ab)\\1\n```\n\nA node:\n\n```js\n{\n  type: 'Alternative',\n  expressions: [\n    {\n      type: 'Group',\n      capturing: true,\n      number: 1,\n      expression: {\n        type: 'Alternative',\n        expressions: [\n          {\n            type: 'Char',\n            value: 'a',\n            symbol: 'a',\n            kind: 'simple',\n            codePoint: 97\n          },\n          {\n            type: 'Char',\n            value: 'b',\n            symbol: 'b',\n            kind: 'simple',\n            codePoint: 98\n          }\n        ]\n      }\n    },\n    {\n      type: 'Backreference',\n      kind: 'number',\n      number: 1,\n      reference: 1,\n    }\n  ]\n}\n```\n\nA [named capturing group](#named-capturing-group) can be accessed using `\\k<name>` pattern, and also using a numbered reference.\n\nMatches `www`:\n\n```js\n(?<foo>w)\\k<foo>\\1\n```\n\nA node:\n\n```js\n{\n  type: 'Alternative',\n  expressions: [\n    {\n      type: 'Group',\n      capturing: true,\n      name: 'foo',\n      nameRaw: 'foo',\n      number: 1,\n      expression: {\n        type: 'Char',\n        value: 'w',\n        symbol: 'w',\n        kind: 'simple',\n        codePoint: 119\n      }\n    },\n    {\n      type: 'Backreference',\n      kind: 'name',\n      number: 1,\n      reference: 'foo',\n      referenceRaw: 'foo'\n    },\n    {\n      type: 'Backreference',\n      kind: 'number',\n      number: 1,\n      reference: 1\n    }\n  ]\n}\n```\n\nNote: The `referenceRaw` property represents the reference *as parsed from the original source*, including escape sequences. The `reference` property represents the canonical decoded form of the reference.\n\nFor example, given the `/u` flag and the following pattern (matches `www`):\n\n```regexp\n(?<Ï€>w)\\k<\\u{03C0}>\\1\n```\n\nWe would have the following node:\n\n```js\n{\n  type: 'Alternative',\n  expressions: [\n    {\n      type: 'Group',\n      capturing: true,\n      name: 'Ï€',\n      nameRaw: 'Ï€',\n      number: 1,\n      expression: {\n        type: 'Char',\n        value: 'w',\n        symbol: 'w',\n        kind: 'simple',\n        codePoint: 119\n      }\n    },\n    {\n      type: 'Backreference',\n      kind: 'name',\n      number: 1,\n      reference: 'Ï€',\n      referenceRaw: '\\\\u{03C0}'\n    },\n    {\n      type: 'Backreference',\n      kind: 'number',\n      number: 1,\n      reference: 1\n    }\n  ]\n}\n```\n\n\n#### Quantifiers\n\nQuantifiers specify _repetition_ of a regular expression (or of its part). Below are the quantifiers which _wrap_ a parsed expression into a `Repetition` node. The quantifier itself can be of different _kinds_, and has `Quantifier` node type.\n\n##### ? zero-or-one\n\nThe `?` quantifier is short for `{0,1}`.\n\n```\na?\n```\n\nNode:\n\n```js\n{\n  type: 'Repetition',\n  expression: {\n    type: 'Char',\n    value: 'a',\n    symbol: 'a',\n    kind: 'simple',\n    codePoint: 97\n  },\n  quantifier: {\n    type: 'Quantifier',\n    kind: '?',\n    greedy: true\n  }\n}\n```\n\n##### * zero-or-more\n\nThe `*` quantifier is short for `{0,}`.\n\n```\na*\n```\n\nNode:\n\n```js\n{\n  type: 'Repetition',\n  expression: {\n    type: 'Char',\n    value: 'a',\n    symbol: 'a',\n    kind: 'simple',\n    codePoint: 97\n  },\n  quantifier: {\n    type: 'Quantifier',\n    kind: '*',\n    greedy: true\n  }\n}\n```\n\n##### + one-or-more\n\nThe `+` quantifier is short for `{1,}`.\n\n```\n// Same as `aa*`, or `a{1,}`\na+\n```\n\nNode:\n\n```js\n{\n  type: 'Repetition',\n  expression: {\n    type: 'Char',\n    value: 'a',\n    symbol: 'a',\n    kind: 'simple',\n    codePoint: 97\n  },\n  quantifier: {\n    type: 'Quantifier',\n    kind: '+',\n    greedy: true\n  }\n}\n```\n\n##### Range-based quantifiers\n\nExplicit _range-based_ quantifiers are parsed as follows:\n\n###### Exact number of matches\n\n```\na{3}\n```\n\nThe type of the quantifier is `Range`, and `from`, and `to` properties have the same value:\n\n```js\n{\n  type: 'Repetition',\n  expression: {\n    type: 'Char',\n    value: 'a',\n    symbol: 'a',\n    kind: 'simple',\n    codePoint: 97\n  },\n  quantifier: {\n    type: 'Quantifier',\n    kind: 'Range',\n    from: 3,\n    to: 3,\n    greedy: true\n  }\n}\n```\n\n###### Open range\n\nAn open range doesn't have max value (assuming semantic \"more\", or Infinity value):\n\n```\na{3,}\n```\n\nAn AST node for such range doesn't contain `to` property:\n\n```js\n{\n  type: 'Repetition',\n  expression: {\n    type: 'Char',\n    value: 'a',\n    symbol: 'a',\n    kind: 'simple',\n    codePoint: 97\n  },\n  quantifier: {\n    type: 'Quantifier',\n    kind: 'Range',\n    from: 3,\n    greedy: true\n  }\n}\n```\n\n###### Closed range\n\nA closed range has explicit max value: (which syntactically can be the same as min value):\n\n```\na{3,5}\n\n// Same as a{3}\na{3,3}\n```\n\nAn AST node for a closed range:\n\n```js\n{\n  type: 'Repetition',\n  expression: {\n    type: 'Char',\n    value: 'a',\n    symbol: 'a',\n    kind: 'simple',\n    codePoint: 97\n  },\n  quantifier: {\n    type: 'Quantifier',\n    kind: 'Range',\n    from: 3,\n    to: 5,\n    greedy: true\n  }\n}\n```\n\n> NOTE: it is a _syntax error_ if the max value is less than min value: `/a{3,2}/`\n\n##### Non-greedy\n\nIf any quantifier is followed by the `?`, the quantifier becomes _non-greedy_.\n\nExample:\n\n```\na+?\n```\n\nNode:\n\n```js\n{\n  type: 'Repetition',\n  expression: {\n    type: 'Char',\n    value: 'a',\n    symbol: 'a',\n    kind: 'simple',\n    codePoint: 97\n  },\n  quantifier: {\n    type: 'Quantifier',\n    kind: '+',\n    greedy: false\n  }\n}\n```\n\nOther examples:\n\n```\na??\na*?\na{1}?\na{1,}?\na{1,3}?\n```\n\n#### Assertions\n\nAssertions appear as separate AST nodes, however instread of manipulating on the characters themselves, they _assert_ certain conditions of a matching string. Examples: `^` -- beginning of a string (or a line in multiline mode), `$` -- end of a string, etc.\n\n##### ^ begin marker\n\nThe `^` assertion checks whether a scanner is at the beginning of a string (or a line in multiline mode).\n\nIn the example below `^` is not a property of the `a` symbol, but a separate AST node for the assertion. The parsed node is actually an `Alternative` with two nodes:\n\n```\n^a\n```\n\nThe node:\n\n```js\n{\n  type: 'Alternative',\n  expressions: [\n    {\n      type: 'Assertion',\n      kind: '^'\n    },\n    {\n      type: 'Char',\n      value: 'a',\n      symbol: 'a',\n      kind: 'simple',\n      codePoint: 97\n    }\n  ]\n}\n```\n\nSince assertion is a separate node, it may appear anywhere in the matching string. The following regexp is completely valid, and asserts beginning of the string; it'll match an empty string:\n\n```\n^^^^^\n```\n\n##### $ end marker\n\nThe `$` assertion is similar to `^`, but asserts the end of a string (or a line in a multiline mode):\n\n```\na$\n```\n\nA node:\n\n```js\n{\n  type: 'Alternative',\n  expressions: [\n    {\n      type: 'Char',\n      value: 'a',\n      symbol: 'a',\n      kind: 'simple',\n      codePoint: 97\n    },\n    {\n      type: 'Assertion',\n      kind: '$'\n    }\n  ]\n}\n```\n\nAnd again, this is a completely valid regexp, and matches an empty string:\n\n```\n^^^^$$$$$\n\n// valid too:\n$^\n```\n\n##### Boundary assertions\n\nThe `\\b` assertion check for _word boundary_, i.e. the position between a word and a space.\n\nMatches `x` in `x y`, but not in `xy`:\n\n```\nx\\b\n```\n\nA node:\n\n```js\n{\n  type: 'Alternative',\n  expressions: [\n    {\n      type: 'Char',\n      value: 'x',\n      symbol: 'x',\n      kind: 'simple',\n      codePoint: 120\n    },\n    {\n      type: 'Assertion',\n      kind: '\\\\b'\n    }\n  ]\n}\n```\n\nThe `\\B` is vice-versa checks for _non-word_ boundary. The following example matches `x` in `xy`, but not in `x y`:\n\n```\nx\\B\n```\n\nA node is the same:\n\n```js\n{\n  type: 'Alternative',\n  expressions: [\n    {\n      type: 'Char',\n      value: 'x',\n      symbol: 'x',\n      kind: 'simple',\n      codePoint: 120\n    },\n    {\n      type: 'Assertion',\n      kind: '\\\\B'\n    }\n  ]\n}\n```\n\n##### Lookahead assertions\n\nThese assertions check whether a pattern is _followed_ (or not followed for the negative assertion) by another pattern.\n\n###### Positive lookahead assertion\n\nMatches `a` only if it's followed by `b`:\n\n```\na(?=b)\n```\n\nA node:\n\n```js\n{\n  type: 'Alternative',\n  expressions: [\n    {\n      type: 'Char',\n      value: 'a',\n      symbol: 'a',\n      kind: 'simple',\n      codePoint: 97\n    },\n    {\n      type: 'Assertion',\n      kind: 'Lookahead',\n      assertion: {\n        type: 'Char',\n        value: 'b',\n        symbol: 'b',\n        kind: 'simple',\n        codePoint: 98\n      }\n    }\n  ]\n}\n```\n\n###### Negative lookahead assertion\n\nMatches `a` only if it's _not_ followed by `b`:\n\n```\na(?!b)\n```\n\nA node is similar, just `negative` flag is added:\n\n```js\n{\n  type: 'Alternative',\n  expressions: [\n    {\n      type: 'Char',\n      value: 'a',\n      symbol: 'a',\n      kind: 'simple',\n      codePoint: 97\n    },\n    {\n      type: 'Assertion',\n      kind: 'Lookahead',\n      negative: true,\n      assertion: {\n        type: 'Char',\n        value: 'b',\n        symbol: 'b',\n        kind: 'simple',\n        codePoint: 98\n      }\n    }\n  ]\n}\n```\n\n##### Lookbehind assertions\n\n> NOTE: _Lookbehind assertions_ are not yet supported by JavaScript RegExp. It is an ECMAScript [proposal](https://tc39.github.io/proposal-regexp-lookbehind/) which is at stage 3 at the moment.\n\nThese assertions check whether a pattern is _preceded_ (or not preceded for the negative assertion) by another pattern.\n\n###### Positive lookbehind assertion\n\nMatches `b` only if it's preceded by `a`:\n\n```\n(?<=a)b\n```\n\nA node:\n\n```js\n{\n  type: 'Alternative',\n  expressions: [\n    {\n      type: 'Assertion',\n      kind: 'Lookbehind',\n      assertion: {\n        type: 'Char',\n        value: 'a',\n        symbol: 'a',\n        kind: 'simple',\n        codePoint: 97\n      }\n    },\n    {\n      type: 'Char',\n      value: 'b',\n      symbol: 'b',\n      kind: 'simple',\n      codePoint: 98\n    },\n  ]\n}\n```\n\n###### Negative lookbehind assertion\n\nMatches `b` only if it's _not_ preceded by `a`:\n\n```\n(?<!a)b\n```\n\nA node:\n\n```js\n{\n  type: 'Alternative',\n  expressions: [\n    {\n      type: 'Assertion',\n      kind: 'Lookbehind',\n      negative: true,\n      assertion: {\n        type: 'Char',\n        value: 'a',\n        symbol: 'a',\n        kind: 'simple',\n        codePoint: 97\n      }\n    },\n    {\n      type: 'Char',\n      value: 'b',\n      symbol: 'b',\n      kind: 'simple',\n      codePoint: 98\n    },\n  ]\n}\n```\n",
    "licenseText": "MIT License\n\nCopyright (c) 2017 Dmitry Soshnikov\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/regexp-tree/-/regexp-tree-0.1.24.tgz#3d6fa238450a4d66e5bc9c4c14bb720e2196829d",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/regexp-tree/-/regexp-tree-0.1.24.tgz",
    "hash": "3d6fa238450a4d66e5bc9c4c14bb720e2196829d",
    "integrity": "sha512-s2aEVuLhvnVJW6s/iPgEGK6R+/xngd2jNQ+xy4bXNDKxZKJH6jpPHY6kVeVv1IeLCHgswRj+Kl3ELaDjG6V1iw==",
    "registry": "npm",
    "packageName": "regexp-tree",
    "cacheIntegrity": "sha512-s2aEVuLhvnVJW6s/iPgEGK6R+/xngd2jNQ+xy4bXNDKxZKJH6jpPHY6kVeVv1IeLCHgswRj+Kl3ELaDjG6V1iw== sha1-PW+iOEUKTWblvJxMFLtyDiGWgp0="
  },
  "registry": "npm",
  "hash": "3d6fa238450a4d66e5bc9c4c14bb720e2196829d"
}