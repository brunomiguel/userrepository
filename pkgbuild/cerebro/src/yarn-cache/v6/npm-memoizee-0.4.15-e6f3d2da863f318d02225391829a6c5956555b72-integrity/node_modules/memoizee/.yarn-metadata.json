{
  "manifest": {
    "name": "memoizee",
    "version": "0.4.15",
    "description": "Memoize/cache function results",
    "author": {
      "name": "Mariusz Nowak",
      "email": "medikoo@medikoo.com",
      "url": "http://www.medikoo.com/"
    },
    "keywords": [
      "memoize",
      "memoizer",
      "cache",
      "memoization",
      "memo",
      "memcached",
      "hashing.",
      "storage",
      "caching",
      "memory",
      "gc",
      "weak",
      "garbage",
      "collector",
      "async"
    ],
    "repository": {
      "type": "git",
      "url": "git://github.com/medikoo/memoizee.git"
    },
    "dependencies": {
      "d": "^1.0.1",
      "es5-ext": "^0.10.53",
      "es6-weak-map": "^2.0.3",
      "event-emitter": "^0.3.5",
      "is-promise": "^2.2.2",
      "lru-queue": "^0.1.0",
      "next-tick": "^1.1.0",
      "timers-ext": "^0.1.7"
    },
    "devDependencies": {
      "bluebird": "^3.7.2",
      "eslint": "^5.16.0",
      "eslint-config-medikoo-es5": "^1.7.3",
      "plain-promise": "^0.1.1",
      "tad": "^2.0.1"
    },
    "eslintConfig": {
      "extends": "medikoo-es5",
      "root": true,
      "globals": {
        "setTimeout": true,
        "clearTimeout": true
      },
      "rules": {
        "max-lines-per-function": "off"
      }
    },
    "scripts": {
      "lint": "eslint --ignore-path=.gitignore .",
      "test": "tad"
    },
    "license": "ISC",
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-memoizee-0.4.15-e6f3d2da863f318d02225391829a6c5956555b72-integrity/node_modules/memoizee/package.json",
    "readmeFilename": "README.md",
    "readme": "[![*nix build status][nix-build-image]][nix-build-url]\n[![Windows build status][win-build-image]][win-build-url]\n![Transpilation status][transpilation-image]\n[![npm version][npm-image]][npm-url]\n\n# Memoizee\n\n## Complete memoize/cache solution for JavaScript\n\n_Originally derived from [es5-ext](https://github.com/medikoo/es5-ext) package._\n\nMemoization is best technique to save on memory or CPU cycles when we deal with repeated operations. For detailed insight see: http://en.wikipedia.org/wiki/Memoization\n\n### Features\n\n*   Works with any type of function arguments – **no serialization is needed**\n*   Works with [**any length of function arguments**](#arguments-length). Length can be set as fixed or dynamic.\n*   One of the [**fastest**](#benchmarks) available solutions.\n*   Support for [**promises**](#promise-returning-functions) and [**asynchronous functions**](#nodejs-callback-style-functions)\n*   [**Primitive mode**](#primitive-mode) which assures fast performance when arguments are convertible to strings.\n*   [**WeakMap based mode**](#weakmap-based-configurations) for garbage collection friendly configuration\n*   Can be configured [**for methods**](#memoizing-methods) (when `this` counts in)\n*   Cache [**can be cleared manually**](#manual-clean-up) or [**after specified timeout**](#expire-cache-after-given-period-of-time)\n*   Cache size can be **[limited on LRU basis](#limiting-cache-size)**\n*   Optionally [**accepts resolvers**](#argument-resolvers) that normalize function arguments before passing them to underlying function.\n*   Optional [**reference counter mode**](#reference-counter), that allows more sophisticated cache management\n*   [**Profile tool**](#profiling--statistics) that provides valuable usage statistics\n*   Covered by [**over 500 unit tests**](#tests)\n\n### Installation\n\nIn your project path — **note the two `e`'s in `memoizee`:**\n\n    $ npm install memoizee\n\n_`memoize` name was already taken, therefore project is published as `memoizee` on NPM._\n\nTo port it to Browser or any other (non CJS) environment, use your favorite CJS bundler. No favorite yet? Try: [Browserify](http://browserify.org/), [Webmake](https://github.com/medikoo/modules-webmake) or [Webpack](http://webpack.github.io/)\n\n### Usage\n\n```javascript\nvar memoize = require(\"memoizee\");\n\nvar fn = function(one, two, three) {\n\t/* ... */\n};\n\nmemoized = memoize(fn);\n\nmemoized(\"foo\", 3, \"bar\");\nmemoized(\"foo\", 3, \"bar\"); // Cache hit\n```\n\n__Note__: Invocations that throw exceptions are not cached.\n\n### Configuration\n\nAll below options can be applied in any combination\n\n#### Arguments length\n\nBy default fixed number of arguments that function take is assumed (it's read from function's `length` property) this can be overridden:\n\n```javascript\nmemoized = memoize(fn, { length: 2 });\n\nmemoized(\"foo\"); // Assumed: 'foo', undefined\nmemoized(\"foo\", undefined); // Cache hit\n\nmemoized(\"foo\", 3, {}); // Third argument is ignored (but passed to underlying function)\nmemoized(\"foo\", 3, 13); // Cache hit\n```\n\n__Note:__ [Parameters predefined with default values (ES2015+ feature)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters) are not reflected in function's `length`, therefore if you want to memoize them as well, you need to tweak `length` setting accordingly\n\nDynamic _length_ behavior can be forced by setting _length_ to `false`, that means memoize will work with any number of arguments.\n\n```javascript\nmemoized = memoize(fn, { length: false });\n\nmemoized(\"foo\");\nmemoized(\"foo\"); // Cache hit\nmemoized(\"foo\", undefined);\nmemoized(\"foo\", undefined); // Cache hit\n\nmemoized(\"foo\", 3, {});\nmemoized(\"foo\", 3, 13);\nmemoized(\"foo\", 3, 13); // Cache hit\n```\n\n#### Primitive mode\n\nIf we work with large result sets, or memoize hot functions, default mode may not perform as fast as we expect. In that case it's good to run memoization in _primitive_ mode. To provide fast access, results are saved in hash instead of an array. Generated hash ids are result of arguments to string conversion. **Mind that this mode will work correctly only if stringified arguments produce unique strings.**\n\n```javascript\nmemoized = memoize(fn, { primitive: true });\n\nmemoized(\"/path/one\");\nmemoized(\"/path/one\"); // Cache hit\n```\n\n#### Cache id resolution (normalization)\n\nBy default cache id for given call is resolved either by:\n\n*   Direct Comparison of values passed in arguments as they are. In such case two different objects, even if their characteristics is exactly same (e.g. `var a = { foo: 'bar' }, b = { foo: 'bar' }`) will be treated as two different values.\n*   Comparison of stringified values of given arguments (`primitive` mode), which serves well, when arguments are expected to be primitive values, or objects that stringify naturally do unique values (e.g. arrays)\n\nStill above two methods do not serve all cases, e.g. if we want to memoize function where arguments are hash objects which we do not want to compare by instance but by its content.\n\n##### Writing custom cache id normalizers\n\nThere's a `normalizer` option through which we can pass custom cache id normalization function  \ne.g. if we want to memoize a function where argument is a hash object which we do not want to compare by instance but by its content, then we can achieve it as following:\n\n```javascript\nvar mfn = memoize(\n\tfunction(hash) {\n\t\t// body of memoized function\n\t},\n\t{\n\t\tnormalizer: function(args) {\n\t\t\t// args is arguments object as accessible in memoized function\n\t\t\treturn JSON.stringify(args[0]);\n\t\t}\n\t}\n);\n\nmfn({ foo: \"bar\" });\nmfn({ foo: \"bar\" }); // Cache hit\n```\n\n#### Argument resolvers\n\nWhen we're expecting arguments of certain type it's good to coerce them before doing memoization. We can do that by passing additional resolvers array:\n\n```javascript\nmemoized = memoize(fn, { length: 2, resolvers: [String, Boolean] });\n\nmemoized(12, [1, 2, 3].length);\nmemoized(\"12\", true); // Cache hit\nmemoized(\n\t{\n\t\ttoString: function() {\n\t\t\treturn \"12\";\n\t\t}\n\t},\n\t{}\n); // Cache hit\n```\n\n**Note. If your arguments are collections (arrays or hashes) that you want to memoize by content (not by self objects), you need to cast them to strings**, for it's best to just use [primitive mode](#primitive-mode). Arrays have standard string representation and work with primitive mode out of a box, for hashes you need to define `toString` method, that will produce unique string descriptions, or rely on `JSON.stringify`.\n\nSimilarly **if you want to memoize functions by their code representation not by their objects, you should use primitive mode**.\n\n#### Memoizing asynchronous functions\n\n##### Promise returning functions\n\nWith _promise_ option we indicate that we memoize a function that returns promise.\n\nThe difference from natural behavior is that in case when promise was rejected with exception,\nthe result is immediately removed from memoize cache, and not kept as further reusable result.\n\n```javascript\nvar afn = function(a, b) {\n\treturn new Promise(function(res) {\n\t\tres(a + b);\n\t});\n};\nmemoized = memoize(afn, { promise: true });\n\nmemoized(3, 7);\nmemoized(3, 7); // Cache hit\n```\n\n###### Important notice on internal promises handling\n\nDefault handling stands purely on _then_ which has side-effect of muting eventual unhandled rejection notifications.\nAlternatively we can other (explained below), by stating with `promise` option desired mode:\n\n```javascript\nmemoized = memoize(afn, { promise: \"done:finally\" });\n```\n\nSupported modes\n\n*   `then` _(default)_. Values are resolved purely by passing callbacks to `promise.then`. **Side effect is that eventual unhandled rejection on given promise\n    come with no logged warning!**, and that to avoid implied error swallowing both states are resolved tick after callbacks were invoked\n\n*   `done` Values are resolved purely by passing callback to `done` method. **Side effect is that eventual unhandled rejection on given promise come with no logged warning!**.\n\n*   `done:finally` The only method that may work with no side-effects assuming that promise implementaion does not throw unconditionally\n    if no _onFailure_ callback was passed to `done`, and promise error was handled by other consumer (this is not commonly implemented _done_ behavior). Otherwise side-effect is that exception is thrown on promise rejection (highly not recommended)\n\n##### Node.js callback style functions\n\nWith _async_ option we indicate that we memoize asynchronous (Node.js style) function\nOperations that result with an error are not cached.\n\n```javascript\nafn = function(a, b, cb) {\n\tsetTimeout(function() {\n\t\tcb(null, a + b);\n\t}, 200);\n};\nmemoized = memoize(afn, { async: true });\n\nmemoized(3, 7, function(err, res) {\n\tmemoized(3, 7, function(err, res) {\n\t\t// Cache hit\n\t});\n});\n\nmemoized(3, 7, function(err, res) {\n\t// Cache hit\n});\n```\n\n#### Memoizing methods\n\nWhen we are defining a prototype, we may want to define a method that will memoize it's results in relation to each instance. A basic way to obtain that would be:\n\n```javascript\nvar Foo = function() {\n\tthis.bar = memoize(this.bar.bind(this), { someOption: true });\n\t// ... constructor logic\n};\nFoo.prototype.bar = function() {\n\t// ... method logic\n};\n```\n\nThere's a lazy methods descriptor generator provided:\n\n```javascript\nvar d = require(\"d\");\nvar memoizeMethods = require(\"memoizee/methods\");\n\nvar Foo = function() {\n\t// ... constructor logic\n};\nObject.defineProperties(\n\tFoo.prototype,\n\tmemoizeMethods({\n\t\tbar: d(\n\t\t\tfunction() {\n\t\t\t\t// ... method logic\n\t\t\t},\n\t\t\t{ someOption: true }\n\t\t)\n\t})\n);\n```\n\n#### WeakMap based configurations\n\nIn this case memoization cache is not bound to memoized function (which we may want to keep forever), but to objects for which given results were generated.\n\nThis mode works only for functions of which first argument is expected to be an object.  \nIt can be combined with other options mentioned across documentation. However due to WeakMap specificity global clear is not possible.\n\n```javascript\nvar memoize = require(\"memoizee/weak\");\n\nvar memoized = memoize(function(obj) {\n\treturn Object.keys(obj);\n});\n\nvar obj = { foo: true, bar: false };\nmemoized(obj);\nmemoized(obj); // Cache hit\n```\n\n#### Cache handling\n\n##### Manual clean up:\n\nDelete data for particular call.\n\n```javascript\nmemoized.delete(\"foo\", true);\n```\n\nArguments passed to `delete` are treated with same rules as input arguments passed to function\n\nClear all cached data:\n\n```javascript\nmemoized.clear();\n```\n\n##### Expire cache after given period of time\n\nWith _maxAge_ option we can ensure that cache for given call is cleared after predefined period of time (in milliseconds)\n\n```javascript\nmemoized = memoize(fn, { maxAge: 1000 }); // 1 second\n\nmemoized(\"foo\", 3);\nmemoized(\"foo\", 3); // Cache hit\nsetTimeout(function() {\n\tmemoized(\"foo\", 3); // No longer in cache, re-executed\n\tmemoized(\"foo\", 3); // Cache hit\n}, 2000);\n```\n\nAdditionally we may ask to _pre-fetch_ in a background a value that is about to expire. _Pre-fetch_ is invoked only if value is accessed close to its expiry date. By default it needs to be within at least 33% of _maxAge_ timespan before expire:\n\n```javascript\nmemoized = memoize(fn, { maxAge: 1000, preFetch: true }); // Defaults to 0.33\n\nmemoized(\"foo\", 3);\nmemoized(\"foo\", 3); // Cache hit\n\nsetTimeout(function() {\n\tmemoized(\"foo\", 3); // Cache hit\n}, 500);\n\nsetTimeout(function() {\n\tmemoized(\"foo\", 3); // Cache hit, silently pre-fetched in next tick\n}, 800);\n\nsetTimeout(function() {\n\tmemoized(\"foo\", 3); // Cache hit\n}, 1300);\n```\n\n_Pre-fetch_ timespan can be customized:\n\n```javascript\nmemoized = memoize(fn, { maxAge: 1000, preFetch: 0.6 });\n\nmemoized(\"foo\", 3);\nmemoized(\"foo\", 3); // Cache hit\n\nsetTimeout(function() {\n\tmemoized(\"foo\", 3); // Cache hit, silently pre-fetched in next tick\n}, 500);\n\nsetTimeout(function() {\n\tmemoized(\"foo\", 3); // Cache hit\n}, 1300);\n```\n\n_Thanks [@puzrin](https://github.com/puzrin) for helpful suggestions concerning this functionality_\n\n##### Reference counter\n\nWe can track number of references returned from cache, and manually delete them. When the last reference is cleared, the cache is purged automatically:\n\n```javascript\nmemoized = memoize(fn, { refCounter: true });\n\nmemoized(\"foo\", 3); // refs: 1\nmemoized(\"foo\", 3); // Cache hit, refs: 2\nmemoized(\"foo\", 3); // Cache hit, refs: 3\nmemoized.deleteRef(\"foo\", 3); // refs: 2\nmemoized.deleteRef(\"foo\", 3); // refs: 1\nmemoized.deleteRef(\"foo\", 3); // refs: 0, Cache purged for 'foo', 3\nmemoized(\"foo\", 3); // Re-executed, refs: 1\n```\n\n##### Limiting cache size\n\nWith _max_ option you can limit cache size, it's backed with [LRU algorithm](http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used), provided by low-level [lru-queue](https://github.com/medikoo/lru-queue) utility.\n\nThe _size_ relates purely to count of results we want to keep in cache, it doesn't relate to memory cost associated with cache value (but such feature is likely to be introduced with next version of memoizee).\n\n```javascript\nmemoized = memoize(fn, { max: 2 });\n\nmemoized(\"foo\", 3);\nmemoized(\"bar\", 7);\nmemoized(\"foo\", 3); // Cache hit\nmemoized(\"bar\", 7); // Cache hit\nmemoized(\"lorem\", 11); // Cache cleared for 'foo', 3\nmemoized(\"bar\", 7); // Cache hit\nmemoized(\"foo\", 3); // Re-executed, Cache cleared for 'lorem', 11\nmemoized(\"lorem\", 11); // Re-executed, Cache cleared for 'bar', 7\nmemoized(\"foo\", 3); // Cache hit\nmemoized(\"bar\", 7); // Re-executed, Cache cleared for 'lorem', 11\n```\n\n##### Registering dispose callback\n\nYou can register a callback to be called on each value removed from the cache:\n\n```javascript\nmemoized = memoize(fn, {\n\tdispose: function(value) {\n\t\t/*…*/\n\t}\n});\n\nvar foo3 = memoized(\"foo\", 3);\nvar bar7 = memoized(\"bar\", 7);\nmemoized.clear(\"foo\", 3); // Dispose called with foo3 value\nmemoized.clear(\"bar\", 7); // Dispose called with bar7 value\n```\n\n### Benchmarks\n\nSimple benchmark tests can be found in _benchmark_ folder. Currently it's just plain simple calculation of fibonacci sequences. To run it you need to install other test candidates:\n\n    $ npm install underscore lodash lru-cache secondary-cache\n\nExample output taken under Node v0.10.35 on 2011 MBP Pro:\n\n```\nFibonacci 3000 x10:\n\n1:    15ms  Memoizee (primitive mode)\n2:    15ms  Underscore\n3:    18ms  lru-cache                 LRU (max: 1000)\n4:    21ms  secondary-cache           LRU (max: 1000)\n5:    37ms  Lo-dash\n6:    62ms  Memoizee (primitive mode) LRU (max: 1000)\n7:   163ms  Memoizee (object mode)    LRU (max: 1000)\n8:   195ms  Memoizee (object mode)\n```\n\n### Profiling & Statistics\n\nIf you want to make sure how much you benefit from memoization or just check if memoization works as expected, loading profile module will give access to all valuable information.\n\n**Module needs to be imported before any memoization (that we want to track) is configured. Mind also that running profile module affects performance, it's best not to use it in production environment**\n\n```javascript\nvar memProfile = require('memoizee/profile');\n...\n...\nmemoize(fn);\n...\nmemoize(fn, { profileName: 'Some Function' })\n...\nmemoize(fn, { profileName: 'Another Function' })\n```\n\nAccess statistics at any time:\n\n```javascript\nmemProfile.statistics; // Statistics accessible for programmatic use\nconsole.log(memProfile.log()); // Output statistics data in readable form\n```\n\nExample console output:\n\n```\n------------------------------------------------------------\nMemoize statistics:\n\n Init  Cache  %Cache  Source location\n11604  35682   75.46  (all)\n 2112  19901   90.41  Some Function, at /Users/medikoo/Projects/_packages/next/lib/fs/is-ignored.js:276:12\n 2108   9087   81.17  Another Function, at /Users/medikoo/Projects/_packages/next/lib/fs/is-ignored.js:293:10\n 6687   2772   29.31  at /Users/medikoo/Projects/_packages/next/lib/fs/watch.js:125:9\n  697   3922   84.91  at /Users/medikoo/Projects/_packages/next/lib/fs/is-ignored.js:277:15\n------------------------------------------------------------\n```\n\n*   _Init_ – Initial hits\n*   _Cache_ – Cache hits\n*   _%Cache_ – What's the percentage of cache hits (of all function calls)\n*   _Source location_ – Where in the source code given memoization was initialized\n\n### Tests\n\n    $ npm test\n\nProject cross-browser compatibility to be supported by:\n\n<a href=\"https://browserstack.com\"><img src=\"https://bstacksupport.zendesk.com/attachments/token/Pj5uf2x5GU9BvWErqAr51Jh2R/?name=browserstack-logo-600x315.png\" height=\"150\" /></a>\n\n## Security contact information\n\nTo report a security vulnerability, please use the [Tidelift security contact](https://tidelift.com/security). Tidelift will coordinate the fix and disclosure.\n\n---\n\n<div align=\"center\">\n\t<b>\n\t\t<a href=\"https://tidelift.com/subscription/pkg/npm-memoizee?utm_source=npm-memoizee&utm_medium=referral&utm_campaign=readme\">Get professional support for d with a Tidelift subscription</a>\n\t</b>\n\t<br>\n\t<sub>\n\t\tTidelift helps make open source sustainable for maintainers while giving companies<br>assurances about security, maintenance, and licensing for their dependencies.\n\t</sub>\n</div>\n\n### Contributors\n\n*   [@puzrin](https://github.com/puzrin) (Vitaly Puzrin)\n    *   Proposal and help with coining right _pre-fetch_ logic for [_maxAge_](https://github.com/medikoo/memoize#expire-cache-after-given-period-of-time) variant\n\n[nix-build-image]: https://semaphoreci.com/api/v1/medikoo-org/memoizee/branches/master/shields_badge.svg\n[nix-build-url]: https://semaphoreci.com/medikoo-org/memoizee\n[win-build-image]: https://ci.appveyor.com/api/projects/status/hsxubnbwe89c26bu?svg=true\n[win-build-url]: https://ci.appveyor.com/project/medikoo/memoizee\n[transpilation-image]: https://img.shields.io/badge/transpilation-free-brightgreen.svg\n[npm-image]: https://img.shields.io/npm/v/memoizee.svg\n[npm-url]: https://www.npmjs.com/package/memoizee\n",
    "licenseText": "ISC License\n\nCopyright (c) 2012-2018, Mariusz Nowak, @medikoo, medikoo.com\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\nOR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/memoizee/-/memoizee-0.4.15.tgz#e6f3d2da863f318d02225391829a6c5956555b72",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/memoizee/-/memoizee-0.4.15.tgz",
    "hash": "e6f3d2da863f318d02225391829a6c5956555b72",
    "integrity": "sha512-UBWmJpLZd5STPm7PMUlOw/TSy972M+z8gcyQ5veOnSDRREz/0bmpyTfKt3/51DhEBqCZQn1udM/5flcSPYhkdQ==",
    "registry": "npm",
    "packageName": "memoizee",
    "cacheIntegrity": "sha512-UBWmJpLZd5STPm7PMUlOw/TSy972M+z8gcyQ5veOnSDRREz/0bmpyTfKt3/51DhEBqCZQn1udM/5flcSPYhkdQ== sha1-5vPS2oY/MY0CIlORgppsWVZVW3I="
  },
  "registry": "npm",
  "hash": "e6f3d2da863f318d02225391829a6c5956555b72"
}