{
  "manifest": {
    "name": "conf",
    "version": "10.2.0",
    "description": "Simple config handling for your app or module",
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/sindresorhus/conf.git"
    },
    "funding": "https://github.com/sponsors/sindresorhus",
    "author": {
      "name": "Sindre Sorhus",
      "email": "sindresorhus@gmail.com",
      "url": "https://sindresorhus.com"
    },
    "main": "dist/source",
    "engines": {
      "node": ">=12"
    },
    "scripts": {
      "test": "xo && npm run build && nyc ava",
      "build": "del-cli dist && tsc",
      "prepack": "npm run build"
    },
    "files": [
      "dist/source"
    ],
    "keywords": [
      "config",
      "store",
      "app",
      "storage",
      "conf",
      "configuration",
      "settings",
      "preferences",
      "json",
      "data",
      "persist",
      "persistent",
      "save",
      "load",
      "read",
      "write",
      "cache"
    ],
    "dependencies": {
      "ajv": "^8.6.3",
      "ajv-formats": "^2.1.1",
      "atomically": "^1.7.0",
      "debounce-fn": "^4.0.0",
      "dot-prop": "^6.0.1",
      "env-paths": "^2.2.1",
      "json-schema-typed": "^7.0.3",
      "onetime": "^5.1.2",
      "pkg-up": "^3.1.0",
      "semver": "^7.3.5"
    },
    "devDependencies": {
      "@ava/typescript": "^1.1.1",
      "@sindresorhus/tsconfig": "^0.7.0",
      "@types/node": "^14.14.41",
      "@types/semver": "^7.3.4",
      "@types/write-file-atomic": "^3.0.1",
      "ava": "^3.15.0",
      "clear-module": "^4.1.1",
      "del": "^6.0.0",
      "del-cli": "^3.0.1",
      "delay": "^5.0.0",
      "nyc": "^15.1.0",
      "p-event": "^4.2.0",
      "tempy": "^1.0.1",
      "tsd": "^0.14.0",
      "typescript": "^4.4.3",
      "xo": "^0.38.2"
    },
    "types": "dist/source",
    "ava": {
      "files": [
        "test/*",
        "!test/index.test-d.ts"
      ],
      "timeout": "1m",
      "typescript": {
        "rewritePaths": {
          "test/": "dist/test/"
        }
      }
    },
    "xo": {
      "rules": {
        "@typescript-eslint/no-implicit-any-catch": "off"
      }
    },
    "nyc": {
      "extension": [
        ".ts"
      ],
      "exclude": [
        "**/test/**"
      ]
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-conf-10.2.0-838e757be963f1a2386dfe048a98f8f69f7b55d6-integrity/node_modules/conf/package.json",
    "readmeFilename": "readme.md",
    "readme": "# conf\n\n> Simple config handling for your app or module\n\nAll you have to care about is what to persist. This module will handle all the dull details like where and how.\n\n**It does not support multiple processes writing to the same store.**\\\nI initially made this tool to let command-line tools persist some data.\n\n*If you need this for Electron, check out [`electron-store`](https://github.com/sindresorhus/electron-store) instead.*\n\n## Install\n\n```\n$ npm install conf\n```\n\n## Usage\n\n```js\nconst Conf = require('conf');\n\nconst config = new Conf();\n\nconfig.set('unicorn', 'ðŸ¦„');\nconsole.log(config.get('unicorn'));\n//=> 'ðŸ¦„'\n\n// Use dot-notation to access nested properties\nconfig.set('foo.bar', true);\nconsole.log(config.get('foo'));\n//=> {bar: true}\n\nconfig.delete('unicorn');\nconsole.log(config.get('unicorn'));\n//=> undefined\n```\n\nOr [create a subclass](https://github.com/sindresorhus/electron-store/blob/main/index.js).\n\n## API\n\nChanges are written to disk atomically, so if the process crashes during a write, it will not corrupt the existing config.\n\n### Conf(options?)\n\nReturns a new instance.\n\n### options\n\nType: `object`\n\n#### defaults\n\nType: `object`\n\nDefault values for the config items.\n\n**Note:** The values in `defaults` will overwrite the `default` key in the `schema` option.\n\n#### schema\n\nType: `object`\n\n[JSON Schema](https://json-schema.org) to validate your config data.\n\nUnder the hood, the JSON Schema validator [ajv](https://github.com/epoberezkin/ajv) is used to validate your config. We use [JSON Schema draft-07](https://json-schema.org/latest/json-schema-validation.html) and support all [validation keywords](https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md) and [formats](https://github.com/epoberezkin/ajv#formats).\n\nYou should define your schema as an object where each key is the name of your data's property and each value is a JSON schema used to validate that property. See more [here](https://json-schema.org/understanding-json-schema/reference/object.html#properties).\n\nExample:\n\n```js\nconst Conf = require('conf');\n\nconst schema = {\n\tfoo: {\n\t\ttype: 'number',\n\t\tmaximum: 100,\n\t\tminimum: 1,\n\t\tdefault: 50\n\t},\n\tbar: {\n\t\ttype: 'string',\n\t\tformat: 'url'\n\t}\n};\n\nconst config = new Conf({schema});\n\nconsole.log(config.get('foo'));\n//=> 50\n\nconfig.set('foo', '1');\n// [Error: Config schema violation: `foo` should be number]\n```\n\n**Note:** The `default` value will be overwritten by the `defaults` option if set.\n\n### migrations\n\nType: `object`\n\nYou can use migrations to perform operations to the store whenever a **project version** is upgraded.\n\nThe `migrations` object should consist of a key-value pair of `'version': handler`. The `version` can also be a [semver range](https://github.com/npm/node-semver#ranges).\n\nExample:\n\n```js\nconst Conf = require('conf');\n\nconst store = new Conf({\n\tmigrations: {\n\t\t'0.0.1': store => {\n\t\t\tstore.set('debugPhase', true);\n\t\t},\n\t\t'1.0.0': store => {\n\t\t\tstore.delete('debugPhase');\n\t\t\tstore.set('phase', '1.0.0');\n\t\t},\n\t\t'1.0.2': store => {\n\t\t\tstore.set('phase', '1.0.2');\n\t\t},\n\t\t'>=2.0.0': store => {\n\t\t\tstore.set('phase', '>=2.0.0');\n\t\t}\n\t}\n});\n```\n\n> Note: The version the migrations use refers to the **project version** by default. If you want to change this behavior, specify the [`projectVersion`](#projectVersion) option.\n\n### beforeEachMigration\n\nType: `Function`\\\nDefault: `undefined`\n\nThe given callback function will be called before each migration step.\n\nThe function receives the store as the first argument and a context object as the second argument with the following properties:\n\n- `fromVersion` - The version the migration step is being migrated from.\n- `toVersion` - The version the migration step is being migrated to.\n- `finalVersion` - The final version after all the migrations are applied.\n- `versions` - All the versions with a migration step.\n\nThis can be useful for logging purposes, preparing migration data, etc.\n\nExample:\n\n```js\nconst Conf = require('conf');\n\nconsole.log = someLogger.log;\n\nconst mainConfig = new Conf({\n\tbeforeEachMigration: (store, context) => {\n\t\tconsole.log(`[main-config] migrate from ${context.fromVersion} â†’ ${context.toVersion}`);\n\t},\n\tmigrations: {\n\t\t'0.4.0': store => {\n\t\t\tstore.set('debugPhase', true);\n\t\t},\n\t}\n});\n\nconst secondConfig = new Conf({\n\tbeforeEachMigration: (store, context) => {\n\t\tconsole.log(`[second-config] migrate from ${context.fromVersion} â†’ ${context.toVersion}`);\n\t},\n\tmigrations: {\n\t\t'1.0.1': store => {\n\t\t\tstore.set('debugPhase', true);\n\t\t},\n\t}\n});\n```\n\n#### configName\n\nType: `string`\\\nDefault: `'config'`\n\nName of the config file (without extension).\n\nUseful if you need multiple config files for your app or module. For example, different config files between two major versions.\n\n#### projectName\n\nType: `string`\\\nDefault: The `name` field in the package.json closest to where `conf` is imported.\n\nYou only need to specify this if you don't have a package.json file in your project or if it doesn't have a name defined within it.\n\n#### projectVersion\n\nType: `string`\\\nDefault: The `version` field in the package.json closest to where `conf` is imported.\n\nYou only need to specify this if you don't have a package.json file in your project or if it doesn't have a version defined within it.\n\n#### cwd\n\nType: `string`\\\nDefault: System default [user config directory](https://github.com/sindresorhus/env-paths#pathsconfig)\n\n**You most likely don't need this. Please don't use it unless you really have to. By default, it will pick the optimal location by adhering to system conventions. You are very likely to get this wrong and annoy users.**\n\nOverrides `projectName`.\n\nThe only use-case I can think of is having the config located in the app directory or on some external storage.\n\n#### encryptionKey\n\nType: `string | Buffer | TypedArray | DataView`\\\nDefault: `undefined`\n\nNote that this is **not intended for security purposes**, since the encryption key would be easily found inside a plain-text Node.js app.\n\nIts main use is for obscurity. If a user looks through the config directory and finds the config file, since it's just a JSON file, they may be tempted to modify it. By providing an encryption key, the file will be obfuscated, which should hopefully deter any users from doing so.\n\nWhen specified, the store will be encrypted using the [`aes-256-cbc`](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation) encryption algorithm.\n\n#### fileExtension\n\nType: `string`\\\nDefault: `'json'`\n\nExtension of the config file.\n\nYou would usually not need this, but could be useful if you want to interact with a file with a custom file extension that can be associated with your app. These might be simple save/export/preference files that are intended to be shareable or saved outside of the app.\n\n#### clearInvalidConfig\n\nType: `boolean`\\\nDefault: `false`\n\nThe config is cleared if reading the config file causes a `SyntaxError`. This is a good behavior for unimportant data, as the config file is not intended to be hand-edited, so it usually means the config is corrupt and there's nothing the user can do about it anyway. However, if you let the user edit the config file directly, mistakes might happen and it could be more useful to throw an error when the config is invalid instead of clearing.\n\n#### serialize\n\nType: `Function`\\\nDefault: `value => JSON.stringify(value, null, '\\t')`\n\nFunction to serialize the config object to a UTF-8 string when writing the config file.\n\nYou would usually not need this, but it could be useful if you want to use a format other than JSON.\n\n#### deserialize\n\nType: `Function`\\\nDefault: `JSON.parse`\n\nFunction to deserialize the config object from a UTF-8 string when reading the config file.\n\nYou would usually not need this, but it could be useful if you want to use a format other than JSON.\n\n#### projectSuffix\n\nType: `string`\\\nDefault: `'nodejs'`\n\n**You most likely don't need this. Please don't use it unless you really have to.**\n\nSuffix appended to `projectName` during config file creation to avoid name conflicts with native apps.\n\nYou can pass an empty string to remove the suffix.\n\nFor example, on macOS, the config file will be stored in the `~/Library/Preferences/foo-nodejs` directory, where `foo` is the `projectName`.\n\n#### accessPropertiesByDotNotation\n\nType: `boolean`\\\nDefault: `true`\n\nAccessing nested properties by dot notation. For example:\n\n```js\nconst Conf = require('conf');\n\nconst config = new Conf();\n\nconfig.set({\n\tfoo: {\n\t\tbar: {\n\t\t\tfoobar: 'ðŸ¦„'\n\t\t}\n\t}\n});\n\nconsole.log(config.get('foo.bar.foobar'));\n//=> 'ðŸ¦„'\n```\n\nAlternatively, you can set this option to `false` so the whole string would be treated as one key.\n\n```js\nconst Conf = require('conf');\n\nconst config = new Conf({accessPropertiesByDotNotation: false});\n\nconfig.set({\n\t`foo.bar.foobar`: 'ðŸ¦„'\n});\n\nconsole.log(config.get('foo.bar.foobar'));\n//=> 'ðŸ¦„'\n```\n\n#### watch\n\ntype: `boolean`\\\nDefault: `false`\n\nWatch for any changes in the config file and call the callback for `onDidChange` or `onDidAnyChange` if set. This is useful if there are multiple processes changing the same config file.\n\n#### configFileMode\n\nType: `number`\\\nDefault: `0o666`\n\nThe [mode](https://en.wikipedia.org/wiki/File-system_permissions#Numeric_notation) that will be used for the config file.\n\nYou would usually not need this, but it could be useful if you want to restrict the permissions of the config file. Setting a permission such as `0o600` would result in a config file that can only be accessed by the user running the program.\n\nNote that setting restrictive permissions can cause problems if different users need to read the file. A common problem is a user running your tool with and without `sudo` and then not being able to access the config the second time.\n\n### Instance\n\nYou can use [dot-notation](https://github.com/sindresorhus/dot-prop) in a `key` to access nested properties.\n\nThe instance is [`iterable`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Iteration_protocols) so you can use it directly in a [`forâ€¦of`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for...of) loop.\n\n#### .set(key, value)\n\nSet an item.\n\nThe `value` must be JSON serializable. Trying to set the type `undefined`, `function`, or `symbol` will result in a TypeError.\n\n#### .set(object)\n\nSet multiple items at once.\n\n#### .get(key, defaultValue?)\n\nGet an item or `defaultValue` if the item does not exist.\n\n#### .reset(...keys)\n\nReset items to their default values, as defined by the `defaults` or `schema` option.\n\nUse `.clear()` to reset all items.\n\n#### .has(key)\n\nCheck if an item exists.\n\n#### .delete(key)\n\nDelete an item.\n\n#### .clear()\n\nDelete all items.\n\nThis resets known items to their default values, if defined by the `defaults` or `schema` option.\n\n#### .onDidChange(key, callback)\n\n`callback`: `(newValue, oldValue) => {}`\n\nWatches the given `key`, calling `callback` on any changes.\n\nWhen a key is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.\n\nReturns a function which you can use to unsubscribe:\n\n```js\nconst unsubscribe = conf.onDidChange(key, callback);\n\nunsubscribe();\n```\n\n#### .onDidAnyChange(callback)\n\n`callback`: `(newValue, oldValue) => {}`\n\nWatches the whole config object, calling `callback` on any changes.\n\n`oldValue` and `newValue` will be the config object before and after the change, respectively. You must compare `oldValue` to `newValue` to find out what changed.\n\nReturns a function which you can use to unsubscribe:\n\n```js\nconst unsubscribe = conf.onDidAnyChange(callback);\n\nunsubscribe();\n```\n\n#### .size\n\nGet the item count.\n\n#### .store\n\nGet all the config as an object or replace the current config with an object:\n\n```js\nconf.store = {\n\thello: 'world'\n};\n```\n\n#### .path\n\nGet the path to the config file.\n\n## FAQ\n\n### How is this different from [`configstore`](https://github.com/yeoman/configstore)?\n\nI'm also the author of `configstore`. While it's pretty good, I did make some mistakes early on that are hard to change at this point. This module is the result of everything I learned from making `configstore`. Mainly where the config is stored. In `configstore`, the config is stored in `~/.config` (which is mainly a Linux convention) on all systems, while `conf` stores config in the system default [user config directory](https://github.com/sindresorhus/env-paths#pathsconfig). The `~/.config` directory, it turns out, often have an incorrect permission on macOS and Windows, which has caused a lot of grief for users.\n\n### Can I use YAML or another serialization format?\n\nThe `serialize` and `deserialize` options can be used to customize the format of the config file, as long as the representation is compatible with `utf8` encoding.\n\nExample using YAML:\n\n```js\nconst Conf = require('conf');\nconst yaml = require('js-yaml');\n\nconst config = new Conf({\n\tfileExtension: 'yaml',\n\tserialize: yaml.safeDump,\n\tdeserialize: yaml.safeLoad\n});\n```\n\n## Related\n\n- [electron-store](https://github.com/sindresorhus/electron-store) - Simple data persistence for your Electron app or module\n- [cache-conf](https://github.com/SamVerschueren/cache-conf) - Simple cache config handling for your app or module\n",
    "licenseText": "MIT License\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/conf/-/conf-10.2.0.tgz#838e757be963f1a2386dfe048a98f8f69f7b55d6",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/conf/-/conf-10.2.0.tgz",
    "hash": "838e757be963f1a2386dfe048a98f8f69f7b55d6",
    "integrity": "sha512-8fLl9F04EJqjSqH+QjITQfJF8BrOVaYr1jewVgSRAEWePfxT0sku4w2hrGQ60BC/TNLGQ2pgxNlTbWQmMPFvXg==",
    "registry": "npm",
    "packageName": "conf",
    "cacheIntegrity": "sha512-8fLl9F04EJqjSqH+QjITQfJF8BrOVaYr1jewVgSRAEWePfxT0sku4w2hrGQ60BC/TNLGQ2pgxNlTbWQmMPFvXg== sha1-g451e+lj8aI4bf4Eipj49p97VdY="
  },
  "registry": "npm",
  "hash": "838e757be963f1a2386dfe048a98f8f69f7b55d6"
}