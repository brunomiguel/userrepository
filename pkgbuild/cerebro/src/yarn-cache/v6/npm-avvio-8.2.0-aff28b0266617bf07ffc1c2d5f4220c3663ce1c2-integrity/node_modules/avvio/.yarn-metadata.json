{
  "manifest": {
    "name": "avvio",
    "version": "8.2.0",
    "description": "Asynchronous bootstrapping of Node applications",
    "main": "boot.js",
    "scripts": {
      "test": "standard && tap -J test/*test.js && npm run typescript",
      "typescript": "tsc --project ./test/types/tsconfig.json"
    },
    "precommit": "test",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/fastify/avvio.git"
    },
    "keywords": [
      "async",
      "boot",
      "delayed",
      "open"
    ],
    "author": {
      "name": "Matteo Collina",
      "email": "hello@matteocollina.com"
    },
    "contributors": [
      {
        "name": "Tomas Della Vedova",
        "url": "http://delved.org"
      }
    ],
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/fastify/avvio/issues"
    },
    "homepage": "https://github.com/fastify/avvio#readme",
    "devDependencies": {
      "@types/node": "^18.0.0",
      "express": "^4.17.1",
      "pre-commit": "^1.2.2",
      "semver": "^7.1.3",
      "standard": "^17.0.0",
      "tap": "^16.0.0",
      "then-sleep": "^1.0.1",
      "typescript": "^4.0.2"
    },
    "dependencies": {
      "archy": "^1.0.0",
      "debug": "^4.0.0",
      "fastq": "^1.6.1"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-avvio-8.2.0-aff28b0266617bf07ffc1c2d5f4220c3663ce1c2-integrity/node_modules/avvio/package.json",
    "readmeFilename": "README.md",
    "readme": "# avvio\n\n![CI](https://github.com/fastify/avvio/workflows/CI/badge.svg)\n[![NPM version](https://img.shields.io/npm/v/avvio.svg?style=flat)](https://www.npmjs.com/package/avvio)\n[![js-standard-style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat)](https://standardjs.com/)\n\nAsynchronous bootstrapping is hard, different things can go wrong, *error handling* and *load order* just to name a few. The aim of this module is to make it simple.\n\n`avvio` is fully *reentrant* and *graph-based*. You can load\ncomponents/plugins *within* plugins, and be still sure that things will\nhappen in the right order. At the end of the loading, your application will start.\n\n* [Install](#install)\n* [Example](#example)\n* [API](#api)\n* [Acknowledgements](#acknowledgements)\n* [License](#license)\n\n<a name=\"install\"></a>\n## Install\n\nTo install `avvio`, simply use npm:\n\n```\nnpm install avvio --save\n```\n\n<a name=\"example\"></a>\n## Example\n\nThe example below can be found [here][example] and run using `node example.js`.\nIt demonstrates how to use `avvio` to load functions / plugins in order.\n\n\n```js\n'use strict'\n\nconst app = require('avvio')()\n\napp\n  .use(first, { hello: 'world' })\n  .after((err, cb) => {\n    console.log('after first and second')\n    cb()\n  })\n\napp.use(third)\n\napp.ready(function (err) {\n  // the error must be handled somehow\n  if (err) {\n    throw err\n  }\n  console.log('application booted!')\n})\n\nfunction first (instance, opts, cb) {\n  console.log('first loaded', opts)\n  instance.use(second)\n  cb()\n}\n\nfunction second (instance, opts, cb) {\n  console.log('second loaded')\n  process.nextTick(cb)\n}\n\n// async/await or Promise support\nasync function third (instance, opts) {\n  console.log('third loaded')\n}\n```\n\n<a name=\"api\"></a>\n## API\n\n  * <a href=\"#constructor\"><code><b>avvio()</b></code></a>\n  * <a href=\"#use\"><code>instance.<b>use()</b></code></a>\n  * <a href=\"#after\"><code>instance.<b>after()</b></code></a>\n  * <a href=\"#await-after\"><code>await instance.<b>after()</b></code></a>\n  * <a href=\"#ready\"><code>instance.<b>ready()</b></code></a>\n  * <a href=\"#start\"><code>instance.<b>start()</b></code></a>\n  * <a href=\"#override\"><code>instance.<b>override()</b></code></a>\n  * <a href=\"#onClose\"><code>instance.<b>onClose()</b></code></a>\n  * <a href=\"#close\"><code>instance.<b>close()</b></code></a>\n  * <a href=\"#express\"><code>avvio.<b>express()</b></code></a>\n  * <a href=\"#toJSON\"><code>avvio.<b>toJSON()</b></code></a>\n  * <a href=\"#prettyPrint\"><code>avvio.<b>prettyPrint()</b></code></a>\n\n-------------------------------------------------------\n<a name=\"constructor\"></a>\n\n### avvio([instance], [options], [started])\n\nStarts the avvio sequence.\nAs the name suggests, `instance` is the object representing your application.\nAvvio will add the functions `use`, `after` and `ready` to the instance.\n\n```js\nconst server = {}\n\nrequire('avvio')(server)\n\nserver.use(function first (s, opts, cb) {\n  // s is the same of server\n  s.use(function second (s, opts, cb) {\n    cb()\n  })\n  cb()\n}).after(function (err, cb) {\n  // after first and second are finished\n  cb()\n})\n```\n\nOptions:\n\n* `expose`: a key/value property to change how `use`, `after` and `ready` are exposed.\n* `autostart`: do not start loading plugins automatically, but wait for\n  a call to [`.start()`](#start)  or [`.ready()`](#ready).\n* `timeout`: the number of millis to wait for a plugin to load after which\n  it will error with code `ERR_AVVIO_PLUGIN_TIMEOUT`. Default\n  `0` (disabled).\n\nEvents:\n\n* `'start'`  when the application starts\n* `'preReady'` fired before the ready queue is run\n\nThe `avvio` function can also be used as a\nconstructor to inherit from.\n```js\nfunction Server () {}\nconst app = require('avvio')(new Server())\n\napp.use(function (s, opts, done) {\n  // your code\n  done()\n})\n\napp.on('start', () => {\n  // you app can start\n})\n```\n\n-------------------------------------------------------\n<a name=\"use\"></a>\n\n### app.use(func, [optsOrFunc]) => Thenable\n\nLoads one or more functions asynchronously.\n\nThe function **must** have the signature: `instance, options, done`\n\nHowever, if the function returns a `Promise` (i.e. `async`), the above function signature is not required.\n\nPlugin example:\n```js\nfunction plugin (server, opts, done) {\n  done()\n}\n\napp.use(plugin)\n```\n`done` should be called only once, when your plugin is ready to go.  Additional\ncalls to `done` are ignored.\n\n`use` returns a thenable wrapped instance on which `use` is called, to support a chainable API that can also be awaited.\n\nThis way, async/await is also supported and `use` can be awaited instead of using `after`.\n\nExample using `after`:\n\n```js\nasync function main () {\n  console.log('begin')\n  app.use(async function (server, opts) {\n    await sleep(10)\n    console.log('this first')\n  })\n  app.after(async (err) => {\n    if (err) throw err\n    console.log('then this')\n  })\n  await app.ready()\n  console.log('ready')\n}\nmain().catch((err) => console.error(err))\n```\n\nExample using `await after`:\n\n\n```js\nasync function main () {\n  console.log('begin')\n  app.use(async function (server, opts) {\n    await sleep(10)\n    console.log('this first')\n  })\n  await app.after()\n  console.log('then this')\n  await app.ready()\n  console.log('ready')\n}\nmain().catch((err) => console.error(err))\n```\n\nExample using `await use`:\n\n```js\nasync function main () {\n  console.log('begin')\n  await app.use(async function (server, opts) {\n    await sleep(10)\n    console.log('this first')\n  })\n  console.log('then this')\n  await app.ready()\n  console.log('ready')\n}\nmain().catch((err) => console.error(err))\n```\n\nA function that returns the options argument instead of an object is supported as well:\n\n```js\nfunction first (server, opts, done) {\n  server.foo = 'bar'\n  done()\n}\n\nfunction second (server, opts, done) {\n  console.log(opts.foo === 'bar') // Evaluates to true\n  done()\n}\n\n/**\n * If the options argument is a function, it has access to the parent\n * instance via the first positional variable\n */\nconst func = parent => {\n  return {\n    foo: parent.foo\n  }\n}\n\napp.use(first)\napp.use(second, func)\n```\n\nThis is useful in cases where an injected variable from a plugin needs to be made available to another.\n\nIt is also possible to use [esm](https://nodejs.org/api/esm.html) with `import('./file.mjs')`:\n\n```js\nimport boot from 'avvio'\n\nconst app = boot()\napp.use(import('./fixtures/esm.mjs'))\n```\n\n-------------------------------------------------------\n<a name=\"error-handling\"></a>\n#### Error handling\n\nIn order to handle errors in the loading plugins, you must use the\n`.ready()` method, like so:\n\n```js\napp.use(function (instance, opts, done) {\n  done(new Error('error'))\n}, opts)\n\napp.ready(function (err) {\n  if (err) throw err\n})\n```\n\nWhen an error happens, the loading of plugins will stop until there is\nan [`after`](#after) callback specified. Otherwise, it will be handled\nin [`ready`](#ready).\n\n-------------------------------------------------------\n<a name=\"after\"></a>\n\n### app.after(func(error, [context], [done]))\n\nCalls a function after all the previously defined plugins are loaded, including\nall their dependencies. The `'start'` event is not emitted yet.\n\nNote: `await after` can be used as an awaitable alternative to `after(func)`, or `await use` can be also as a shorthand for `use(plugin); await after()`.\n\nThe callback changes based on the parameters you give:\n1. If no parameter is given to the callback and there is an error, that error will be passed to the next error handler.\n2. If one parameter is given to the callback, that parameter will be the `error` object.\n3. If two parameters are given to the callback, the first will be the `error` object, the second will be the `done` callback.\n4. If three parameters are given to the callback, the first will be the `error` object, the second will be the top level `context` and the third the `done` callback.\n\nIn the \"no parameter\" and \"one parameter\" variants, the callback can return a `Promise`.\n\n```js\nconst server = {}\nconst app = require('avvio')(server)\n\n...\n// after with one parameter\napp.after(function (err) {\n  if (err) throw err\n})\n\n// after with two parameter\napp.after(function (err, done) {\n  if (err) throw err\n  done()\n})\n\n// after with three parameters\napp.after(function (err, context, done) {\n  if (err) throw err\n  assert.equal(context, server)\n  done()\n})\n\n// async after with one parameter\napp.after(async function (err) {\n  await sleep(10)\n  if (err) {\n    throw err\n  }\n})\n\n// async after with no parameter\napp.after(async function () {\n  await sleep(10)\n})\n```\n\n`done` must be called only once.\n\nIf called with a function, it returns the instance on which `after` is called, to support a chainable API.\n\n-------------------------------------------------------\n<a name=\"await-after\"></a>\n\n### await app.after() | app.after() => Promise\n\nCalling after with no function argument loads any plugins previously registered via `use` and returns a promise, which resolves when all plugins registered so far have loaded.\n\n```js\nasync function main () {\n  app.use(async function (server, opts) {\n    await sleep(10)\n    console.log('this first')\n  })\n  app.use(async function (server, opts) {\n    await sleep(10)\n    console.log('this second')\n  })\n  console.log('before after')\n  await app.after()\n  console.log('after after')\n  app.use(async function (server, opts) {\n    await sleep(10)\n    console.log('this third')\n  })\n  await app.ready()\n  console.log('ready')\n}\nmain().catch((err) => console.error(err))\n```\n\nUnlike `after` and `use`, `await after` is *not* chainable.\n\n-------------------------------------------------------\n<a name=\"ready\"></a>\n\n### app.ready([func(error, [context], [done])])\n\nCalls a function after all the plugins and `after` call are completed, but before `'start'` is emitted. `ready` callbacks are executed one at a time.\n\nThe callback changes based on the parameters you give:\n1. If no parameter is given to the callback and there is an error, that error will be passed to the next error handler.\n2. If one parameter is given to the callback, that parameter will be the `error` object.\n3. If two parameters are given to the callback, the first will be the `error` object, the second will be the `done` callback.\n4. If three parameters are given to the callback, the first will be the `error` object, the second will be the top level `context` unless you have specified both server and override, in that case the `context` will be what the override returns, and the third the `done` callback.\n\nIf no callback is provided `ready` will return a Promise that is resolved or rejected once plugins and `after` calls are completed.  On success `context` is provided to the `.then` callback, if an error occurs it is provided to the `.catch` callback.\n\n```js\nconst server = {}\nconst app = require('avvio')(server)\n...\n// ready with one parameter\napp.ready(function (err) {\n  if (err) throw err\n})\n\n// ready with two parameter\napp.ready(function (err, done) {\n  if (err) throw err\n  done()\n})\n\n// ready with three parameters\napp.ready(function (err, context, done) {\n  if (err) throw err\n  assert.equal(context, server)\n  done()\n})\n\n// ready with Promise\napp.ready()\n  .then(() => console.log('Ready'))\n  .catch(err => {\n    console.error(err)\n    process.exit(1)\n  })\n\n// await ready from an async function.\nasync function main () [\n  try {\n    await app.ready()\n    console.log('Ready')\n  } catch(err) {\n    console.error(err)\n    process.exit(1)\n  }\n}\n```\n\n`done` must be called only once.\n\nThe callback form of this function has no return value.\n\nIf `autostart: false` is passed as an option, calling `.ready()`  will\nalso start the boot sequence.\n\n-------------------------------------------------------\n<a name=\"start\"></a>\n\n### app.start()\n\nStart the boot sequence, if it was not started yet.\nReturns the `app` instance.\n\n-------------------------------------------------------\n<a name=\"express\"></a>\n\n### avvio.express(app)\n\nSame as:\n\n```js\nconst app = express()\nconst avvio = require('avvio')\n\navvio(app, {\n  expose: {\n    use: 'load'\n  }\n})\n```\n\n-------------------------------------------------------\n<a name=\"override\"></a>\n\n### app.override(server, plugin, options)\n\nAllows overriding the instance of the server for each loading plugin.\nIt allows the creation of an inheritance chain for the server instances.\nThe first parameter is the server instance and the second is the plugin function while the third is the options object that you give to use.\n\n```js\nconst assert = require('assert')\nconst server = { count: 0 }\nconst app = require('avvio')(server)\n\nconsole.log(app !== server, 'override must be set on the Avvio instance')\n\napp.override = function (s, fn, opts) {\n  // create a new instance with the\n  // server as the prototype\n  const res = Object.create(s)\n  res.count = res.count + 1\n\n  return res\n}\n\napp.use(function first (s1, opts, cb) {\n  assert(s1 !== server)\n  assert(server.isPrototypeOf(s1))\n  assert(s1.count === 1)\n  s1.use(second)\n  cb()\n\n  function second (s2, opts, cb) {\n    assert(s2 !== s1)\n    assert(s1.isPrototypeOf(s2))\n    assert(s2.count === 2)\n    cb()\n  }\n})\n```\n-------------------------------------------------------\n\n<a name=\"onClose\"></a>\n### app.onClose(func([context], [done]))\n\nRegisters a new callback that will be fired once then `close` api is called.\n\nThe callback changes basing on the parameters you give:\n1. If one parameter is given to the callback, that parameter will be the `context`.\n2. If zero or one parameter is given, the callback may return a promise\n3. If two parameters are given to the callback, the first will be the top level `context` unless you have specified both server and override, in that case the `context` will be what the override returns, the second will be the `done` callback.\n\n```js\nconst server = {}\nconst app = require('avvio')(server)\n...\n// onClose with one parameter\napp.onClose(function (context) {\n  // ...\n})\n\n// onClose with one parameter, returning a promise\napp.onClose(function (context) {\n  return new Promise((resolve, reject) => {\n    // ...\n  })\n})\n\n// async onClose with one parameter\napp.onClose(async function (context) {\n  // ...\n  await ...\n})\n\n\n// onClose with two parameter\napp.onClose(function (context, done) {\n  // ...\n  done()\n})\n```\n\nIf the callback returns a promise, the next onClose callback and the close callback will not run until the promise is either resolved or rejected.\n\n`done` must be called only once.\nReturns the instance on which `onClose` is called, to support a chainable API.\n\n-------------------------------------------------------\n\n<a name=\"close\"></a>\n### app.close(func(error, [context], [done]))\n\nStarts the shutdown procedure, the callback is called once all the registered callbacks with `onClose` has been executed.\n\nThe callback changes based on the parameters you give:\n1. If one parameter is given to the callback, that parameter will be the `error` object.\n2. If two parameters are given to the callback, the first will be the `error` object, the second will be the `done` callback.\n3. If three parameters are given to the callback, the first will be the `error` object, the second will be the top level `context` unless you have specified both server and override, in that case the `context` will be what the override returns, and the third the `done` callback.\n\nIf no callback is provided `close` will return a Promise.\n\n```js\nconst server = {}\nconst app = require('avvio')(server)\n...\n// close with one parameter\napp.close(function (err) {\n  if (err) throw err\n})\n\n// close with two parameter\napp.close(function (err, done) {\n  if (err) throw err\n  done()\n})\n\n// close with three parameters\napp.close(function (err, context, done) {\n  if (err) throw err\n  assert.equal(context, server)\n  done()\n})\n\n// close with Promise\napp.close()\n  .then(() => console.log('Closed'))\n  .catch(err => {\n    console.error(err)\n    process.exit(1)\n  })\n\n```\n\n`done` must be called only once.\n\n-------------------------------------------------------\n\n<a name=\"toJSON\"></a>\n\n### avvio.toJSON()\n\nReturn a JSON tree representing the state of the plugins and the loading time.\nCall it on `preReady` to get the complete tree.\n\n```js\nconst avvio = require('avvio')()\navvio.on('preReady', () => {\n  avvio.toJSON()\n})\n```\n\nThe output is like this:\n```json\n{\n  \"label\": \"bound root\",\n  \"start\": 1550245184665,\n  \"nodes\": [\n    {\n      \"parent\": \"bound root\",\n      \"start\": 1550245184665,\n      \"label\": \"first\",\n      \"nodes\": [\n        {\n          \"parent\": \"first\",\n          \"start\": 1550245184708,\n          \"label\": \"second\",\n          \"nodes\": [],\n          \"stop\": 1550245184709,\n          \"diff\": 1\n        }\n      ],\n      \"stop\": 1550245184709,\n      \"diff\": 44\n    },\n    {\n      \"parent\": \"bound root\",\n      \"start\": 1550245184709,\n      \"label\": \"third\",\n      \"nodes\": [],\n      \"stop\": 1550245184709,\n      \"diff\": 0\n    }\n  ],\n  \"stop\": 1550245184709,\n  \"diff\": 44\n}\n```\n\n-------------------------------------------------------\n\n<a name=\"prettyPrint\"></a>\n\n### avvio.prettyPrint()\n\nThis method will return a printable string with the tree returned by the `toJSON()` method.\n\n```js\nconst avvio = require('avvio')()\navvio.on('preReady', () => {\n  console.log(avvio.prettyPrint())\n})\n```\n\nThe output will be like:\n\n```\navvio 56 ms\n├── first 52 ms\n├── second 1 ms\n└── third 2 ms\n```\n\n-------------------------------------------------------\n\n## Acknowledgements\n\nThis project was kindly sponsored by [nearForm](https://nearform.com).\n\n## License\n\nCopyright Matteo Collina 2016-2020, Licensed under [MIT][].\n\n[MIT]: ./LICENSE\n[example]: ./example.js\n",
    "licenseText": "MIT License\n\nCopyright (c) 2016-2020 Matteo Collina\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/avvio/-/avvio-8.2.0.tgz#aff28b0266617bf07ffc1c2d5f4220c3663ce1c2",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/avvio/-/avvio-8.2.0.tgz",
    "hash": "aff28b0266617bf07ffc1c2d5f4220c3663ce1c2",
    "integrity": "sha512-bbCQdg7bpEv6kGH41RO/3B2/GMMmJSo2iBK+X8AWN9mujtfUipMDfIjsgHCfpnKqoGEQrrmCDKSa5OQ19+fDmg==",
    "registry": "npm",
    "packageName": "avvio",
    "cacheIntegrity": "sha512-bbCQdg7bpEv6kGH41RO/3B2/GMMmJSo2iBK+X8AWN9mujtfUipMDfIjsgHCfpnKqoGEQrrmCDKSa5OQ19+fDmg== sha1-r/KLAmZhe/B//BwtX0Igw2Y84cI="
  },
  "registry": "npm",
  "hash": "aff28b0266617bf07ffc1c2d5f4220c3663ce1c2"
}