{
  "manifest": {
    "name": "@sinclair/typebox",
    "version": "0.24.51",
    "description": "JSONSchema Type Builder with Static Type Resolution for TypeScript",
    "keywords": [
      "typescript",
      "json-schema",
      "validate",
      "typecheck"
    ],
    "author": {
      "name": "sinclairzx81"
    },
    "license": "MIT",
    "main": "./typebox.js",
    "types": "./typebox.d.ts",
    "repository": {
      "type": "git",
      "url": "https://github.com/sinclairzx81/typebox"
    },
    "scripts": {
      "clean": "hammer task clean",
      "format": "hammer task format",
      "start": "hammer task start",
      "test": "hammer task test",
      "benchmark": "hammer task benchmark",
      "build": "hammer task build",
      "publish": "hammer task publish"
    },
    "devDependencies": {
      "@sinclair/hammer": "^0.17.1",
      "@types/chai": "^4.3.3",
      "@types/mocha": "^9.1.1",
      "@types/node": "^18.7.13",
      "ajv": "^8.11.0",
      "ajv-formats": "^2.1.1",
      "chai": "^4.3.6",
      "mocha": "^9.2.2",
      "prettier": "^2.7.1",
      "typescript": "^4.8.2"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-@sinclair-typebox-0.24.51-645f33fe4e02defe26f2f5c0410e1c094eac7f5f-integrity/node_modules/@sinclair/typebox/package.json",
    "readmeFilename": "readme.md",
    "readme": "<div align='center'>\n\n<h1>TypeBox</h1>\n\n<p>JSON Schema Type Builder with Static Type Resolution for TypeScript</p>\n\t\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\n\n<br />\n<br />\n\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\n[![GitHub CI](https://github.com/sinclairzx81/typebox/workflows/GitHub%20CI/badge.svg)](https://github.com/sinclairzx81/typebox/actions)\n\n</div>\n\n<a name=\"Install\"></a>\n\n## Install\n\nNode\n\n```bash\n$ npm install @sinclair/typebox --save\n```\n\nDeno and ESM\n\n```typescript\nimport { Static, Type } from 'https://esm.sh/@sinclair/typebox'\n```\n\n## Example\n\n```typescript\nimport { Static, Type } from '@sinclair/typebox'\n\nconst T = Type.String()     // const T = { type: 'string' }\n\ntype T = Static<typeof T>   // type T = string\n```\n\n<a name=\"Overview\"></a>\n\n## Overview\n\nTypeBox is a type builder library that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\n\nTypeBox is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used either as a simple tool to build up complex schemas or integrated into REST and RPC services to help validate data received over the wire. \n\nLicense MIT\n\n## Contents\n- [Install](#install)\n- [Overview](#overview)\n- [Usage](#usage)\n- [Types](#types)\n  - [Standard](#types-standard)\n  - [Modifiers](#types-modifiers)\n  - [Options](#types-options)\n  - [Extended](#types-extended)\n  - [Reference](#types-reference)\n  - [Recursive](#types-recursive)\n  - [Generic](#types-generic)\n  - [Conditional](#types-conditional)\n  - [Unsafe](#types-unsafe)\n  - [Guards](#types-guards)\n  - [Strict](#types-strict)\n- [Values](#values)\n  - [Create](#values-create)\n  - [Clone](#values-clone)\n  - [Check](#values-check)\n  - [Cast](#values-cast)\n  - [Equal](#values-equal)\n  - [Diff](#values-diff)\n  - [Patch](#values-patch)\n  - [Errors](#values-errors)\n  - [Pointer](#values-pointer)\n- [TypeCheck](#typecheck)\n  - [Ajv](#typecheck-ajv)\n  - [Compiler](#typecheck-compiler)\n  - [Formats](#typecheck-formats)\n- [Benchmark](#benchmark)\n  - [Compile](#benchmark-compile)\n  - [Validate](#benchmark-validate)\n  - [Compression](#benchmark-compression)\n- [Contribute](#contribute)\n\n<a name=\"Example\"></a>\n\n## Usage\n\nThe following demonstrates TypeBox's general usage.\n\n```typescript\n\nimport { Static, Type } from '@sinclair/typebox'\n\n//--------------------------------------------------------------------------------------------\n//\n// Let's say you have the following type ...\n//\n//--------------------------------------------------------------------------------------------\n\ntype T = {\n  id: string,\n  name: string,\n  timestamp: number\n}\n\n//--------------------------------------------------------------------------------------------\n//\n// ... you can express this type in the following way.\n//\n//--------------------------------------------------------------------------------------------\n\nconst T = Type.Object({                              // const T = {\n  id: Type.String(),                                 //   type: 'object',\n  name: Type.String(),                               //   properties: { \n  timestamp: Type.Integer()                          //     id: { \n})                                                   //       type: 'string' \n                                                     //     },\n                                                     //     name: { \n                                                     //       type: 'string' \n                                                     //     },\n                                                     //     timestamp: { \n                                                     //       type: 'integer' \n                                                     //     }\n                                                     //   }, \n                                                     //   required: [\n                                                     //     'id',\n                                                     //     'name',\n                                                     //     'timestamp'\n                                                     //   ]\n                                                     // } \n\n//--------------------------------------------------------------------------------------------\n//\n// ... then infer back to the original static type this way.\n//\n//--------------------------------------------------------------------------------------------\n\ntype T = Static<typeof T>                            // type T = {\n                                                     //   id: string,\n                                                     //   name: string,\n                                                     //   timestamp: number\n                                                     // }\n\n//--------------------------------------------------------------------------------------------\n//\n// ... then use the type both as JSON schema and as a TypeScript type.\n//\n//--------------------------------------------------------------------------------------------\n\nfunction receive(value: T) {                         // ... as a Type\n\n  if(JSON.validate(T, value)) {                      // ... as a Schema\n  \n    // ok...\n  }\n}\n```\n\n<a name='types'></a>\n\n## Types\n\nTypeBox provides a set of functions that allow you to compose JSON Schema similar to how you would compose static types with TypeScript. Each function creates a JSON schema fragment which can compose into more complex types. The schemas produced by TypeBox can be passed directly to any JSON Schema compliant validator, or used to reflect runtime metadata for a type.\n\n<a name='types-standard'></a>\n\n### Standard\n\nThe following table lists the standard TypeBox types.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\n│                                │                             │   type: 'string'               │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\n│                                │                             │   type: 'number'               │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\n│                                │                             │   type: 'integer'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\n│                                │                             │   type: 'boolean'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\n│                                │                             │    type: 'null'                │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.RegEx(/foo/)    │ type T = string             │ const T = {                    │\n│                                │                             │    type: 'string',             │\n│                                │                             │    pattern: 'foo'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\n│                                │                             │    const: 42,                  │\n│                                │                             │    type: 'number'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\n│   Type.Number()                │                             │   type: 'array',               │\n│ )                              │                             │   items: {                     │\n│                                │                             │     type: 'number'             │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\n│   y: Type.Number()             │   y: number                 │   properties: {                │\n│ })                             │ }                           │      x: {                      │\n│                                │                             │        type: 'number'          │\n│                                │                             │      },                        │\n│                                │                             │      y: {                      │\n│                                │                             │        type: 'number'          │\n│                                │                             │      }                         │\n│                                │                             │   },                           │\n│                                │                             │   required: ['x', 'y']         │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\n│   Type.Number(),               │                             │   type: 'array',               │\n│   Type.Number()                │                             │   items: [{                    │\n│ ])                             │                             │      type: 'number'            │\n│                                │                             │    }, {                        │\n│                                │                             │      type: 'number'            │\n│                                │                             │    }],                         │\n│                                │                             │    additionalItems: false,     │\n│                                │                             │    minItems: 2,                │\n│                                │                             │    maxItems: 2                 │\n│                                │                             │ }                              │\n│                                │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\n│   A,                           │   A,                        │   anyOf: [{                    │\n│   B                            │   B                         │     type: 'number',            │\n│ }                              │ }                           │     const: 0                   │\n│                                │                             │   }, {                         │\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\n│                                │                             │     const: 1                   │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\n│   })                           │                             │   }, {                         │\n│ )                              │                             │     type: 'string',            │\n│                                │                             │     const: 'y'                 │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\n│   Type.String(),               │                             │   anyOf: [{                    │\n│   Type.Number()                │                             │      type: 'string'            │\n│ ])                             │                             │   }, {                         │\n│                                │                             │      type: 'number'            │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\n│   Type.Object({                │   x: number                 │   type: 'object',              │\n│     x: Type.Number()           │ } & {                       │   properties: {                │\n│   }),                          │   y: number                 │     x: {                       │\n│   Type.Object({                │ }                           │       type: 'number'           │\n│     y: Type.Number()           │                             │     },                         │\n│   })                           │                             │     y: {                       │\n│ ])                             │                             │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['x', 'y']         │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\n│                                │                             │   allOf: [{                    │\n│                                │                             │     type: 'boolean',           │\n│                                │                             │     const: false               │\n│                                │                             │   }, {                         │\n│                                │                             │     type: 'boolean',           │\n│                                │                             │     const: true                │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\n│   Type.String(),               │   string,                   │   type: 'object',              │\n│   Type.Number()                │   number,                   │   patternProperties: {         │\n│ )                              │ >                           │     '^.*$': {                  │\n│                                │                             │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\n│   Type.Object({                │   x: number,                │   type: 'object',              │\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\n│     y: Type.Number()           | }>                          │     x: {                       │\n│   })                           │                             │       type: 'number'           │\n│ )                              │                             │     },                         │\n│                                │                             │     y: {                       │\n│                                │                             │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\n│     x: Type.Optional(          │   y?: number                │   properties: {                │\n│       Type.Number()            | }>                          │     x: {                       │\n│     ),                         │                             │       type: 'number'           │\n│     y: Type.Optional(          │                             │     },                         │\n│       Type.Number()            │                             │     y: {                       │\n│     )                          │                             │       type: 'number'           │\n│   })                           │                             │     }                          │\n│ )                              │                             │   },                           │\n│                                │                             │   required: ['x', 'y']         │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\n│   Type.Object({                │   x: number,                │   type: 'object',              │\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\n│     y: Type.Number()           | }, 'x'>                     │     x: {                       │\n│   }), ['x']                    │                             │       type: 'number'           │\n│ )                              │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['x']              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\n│   Type.Object({                │   x: number,                │   type: 'object',              │\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\n│     y: Type.Number()           | }, 'x'>                     │     y: {                       │\n│   }), ['x']                    │                             │       type: 'number'           │\n│ )                              │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['y']              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n<a name='types-modifiers'></a>\n\n### Modifiers\n\nTypeBox provides modifiers that can be applied to an objects properties. This allows for `optional` and `readonly` to be applied to that property. The following table illustates how they map between TypeScript and JSON Schema.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\n│     Type.String()              │ }                           │   properties: {                │\n│   )                            │                             │      name: {                   │\n│ })  \t                         │                             │        type: 'string'          │\n│                                │                             │      }                         │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\n│     Type.String()              │ }                           │   properties: {                │\n│   )                            │                             │     name: {                    │\n│ })  \t                         │                             │       type: 'string'           │\n│                                │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['name']           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\n│     Type.String()              │ }                           │   properties: {                │\n│   )                            │                             │     name: {                    │\n│ })  \t                         │                             │       type: 'string'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n<a name='types-options'></a>\n\n### Options\n\nYou can pass additional JSON schema options on the last argument of any given type. The following are some examples.\n\n```typescript\n// string must be an email\nconst T = Type.String({ format: 'email' })\n\n// number must be a multiple of 2\nconst T = Type.Number({ multipleOf: 2 })\n\n// array must have at least 5 integer values\nconst T = Type.Array(Type.Integer(), { minItems: 5 })\n```\n\n<a name='types-extended'></a>\n\n### Extended\n\nIn addition to JSON schema types, TypeBox provides several extended types that allow for the composition of `function` and `constructor` types. These additional types are not valid JSON Schema and will not validate using typical JSON Schema validation. However, these types can be used to frame JSON schema and describe callable interfaces that may receive JSON validated data. These types are as follows.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\n│   Type.String(),               │  arg0: string,              │   type: 'constructor'          │\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\n│                                │                             │   }, {                         │\n│                                │                             │     type: 'number'             │\n│                                │                             │   }],                          │\n│                                │                             │   return: {                    │\n│                                │                             │     type: 'boolean'            │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\n|   Type.String(),               │  arg0: string,              │   type : 'function',           │\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\n│                                │                             │   }, {                         │\n│                                │                             │     type: 'number'             │\n│                                │                             │   }],                          │\n│                                │                             │   return: {                    │\n│                                │                             │     type: 'boolean'            │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\n│                                │                             │   type: 'object',              │\n│                                │                             │   specialized: 'Uint8Array'    │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\n│   Type.String()                │                             │   type: 'promise',             │\n│ )                              │                             │   item: {                      │\n│                                │                             │     type: 'string'             │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\n│                                │                             │   type: 'object',              │\n│                                │                             │   specialized: 'Undefined'     │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\n│                                │                             │   type: 'null'                 │\n│                                │                             │ }                              │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n<a name='types-reference'></a>\n\n### Reference\n\nUse `Type.Ref(...)` to create referenced types. The target type must specify an `$id`.\n\n```typescript\nconst T = Type.String({ $id: 'T' })                  // const T = {\n                                                     //    $id: 'T',\n                                                     //    type: 'string'\n                                                     // }\n                                             \nconst R = Type.Ref(T)                                // const R = {\n                                                     //    $ref: 'T'\n                                                     // }\n```\n\n<a name='types-recursive'></a>\n\n### Recursive\n\nUse `Type.Recursive(...)` to create recursive types.\n\n```typescript\nconst Node = Type.Recursive(Node => Type.Object({    // const Node = {\n  id: Type.String(),                                 //   $id: 'Node',\n  nodes: Type.Array(Node)                            //   type: 'object',\n}), { $id: 'Node' })                                 //   properties: {\n                                                     //     id: {\n                                                     //       type: 'string'\n                                                     //     },\n                                                     //     nodes: {\n                                                     //       type: 'array',\n                                                     //       items: {\n                                                     //         $ref: 'Node'\n                                                     //       }\n                                                     //     }\n                                                     //   },\n                                                     //   required: [\n                                                     //     'id',\n                                                     //     'nodes'\n                                                     //   ]\n                                                     // }\n\ntype Node = Static<typeof Node>                      // type Node = {\n                                                     //   id: string\n                                                     //   nodes: Node[]\n                                                     // }\n\nfunction test(node: Node) {\n  const id = node.nodes[0].nodes[0]                  // id is string\n                 .nodes[0].nodes[0]\n                 .id\n}\n```\n\n<a name='types-generic'></a>\n\n### Generic\n\nUse functions to create generic types. The following creates a generic `Nullable<T>` type. \n\n```typescript\nimport { Type, Static, TSchema } from '@sinclair/typebox'\n\nconst Nullable = <T extends TSchema>(type: T) => Type.Union([type, Type.Null()])\n\nconst T = Nullable(Type.String())                    // const T = {\n                                                     //   anyOf: [{\n                                                     //     type: 'string'\n                                                     //   }, {\n                                                     //     type: 'null'\n                                                     //   }]\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = string | null\n\nconst U = Nullable(Type.Number())                    // const U = {\n                                                     //   anyOf: [{\n                                                     //     type: 'number'\n                                                     //   }, {\n                                                     //     type: 'null'\n                                                     //   }]\n                                                     // }\n\ntype U = Static<typeof U>                            // type U = number | null\n```\n\n<a name='types-conditional'></a>\n\n### Conditional\n\nUse the conditional module to create [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html). This module implements TypeScript's structural equivalence checks to enable TypeBox types to be conditionally inferred at runtime. This module also provides the [Extract](https://www.typescriptlang.org/docs/handbook/utility-types.html#extracttype-union) and [Exclude](https://www.typescriptlang.org/docs/handbook/utility-types.html#excludeuniontype-excludedmembers) utility types which are expressed as conditional types in TypeScript. \n\nThe conditional module is provided as an optional import.\n\n```typescript\nimport { Conditional } from '@sinclair/typebox/conditional'\n```\nThe following table shows the TypeBox mappings between TypeScript and JSON schema.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Conditional.Extends( │ type T =                    │ const T = {                    │\n│   Type.String(),               │  string extends number      │   const: false,                │\n│   Type.Number(),               │  true : false               │   type: 'boolean'              │\n│   Type.Literal(true),          │                             │ }                              │\n│   Type.Literal(false)          │                             │                                │\n│ )                              │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Conditional.Extract( │ type T = Extract<           │ const T = {                    │\n│   Type.Union([                 │   'a' | 'b' | 'c',          │   anyOf: [{                    │\n│     Type.Literal('a'),         │   'a' | 'f'                 │     const: 'a'                 │\n│     Type.Literal('b'),         │ >                           │     type: 'string'             │\n│     Type.Literal('c')          │                             │   }]                           │\n│   ]),                          │                             │ }                              │\n│   Type.Union([                 │                             │                                │\n│     Type.Literal('a'),         │                             │                                │\n│     Type.Literal('f')          │                             │                                │\n│   ])                           │                             │                                │\n│ )                              │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Conditional.Exclude( │ type T = Exclude<           │ const T = {                    │\n│   Type.Union([                 │   'a' | 'b' | 'c',          │   anyOf: [{                    │\n│     Type.Literal('a'),         │   'a'                       │     const: 'b',                │\n│     Type.Literal('b'),         │ >                           │     type: 'string'             │\n│     Type.Literal('c')          │                             │   }, {                         │\n│   ]),                          │                             │     const: 'c',                │\n│   Type.Union([                 │                             │     type: 'string'             │\n│     Type.Literal('a')          │                             │   }]                           │\n│   ])                           │                             │ }                              │\n│ )                              │                             │                                │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n<a name='types-unsafe'></a>\n\n### Unsafe\n\nUse `Type.Unsafe(...)` to create custom schemas with user defined inference rules.\n\n```typescript\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\n                                                     //   type: 'number'\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = string\n```\n\nThis function can be used to create custom schemas for validators that require specific schema representations. An example of this might be OpenAPI's `nullable` and `enum` schemas which are not provided by TypeBox. The following demonstrates using `Type.Unsafe(...)` to create these types.\n\n```typescript\nimport { Type, Static, TSchema } from '@sinclair/typebox'\n\n//--------------------------------------------------------------------------------------------\n//\n// Nullable<T>\n//\n//--------------------------------------------------------------------------------------------\n\nfunction Nullable<T extends TSchema>(schema: T) {\n  return Type.Unsafe<Static<T> | null>({ ...schema, nullable: true })\n}\n\nconst T = Nullable(Type.String())                    // const T = {\n                                                     //   type: 'string',\n                                                     //   nullable: true\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = string | null\n\n\n//--------------------------------------------------------------------------------------------\n//\n// StringEnum<string[]>\n//\n//--------------------------------------------------------------------------------------------\n\nfunction StringEnum<T extends string[]>(values: [...T]) {\n  return Type.Unsafe<T[number]>({ type: 'string', enum: values })\n}\n\nconst T = StringEnum(['A', 'B', 'C'])                // const T = {\n                                                     //   enum: ['A', 'B', 'C']\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = 'A' | 'B' | 'C'\n```\n\n<a name='types-guards'></a>\n\n### Guards\n\nUse the guard module to test if values are TypeBox types.\n\n```typescript\nimport { TypeGuard } from '@sinclair/typebox/guard'\n\nconst T = Type.String()\n\nif(TypeGuard.TString(T)) {\n    \n  // T is TString\n}\n```\n\n<a name='types-strict'></a>\n\n### Strict\n\nTypeBox schemas contain the `Kind` and `Modifier` symbol properties. These properties are provided to enable runtime type reflection on schemas, as well as helping TypeBox internally compose types. These properties are not strictly valid JSON schema; so in some cases it may be desirable to omit them. TypeBox provides a `Type.Strict()` function that will omit these properties if necessary.\n\n```typescript\nconst T = Type.Object({                              // const T = {\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\n})                                                   //   type: 'object',\n                                                     //   properties: {\n                                                     //     name: {\n                                                     //       [Kind]: 'String',\n                                                     //       type: 'string',\n                                                     //       [Modifier]: 'Optional'\n                                                     //     }\n                                                     //   }\n                                                     // }\n\nconst U = Type.Strict(T)                             // const U = {\n                                                     //   type: 'object', \n                                                     //   properties: { \n                                                     //     name: { \n                                                     //       type: 'string' \n                                                     //     } \n                                                     //   } \n                                                     // }\n```\n\n<a name='values'></a>\n\n## Values\n\nTypeBox includes an optional values module that can be used to perform common operations on JavaScript values. This module enables one to create, check and cast values from types. It also provides functionality to check equality, clone and diff and patch JavaScript values. The value module is provided as an optional import.\n\n```typescript\nimport { Value } from '@sinclair/typebox/value'\n```\n\n<a name='values-create'></a>\n\n### Create\n\nUse the Create function to create a value from a TypeBox type. TypeBox will use default values if specified.\n\n```typescript\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\n\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\n```\n\n<a name='values-clone'></a>\n\n### Clone\n\nUse the Clone function to deeply clone a value\n\n```typescript\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\n```\n\n<a name='values-check'></a>\n\n### Check\n\nUse the Check function to type check a value\n\n```typescript\nconst T = Type.Object({ x: Type.Number() })\n\nconst R = Value.Check(T, { x: 1 })                   // const R = true\n```\n\n<a name='values-cast'></a>\n\n### Cast\n\nUse the Cast function to cast a value into a type. The cast function will retain as much information as possible from the original value.\n\n```typescript\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\n\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\n\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\n\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\n```\n\n<a name='values-equal'></a>\n\n### Equal\n\nUse the Equal function to deeply check for value equality.\n\n```typescript\nconst R = Value.Equal(                               // const R = true\n  { x: 1, y: 2, z: 3 },\n  { x: 1, y: 2, z: 3 }\n)\n```\n\n<a name='values-diff'></a>\n\n### Diff\n\nUse the Diff function to produce a sequence of edits to transform one value into another.\n\n```typescript\nconst E = Value.Diff<any>(                          // const E = [\n  { x: 1, y: 2, z: 3 },                             //   { type: 'update', path: '/y', value: 4 },\n  { y: 4, z: 5, w: 6 }                              //   { type: 'update', path: '/z', value: 5 },\n)                                                   //   { type: 'insert', path: '/w', value: 6 },\n                                                    //   { type: 'delete', path: '/x' }\n                                                    // ]\n```\n\n<a name='values-patch'></a>\n\n### Patch\n\nUse the Patch function to apply edits\n\n```typescript\nconst A = { x: 1, y: 2 }\n\nconst B = { x: 3 }\n\nconst E = Value.Diff<any>(A, B)                      // const E = [\n                                                     //   { type: 'update', path: '/x', value: 3 },\n                                                     //   { type: 'delete', path: '/y' }\n                                                     // ]\n\nconst C = Value.Patch<any>(A, E)                     // const C = { x: 3 }\n```\n\n\n<a name='values-errors'></a>\n\n### Errors\n\nUse the Errors function enumerate validation errors.\n\n```typescript\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\n\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/x',\n                                                     //   value: '42',\n                                                     //   message: 'Expected number'\n                                                     // }, {\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/y',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }]\n```\n\n<a name='values-pointer'></a>\n\n### Pointer\n\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\n\n```typescript\nimport { ValuePointer } from '@sinclair/typebox/value'\n\nconst A = { x: 0, y: 0, z: 0 }\n\nValuePointer.Set(A, '/x', 1)                         // const A = { x: 1, y: 0, z: 0 }\nValuePointer.Set(A, '/y', 1)                         // const A = { x: 1, y: 1, z: 0 }\nValuePointer.Set(A, '/z', 1)                         // const A = { x: 1, y: 1, z: 1 }\n```\n<a name='typecheck'></a>\n\n## TypeCheck\n\nTypeBox is written to target JSON Schema Draft 6 and can be used with any Draft 6 compliant validator. TypeBox is developed and tested against Ajv and can be used in any application already making use of this validator. Additionally, TypeBox also provides an optional type compiler that can be used to attain improved compilation and validation performance for certain application types.\n\n<a name='typecheck-ajv'></a>\n\n### Ajv\n\nThe following example shows setting up Ajv to work with TypeBox. \n\n```bash\n$ npm install ajv ajv-formats --save\n```\n\n```typescript\nimport { Type }   from '@sinclair/typebox'\nimport addFormats from 'ajv-formats'\nimport Ajv        from 'ajv'\n\n//--------------------------------------------------------------------------------------------\n//\n// Setup Ajv validator with the following options and formats\n//\n//--------------------------------------------------------------------------------------------\n\nconst ajv = addFormats(new Ajv({}), [\n  'date-time', \n  'time', \n  'date', \n  'email',  \n  'hostname', \n  'ipv4', \n  'ipv6', \n  'uri', \n  'uri-reference', \n  'uuid',\n  'uri-template', \n  'json-pointer', \n  'relative-json-pointer', \n  'regex'\n])\n\n//--------------------------------------------------------------------------------------------\n//\n// Create a TypeBox type\n//\n//--------------------------------------------------------------------------------------------\n\nconst T = Type.Object({\n  x: Type.Number(),\n  y: Type.Number(),\n  z: Type.Number()\n})\n\n//--------------------------------------------------------------------------------------------\n//\n// Validate Data\n//\n//--------------------------------------------------------------------------------------------\n\nconst R = ajv.validate(T, { x: 1, y: 2, z: 3 })      // const R = true\n```\n\n<a name='typecheck-compiler'></a>\n\n### Compiler\n\nTypeBox provides an optional high performance just-in-time (JIT) compiler and type checker that can be used in applications that require extremely fast validation. Note that this compiler is optimized for TypeBox types only where the schematics are known in advance. If defining custom types with `Type.Unsafe<T>` please consider Ajv.\n\nThe compiler module is provided as an optional import.\n\n```typescript\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\n```\n\nUse the `Compile(...)` function to compile a type.\n\n```typescript\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\n  x: Type.Number(),                                  //     x: TNumber;\n  y: Type.Number(),                                  //     y: TNumber;\n  z: Type.Number()                                   //     z: TNumber;\n}))                                                  // }>>\n\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\n```\n\nValidation errors can be read with the `Errors(...)` function.\n\n```typescript\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\n  x: Type.Number(),                                  //     x: TNumber;\n  y: Type.Number(),                                  //     y: TNumber;\n  z: Type.Number()                                   //     z: TNumber;\n}))                                                  // }>>\n\nconst value = { }\n\nconst errors = [...C.Errors(value)]                  // const errors = [{\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/x',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }, {\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/y',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }, {\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/z',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }]\n```\n\nCompiled routines can be inspected with the `.Code()` function.\n\n```typescript\nconst C = TypeCompiler.Compile(Type.String())        // const C: TypeCheck<TString>\n\nconsole.log(C.Code())                                // return function check(value) {\n                                                     //   return (\n                                                     //     (typeof value === 'string')\n                                                     //   )\n                                                     // }\n```\n\n<a name='typecheck-formats'></a>\n\n### Formats\n\nUse the format module to create user defined string formats. The format module is used by the Value and TypeCompiler modules only. If using Ajv, please refer to the official Ajv format documentation located [here](https://ajv.js.org/guide/formats.html).\n\nThe format module is an optional import.\n\n```typescript\nimport { Format } from '@sinclair/typebox/format'\n```\n\nThe following creates a `palindrome` string format.\n\n```typescript\nFormat.Set('palindrome', value => value === value.split('').reverse().join(''))\n```\n\nOnce set, this format can then be used by the TypeCompiler and Value modules.\n\n```typescript\nconst T = Type.String({ format: 'palindrome' })\n\nconst A = TypeCompiler.Compile(T).Check('engine')    // const A = false\n\nconst B = Value.Check(T, 'kayak')                    // const B = true\n```\n\n<a name='benchmark'></a>\n\n## Benchmark\n\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.11.0. \n\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\n\n<a name='benchmark-compile'></a>\n\n### Compile\n\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/compile.ts).\n\n```typescript\n┌──────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\n│     (index)      │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\n├──────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\n│           Number │    2000    │ '    428 ms' │ '     12 ms' │ '   35.67 x' │\n│           String │    2000    │ '    337 ms' │ '     12 ms' │ '   28.08 x' │\n│          Boolean │    2000    │ '    317 ms' │ '     11 ms' │ '   28.82 x' │\n│             Null │    2000    │ '    274 ms' │ '     10 ms' │ '   27.40 x' │\n│            RegEx │    2000    │ '    500 ms' │ '     18 ms' │ '   27.78 x' │\n│          ObjectA │    2000    │ '   2717 ms' │ '     49 ms' │ '   55.45 x' │\n│          ObjectB │    2000    │ '   2854 ms' │ '     37 ms' │ '   77.14 x' │\n│            Tuple │    2000    │ '   1224 ms' │ '     21 ms' │ '   58.29 x' │\n│            Union │    2000    │ '   1266 ms' │ '     23 ms' │ '   55.04 x' │\n│          Vector4 │    2000    │ '   1513 ms' │ '     19 ms' │ '   79.63 x' │\n│          Matrix4 │    2000    │ '    841 ms' │ '     12 ms' │ '   70.08 x' │\n│   Literal_String │    2000    │ '    327 ms' │ '      8 ms' │ '   40.88 x' │\n│   Literal_Number │    2000    │ '    358 ms' │ '      6 ms' │ '   59.67 x' │\n│  Literal_Boolean │    2000    │ '    355 ms' │ '      5 ms' │ '   71.00 x' │\n│     Array_Number │    2000    │ '    685 ms' │ '      7 ms' │ '   97.86 x' │\n│     Array_String │    2000    │ '    716 ms' │ '     11 ms' │ '   65.09 x' │\n│    Array_Boolean │    2000    │ '    732 ms' │ '      6 ms' │ '  122.00 x' │\n│    Array_ObjectA │    2000    │ '   3503 ms' │ '     34 ms' │ '  103.03 x' │\n│    Array_ObjectB │    2000    │ '   3626 ms' │ '     38 ms' │ '   95.42 x' │\n│      Array_Tuple │    2000    │ '   2095 ms' │ '     21 ms' │ '   99.76 x' │\n│      Array_Union │    2000    │ '   1577 ms' │ '     22 ms' │ '   71.68 x' │\n│    Array_Vector4 │    2000    │ '   2172 ms' │ '     17 ms' │ '  127.76 x' │\n│    Array_Matrix4 │    2000    │ '   1468 ms' │ '     19 ms' │ '   77.26 x' │\n└──────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\n```\n\n<a name='benchmark-validate'></a>\n\n### Validate\n\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/check.ts).\n\n```typescript\n┌──────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\n│     (index)      │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\n├──────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\n│           Number │  1000000   │ '     24 ms' │ '      9 ms' │ '      6 ms' │ '    1.50 x' │\n│           String │  1000000   │ '     23 ms' │ '     19 ms' │ '     12 ms' │ '    1.58 x' │\n│          Boolean │  1000000   │ '     24 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\n│             Null │  1000000   │ '     23 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\n│            RegEx │  1000000   │ '    164 ms' │ '     46 ms' │ '     38 ms' │ '    1.21 x' │\n│          ObjectA │  1000000   │ '    548 ms' │ '     36 ms' │ '     22 ms' │ '    1.64 x' │\n│          ObjectB │  1000000   │ '   1118 ms' │ '     51 ms' │ '     38 ms' │ '    1.34 x' │\n│            Tuple │  1000000   │ '    136 ms' │ '     25 ms' │ '     14 ms' │ '    1.79 x' │\n│            Union │  1000000   │ '    338 ms' │ '     27 ms' │ '     16 ms' │ '    1.69 x' │\n│        Recursive │  1000000   │ '   3251 ms' │ '    416 ms' │ '     98 ms' │ '    4.24 x' │\n│          Vector4 │  1000000   │ '    146 ms' │ '     23 ms' │ '     12 ms' │ '    1.92 x' │\n│          Matrix4 │  1000000   │ '    584 ms' │ '     40 ms' │ '     25 ms' │ '    1.60 x' │\n│   Literal_String │  1000000   │ '     46 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\n│   Literal_Number │  1000000   │ '     46 ms' │ '     20 ms' │ '     10 ms' │ '    2.00 x' │\n│  Literal_Boolean │  1000000   │ '     47 ms' │ '     21 ms' │ '     10 ms' │ '    2.10 x' │\n│     Array_Number │  1000000   │ '    456 ms' │ '     31 ms' │ '     19 ms' │ '    1.63 x' │\n│     Array_String │  1000000   │ '    489 ms' │ '     40 ms' │ '     25 ms' │ '    1.60 x' │\n│    Array_Boolean │  1000000   │ '    458 ms' │ '     35 ms' │ '     27 ms' │ '    1.30 x' │\n│    Array_ObjectA │  1000000   │ '  13559 ms' │ '   2568 ms' │ '   1564 ms' │ '    1.64 x' │\n│    Array_ObjectB │  1000000   │ '  15863 ms' │ '   2744 ms' │ '   2060 ms' │ '    1.33 x' │\n│      Array_Tuple │  1000000   │ '   1694 ms' │ '     96 ms' │ '     63 ms' │ '    1.52 x' │\n│      Array_Union │  1000000   │ '   4736 ms' │ '    229 ms' │ '     86 ms' │ '    2.66 x' │\n│  Array_Recursive │  1000000   │ '  53804 ms' │ '   6744 ms' │ '   1167 ms' │ '    5.78 x' │\n│    Array_Vector4 │  1000000   │ '   2244 ms' │ '     99 ms' │ '     46 ms' │ '    2.15 x' │\n│    Array_Matrix4 │  1000000   │ '  11966 ms' │ '    378 ms' │ '    229 ms' │ '    1.65 x' │\n└──────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\n```\n\n<a name='benchmark-compression'></a>\n\n### Compression\n\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\n\n```typescript\n┌──────────────────────┬────────────┬────────────┬─────────────┐\n│       (index)        │  Compiled  │  Minified  │ Compression │\n├──────────────────────┼────────────┼────────────┼─────────────┤\n│ typebox/compiler     │ '   51 kb' │ '   25 kb' │  '2.00 x'   │\n│ typebox/conditional  │ '   42 kb' │ '   17 kb' │  '2.46 x'   │\n│ typebox/format       │ '    0 kb' │ '    0 kb' │  '2.66 x'   │\n│ typebox/guard        │ '   21 kb' │ '   10 kb' │  '2.08 x'   │\n│ typebox/value        │ '   74 kb' │ '   34 kb' │  '2.16 x'   │\n│ typebox              │ '   11 kb' │ '    6 kb' │  '1.91 x'   │\n└──────────────────────┴────────────┴────────────┴─────────────┘\n```\n\n<a name='contribute'></a>\n\n## Contribute\n\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\n",
    "licenseText": "TypeBox: JSON Schema Type Builder with Static Type Resolution for TypeScript \n\nThe MIT License (MIT)\n\nCopyright (c) 2022 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@sinclair/typebox/-/typebox-0.24.51.tgz#645f33fe4e02defe26f2f5c0410e1c094eac7f5f",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@sinclair/typebox/-/typebox-0.24.51.tgz",
    "hash": "645f33fe4e02defe26f2f5c0410e1c094eac7f5f",
    "integrity": "sha512-1P1OROm/rdubP5aFDSZQILU0vrLCJ4fvHt6EoqHEM+2D/G5MK3bIaymUKLit8Js9gbns5UyJnkP/TZROLw4tUA==",
    "registry": "npm",
    "packageName": "@sinclair/typebox",
    "cacheIntegrity": "sha512-1P1OROm/rdubP5aFDSZQILU0vrLCJ4fvHt6EoqHEM+2D/G5MK3bIaymUKLit8Js9gbns5UyJnkP/TZROLw4tUA== sha1-ZF8z/k4C3v4m8vXAQQ4cCU6sf18="
  },
  "registry": "npm",
  "hash": "645f33fe4e02defe26f2f5c0410e1c094eac7f5f"
}