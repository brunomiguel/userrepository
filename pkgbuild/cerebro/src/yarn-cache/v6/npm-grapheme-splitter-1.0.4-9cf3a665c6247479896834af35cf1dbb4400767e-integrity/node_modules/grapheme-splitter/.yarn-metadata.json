{
  "manifest": {
    "name": "grapheme-splitter",
    "version": "1.0.4",
    "description": "A JavaScript library that breaks strings into their individual user-perceived characters. It supports emojis!",
    "homepage": "https://github.com/orling/grapheme-splitter",
    "author": {
      "name": "Orlin Georgiev"
    },
    "contributors": [
      {
        "name": "Lucas Tadeu Teixeira",
        "email": "lucas@fastmail.nl",
        "url": "https://lucas.is"
      }
    ],
    "main": "index.js",
    "license": "MIT",
    "keywords": [
      "utf-8",
      "strings",
      "emoji",
      "split"
    ],
    "scripts": {
      "test": "tape tests/grapheme_splitter_tests.js"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/orling/grapheme-splitter.git"
    },
    "bugs": {
      "url": "https://github.com/orling/grapheme-splitter/issues"
    },
    "dependencies": {},
    "devDependencies": {
      "tape": "^4.6.3"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-grapheme-splitter-1.0.4-9cf3a665c6247479896834af35cf1dbb4400767e-integrity/node_modules/grapheme-splitter/package.json",
    "readmeFilename": "README.md",
    "readme": "# Background\n\nIn JavaScript there is not always a one-to-one relationship between string characters and what a user would call a separate visual \"letter\". Some symbols are represented by several characters. This can cause issues when splitting strings and inadvertently cutting a multi-char letter in half, or when you need the actual number of letters in a string.\n\nFor example, emoji characters like \"🌷\",\"🎁\",\"💩\",\"😜\" and \"👍\" are represented by two JavaScript characters each (high surrogate and low surrogate). That is, \n\n```javascript\n\"🌷\".length == 2\n```\nThe combined emoji are even longer:\n```javascript\n\"🏳️‍🌈\".length == 6\n```\n\nWhat's more, some languages often include combining marks - characters that are used to modify the letters before them. Common examples are the German letter ü and the Spanish letter ñ. Sometimes they can be represented alternatively both as a single character and as a letter + combining mark, with both forms equally valid:\n    \n```javascript\nvar two = \"ñ\"; // unnormalized two-char n+◌̃  , i.e. \"\\u006E\\u0303\";\nvar one = \"ñ\"; // normalized single-char, i.e. \"\\u00F1\"\nconsole.log(one!=two); // prints 'true'\n```\n\nUnicode normalization, as performed by the popular punycode.js library or ECMAScript 6's String.normalize, can **sometimes** fix those differences and turn two-char sequences into single characters. But it is **not** enough in all cases. Some languages like Hindi make extensive use of combining marks on their letters, that have no dedicated single-codepoint Unicode sequences, due to the sheer number of possible combinations.\nFor example, the Hindi word \"अनुच्छेद\" is comprised of 5 letters and 3 combining marks:\n\nअ + न + ु + च + ् + छ + े + द\n\nwhich is in fact just 5 user-perceived letters:\n\nअ + नु + च् + छे + द\n\nand which Unicode normalization would not combine properly.\nThere are also the unusual letter+combining mark combinations which have no dedicated Unicode codepoint. The string Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘ obviously has 5 separate letters, but is in fact comprised of 58 JavaScript characters, most of which are combining marks.\n\nEnter the grapheme-splitter.js library. It can be used to properly split JavaScript strings into what a human user would call separate letters (or \"extended grapheme clusters\" in Unicode terminology), no matter what their internal representation is. It is an implementation on the [Default Grapheme Cluster Boundary](http://unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table) of [UAX #29](http://www.unicode.org/reports/tr29/). \n\n# Installation\n\nYou can use the index.js file directly as-is. Or you you can install `grapheme-splitter` to your project using the NPM command below:\n\n```\n$ npm install --save grapheme-splitter\n```\n\n# Tests\n\nTo run the tests on `grapheme-splitter`, use the command below:\n\n```\n$ npm test\n```\n\n# Usage\n\nJust initialize and use:\n\n```javascript\nvar splitter = new GraphemeSplitter();\n\n// split the string to an array of grapheme clusters (one string each)\nvar graphemes = splitter.splitGraphemes(string);\n\n// iterate the string to an iterable iterator of grapheme clusters (one string each)\nvar graphemes = splitter.iterateGraphemes(string);\n\n// or do this if you just need their number\nvar graphemeCount = splitter.countGraphemes(string);\n```\n\n# Examples\n\n```javascript\nvar splitter = new GraphemeSplitter();\n\n// plain latin alphabet - nothing spectacular\nsplitter.splitGraphemes(\"abcd\"); // returns [\"a\", \"b\", \"c\", \"d\"]\n\n// two-char emojis and six-char combined emoji\nsplitter.splitGraphemes(\"🌷🎁💩😜👍🏳️‍🌈\"); // returns [\"🌷\",\"🎁\",\"💩\",\"😜\",\"👍\",\"🏳️‍🌈\"]\n\n// diacritics as combining marks, 10 JavaScript chars\nsplitter.splitGraphemes(\"Ĺo͂řȩm̅\"); // returns [\"Ĺ\",\"o͂\",\"ř\",\"ȩ\",\"m̅\"]\n\n// individual Korean characters (Jamo), 4 JavaScript chars\nsplitter.splitGraphemes(\"뎌쉐\"); // returns [\"뎌\",\"쉐\"]\n\n// Hindi text with combining marks, 8 JavaScript chars\nsplitter.splitGraphemes(\"अनुच्छेद\"); // returns [\"अ\",\"नु\",\"च्\",\"छे\",\"द\"]\n\n// demonic multiple combining marks, 75 JavaScript chars\nsplitter.splitGraphemes(\"Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞\"); // returns [\"Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍\",\"A̴̵̜̰͔ͫ͗͢\",\"L̠ͨͧͩ͘\",\"G̴̻͈͍͔̹̑͗̎̅͛́\",\"Ǫ̵̹̻̝̳͂̌̌͘\",\"!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞\"]\n```\n\n# TypeScript\n\nGrapheme splitter includes TypeScript declarations.\n\n```typescript\nimport GraphemeSplitter = require('grapheme-splitter')\n\nconst splitter = new GraphemeSplitter()\n\nconst split: string[] = splitter.splitGraphemes('Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞')\n```\n\n# Acknowledgements\n\nThis library is heavily influenced by Devon Govett's excellent grapheme-breaker CoffeeScript library at https://github.com/devongovett/grapheme-breaker with an emphasis on ease of integration and pure JavaScript implementation.\n\n\n\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2015 Orlin Georgiev\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/grapheme-splitter/-/grapheme-splitter-1.0.4.tgz#9cf3a665c6247479896834af35cf1dbb4400767e",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/grapheme-splitter/-/grapheme-splitter-1.0.4.tgz",
    "hash": "9cf3a665c6247479896834af35cf1dbb4400767e",
    "integrity": "sha512-bzh50DW9kTPM00T8y4o8vQg89Di9oLJVLW/KaOGIXJWP/iqCN6WKYkbNOF04vFLJhwcpYUh9ydh/+5vpOqV4YQ==",
    "registry": "npm",
    "packageName": "grapheme-splitter",
    "cacheIntegrity": "sha512-bzh50DW9kTPM00T8y4o8vQg89Di9oLJVLW/KaOGIXJWP/iqCN6WKYkbNOF04vFLJhwcpYUh9ydh/+5vpOqV4YQ== sha1-nPOmZcYkdHmJaDSvNc8du0QAdn4="
  },
  "registry": "npm",
  "hash": "9cf3a665c6247479896834af35cf1dbb4400767e"
}