{
  "manifest": {
    "name": "send-intent",
    "version": "3.0.11",
    "description": "Plugin for Capacitor to receive send intents in Ionic",
    "main": "dist/esm/index.js",
    "types": "dist/esm/index.d.ts",
    "scripts": {
      "build": "npm run clean && tsc",
      "clean": "rimraf ./dist",
      "watch": "tsc --watch",
      "prepare": "npm run build",
      "prepublishOnly": "npm run build"
    },
    "author": {
      "name": "Carsten Klaffke"
    },
    "license": "MIT",
    "dependencies": {
      "-": "0.0.1",
      "@capacitor/cli": ">= 3 < 4",
      "@capacitor/core": ">= 3 < 4"
    },
    "devDependencies": {
      "@capacitor/android": ">= 3 < 4",
      "@capacitor/ios": ">= 3 < 4",
      "rimraf": "^3.0.2",
      "typescript": "^4.4.2"
    },
    "files": [
      "dist/",
      "ios/",
      "android/",
      "SendIntent.podspec"
    ],
    "keywords": [
      "capacitor",
      "plugin",
      "native"
    ],
    "capacitor": {
      "ios": {
        "src": "ios"
      },
      "android": {
        "src": "android"
      }
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/carsten-klaffke/send-intent.git"
    },
    "bugs": {
      "url": "https://github.com/carsten-klaffke/send-intent.git/issues"
    },
    "homepage": "https://carsten-klaffke.de/",
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-send-intent-3.0.11-85bf84b57e147a79a24429f8e51229339da36a78-integrity/node_modules/send-intent/package.json",
    "readmeFilename": "README.md",
    "readme": "# Send-Intent\n\nThis is a small Capacitor plugin meant to be used in Ionic applications for checking if your App was targeted as a share goal. It supports both Android and iOS. So far, it checks and returns \"SEND\"-intents of mimeType \"text/plain\", \"image\" or \"application/octet-stream\" (files).\n\nCheck out my app [mindlib - your personal mind library](https://play.google.com/store/apps/details?id=de.mindlib) to see it in action.\n\n## Projects below Capacitor 3\n\nFor projects below Capacitor 3 please use  \"send-intent\": \"1.1.7\".\n\n## Installation\n\n```\nnpm install send-intent\nnpx cap sync\n```\n\n## Usage\n\nImport & Sample call\n\nShared files will be received as URI-String. You can use Capacitor's [Filesystem](https://capacitorjs.com/docs/apis/filesystem) plugin to get the files content. \nThe \"url\"-property of the SendIntent result is also used for web urls, e.g. when sharing a website via browser, so it is not necessarily a file path. Make sure to handle this\neither through checking the \"type\"-property or by error handling.\n\n```js\nimport {SendIntent} from \"send-intent\";\n\nSendIntent.checkSendIntentReceived().then((result: any) => {\n    if (result) {\n        console.log('SendIntent received');\n        console.log(JSON.stringify(result));\n    }\n    if (result.url) {\n        let resultUrl = decodeURIComponent(result.url);\n        Filesystem.readFile({path: resultUrl})\n        .then((content) => {\n            console.log(content.data);\n        })\n        .catch((err) => console.error(err));\n    }\n}).catch(err => console.error(err));\n```\n\n## **Android**\n\nConfigure AndroidManifest.xml\n\n```xml\n<activity\n        android:name=\".sendIntent.SendIntentActivity\"\n        android:label=\"@string/app_name\"\n        android:exported=\"true\"\n        android:theme=\"@style/AppTheme.NoActionBar\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.SEND\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <data android:mimeType=\"text/plain\" />\n        <data android:mimeType=\"image/*\" />\n        <data android:mimeType=\"application/*\" />\n        <data android:mimeType=\"video/*\" />\n    </intent-filter>\n</activity>\n\n```\n\nOn Android, I strongly recommend closing the send-intent-activity after you have processed the send-intent in your app. Not doing \nthis can lead to app state issues (because you have two instances running) or trigger the same intent again if your app \nreloads from idle mode. You can close the send-intent-activity by calling the \"finish\"-method:\n\n```js\nSendIntent.finish();\n```\n\n## **iOS**\n\nCreate a \"Share Extension\" ([Creating an App extension](https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionCreation.html#//apple_ref/doc/uid/TP40014214-CH5-SW1))\n\nSet the activation rules in the extensions Info.plist, so that your app will be displayed as share option.\n\n```\n...\n    <key>NSExtensionActivationRule</key>\n    <dict>\n        <key>NSExtensionActivationSupportsFileWithMaxCount</key>\n        <integer>5</integer>\n        <key>NSExtensionActivationSupportsImageWithMaxCount</key>\n        <integer>5</integer>\n        <key>NSExtensionActivationSupportsMovieWithMaxCount</key>\n        <integer>5</integer>\n        <key>NSExtensionActivationSupportsText</key>\n        <true/>\n        <key>NSExtensionActivationSupportsWebPageWithMaxCount</key>\n        <integer>1</integer>\n        <key>NSExtensionActivationSupportsWebURLWithMaxCount</key>\n        <integer>1</integer>\n        <key>NSExtensionActivationUsesStrictMatching</key>\n        <false/>\n    </dict>\n...            \n```\n\nCode for the ShareViewController:\n\n```swift\n//\n//  ShareViewController.swift\n//  mindlib\n//\n//  Created by Carsten Klaffke on 05.07.20.\n//\n\nimport MobileCoreServices\nimport Social\nimport UIKit\n\nclass ShareItem {\n    \n    public var title: String?\n    public var type: String?\n    public var url: String?\n}\n\nclass ShareViewController: UIViewController {\n    \n    private var shareItems: [ShareItem] = []\n    \n    private func sendData() {\n        let queryItems = shareItems.map {\n            [\n                URLQueryItem(\n                    name: \"title\",\n                    value: $0.title?.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) ?? \"\"),\n                URLQueryItem(name: \"description\", value: \"\"),\n                URLQueryItem(\n                    name: \"type\",\n                    value: $0.type?.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) ?? \"\"),\n                URLQueryItem(\n                    name: \"url\",\n                    value: $0.url?.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) ?? \"\"),\n            ]\n        }.flatMap({ $0 })\n        var urlComps = URLComponents(string: \"YOUR_APP_URL_SCHEME://\")!\n        urlComps.queryItems = queryItems\n        openURL(urlComps.url!)\n        self.extensionContext!.completeRequest(returningItems: [], completionHandler: nil)\n    }\n    \n    fileprivate func createSharedFileUrl(_ url: URL?) -> String {\n        let fileManager = FileManager.default\n        \n        let copyFileUrl =\n        fileManager.containerURL(forSecurityApplicationGroupIdentifier: \"YOUR_APP_GROUP_ID\")!\n            .absoluteString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)! + \"/\" + url!\n            .lastPathComponent.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!\n        try? Data(contentsOf: url!).write(to: URL(string: copyFileUrl)!)\n        \n        return copyFileUrl\n    }\n    \n    func saveScreenshot(_ image: UIImage) -> String {\n        let fileManager = FileManager.default\n        \n        let copyFileUrl =\n        fileManager.containerURL(forSecurityApplicationGroupIdentifier: \"YOUR_APP_GROUP_ID\")!\n            .absoluteString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)!\n        + \"/screenshot.png\"\n        do {\n            try image.pngData()?.write(to: URL(string: copyFileUrl)!)\n            return copyFileUrl\n        } catch {\n            print(error.localizedDescription)\n            return \"\"\n        }\n    }\n    \n    fileprivate func handleTypeUrl(_ attachment: NSItemProvider)\n    async throws -> ShareItem\n    {\n        let results = try await attachment.loadItem(forTypeIdentifier: kUTTypeURL as String, options: nil)\n        let url = results as! URL?\n        let shareItem: ShareItem = ShareItem()\n        \n        if url!.isFileURL {\n            shareItem.title = url!.lastPathComponent\n            shareItem.type = \"application/\" + url!.pathExtension.lowercased()\n            shareItem.url = createSharedFileUrl(url)\n        } else {\n            shareItem.title = url!.absoluteString\n            shareItem.url = url!.absoluteString\n            shareItem.type = \"text/plain\"\n        }\n        \n        return shareItem\n    }\n    \n    fileprivate func handleTypeText(_ attachment: NSItemProvider)\n    async throws -> ShareItem\n    {\n        let results = try await attachment.loadItem(forTypeIdentifier: kUTTypeText as String, options: nil)\n        let shareItem: ShareItem = ShareItem()\n        let text = results as! String\n        shareItem.title = text\n        shareItem.type = \"text/plain\"\n        return shareItem\n    }\n    \n    fileprivate func handleTypeMovie(_ attachment: NSItemProvider)\n    async throws -> ShareItem\n    {\n        let results = try await attachment.loadItem(forTypeIdentifier: kUTTypeMovie as String, options: nil)\n        let shareItem: ShareItem = ShareItem()\n        \n        let url = results as! URL?\n        shareItem.title = url!.lastPathComponent\n        shareItem.type = \"video/\" + url!.pathExtension.lowercased()\n        shareItem.url = createSharedFileUrl(url)\n        return shareItem\n    }\n    \n    fileprivate func handleTypeImage(_ attachment: NSItemProvider)\n    async throws -> ShareItem\n    {\n        let data = try await attachment.loadItem(forTypeIdentifier: kUTTypeImage as String, options: nil)\n        \n        let shareItem: ShareItem = ShareItem()\n        switch data {\n        case let image as UIImage:\n            shareItem.title = \"screenshot\"\n            shareItem.type = \"image/png\"\n            shareItem.url = self.saveScreenshot(image)\n        case let url as URL:\n            shareItem.title = url.lastPathComponent\n            shareItem.type = \"image/\" + url.pathExtension.lowercased()\n            shareItem.url = self.createSharedFileUrl(url)\n        default:\n            print(\"Unexpected image data:\", type(of: data))\n        }\n        return shareItem\n    }\n    \n    override public func viewDidLoad() {\n        super.viewDidLoad()\n        \n        shareItems.removeAll()\n        \n        let extensionItem = extensionContext?.inputItems[0] as! NSExtensionItem\n        Task {\n            try await withThrowingTaskGroup(\n                of: ShareItem.self,\n                body: { taskGroup in\n                    \n                    for attachment in extensionItem.attachments! {\n                        if attachment.hasItemConformingToTypeIdentifier(kUTTypeURL as String) {\n                            taskGroup.addTask {\n                                return try await self.handleTypeUrl(attachment)\n                            }\n                        } else if attachment.hasItemConformingToTypeIdentifier(kUTTypeText as String) {\n                            taskGroup.addTask {\n                                return try await self.handleTypeText(attachment)\n                            }\n                        } else if attachment.hasItemConformingToTypeIdentifier(kUTTypeMovie as String) {\n                            taskGroup.addTask {\n                                return try await self.handleTypeMovie(attachment)\n                            }\n                        } else if attachment.hasItemConformingToTypeIdentifier(kUTTypeImage as String) {\n                            taskGroup.addTask {\n                                return try await self.handleTypeImage(attachment)\n                            }\n                        }\n                    }\n                    \n                    for try await item in taskGroup {\n                        self.shareItems.append(item)\n                    }\n                })\n            \n            self.sendData()\n            \n        }\n    }\n    \n    @objc func openURL(_ url: URL) -> Bool {\n        var responder: UIResponder? = self\n        while responder != nil {\n            if let application = responder as? UIApplication {\n                return application.perform(#selector(openURL(_:)), with: url) != nil\n            }\n            responder = responder?.next\n        }\n        return false\n    }\n    \n}\n\n```\n\nThe share extension is like a little standalone program, so to get to your app the extension has to make an openURL call. In order to make your app reachable by a URL, you have to define a URL scheme ([Register Your URL Scheme](https://developer.apple.com/documentation/uikit/inter-process_communication/allowing_apps_and_websites_to_link_to_your_content/defining_a_custom_url_scheme_for_your_app)). The code above calls a URL scheme named \"YOUR_APP_URL_SCHEME\" (first line in \"didSelectPost\"), so just replace this with your scheme.\nTo allow sharing of files between the extension and your main app, you need to [create an app group](https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_security_application-groups) which is checked for both your extension and main app. Replace \"YOUR_APP_GROUP_ID\" in \"setSharedFileUrl()\" with your app groups name.\n\nFinally, in your AppDelegate.swift, override the following function like this:\n\n```swift\nimport SendIntent\nimport Capacitor\n\n// ...\n\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    // ...\n\n    let store = ShareStore.store\n\n    // ...\n\n    func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {\n            \n            var success = true\n            if CAPBridge.handleOpenUrl(url, options) {\n                success = ApplicationDelegateProxy.shared.application(app, open: url, options: options)\n            }\n            \n            guard let components = NSURLComponents(url: url, resolvingAgainstBaseURL: true),\n                  let params = components.queryItems else {\n                      return false\n                  }\n            let titles = params.filter { $0.name == \"title\" }\n            let descriptions = params.filter { $0.name == \"description\" }\n            let types = params.filter { $0.name == \"type\" }\n            let urls = params.filter { $0.name == \"url\" }\n            \n            store.shareItems.removeAll()\n        \n            if(titles.count > 0){\n                for index in 0...titles.count-1 {\n                    var shareItem: JSObject = JSObject()\n                    shareItem[\"title\"] = titles[index].value!\n                    shareItem[\"description\"] = descriptions[index].value!\n                    shareItem[\"type\"] = types[index].value!\n                    shareItem[\"url\"] = urls[index].value!\n                    store.shareItems.append(shareItem)\n                }\n            }\n            \n            store.processed = false\n            let nc = NotificationCenter.default\n            nc.post(name: Notification.Name(\"triggerSendIntent\"), object: nil )\n            \n            return success\n        }\n\n    // ...\n\n}\n```\n\nThis is the function started when an application is open by URL.\n\nAlso, make sure you use SendIntent as a listener. Otherwise you will miss the event fired in the plugin:\n\n```js\nwindow.addEventListener(\"sendIntentReceived\", () => {\n    Plugins.SendIntent.checkSendIntentReceived().then((result: any) => {\n        if (result) {\n            // ...\n        }\n    });\n})\n```\n\n## Donation\n\nIf you want to support my work, you can donate me on Bitcoin or Stripe.\n\nbitcoin:bc1q60ntnlz4wqfup3yg3hyqmzfkuraf8clmvupqvs\n\n[Donate me a coffee on Stripe](https://buy.stripe.com/5kA9EH5SAe778VO146)\n",
    "licenseText": "MIT License\n\nCopyright (c) 2021 Carsten Klaffke\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/send-intent/-/send-intent-3.0.11.tgz#85bf84b57e147a79a24429f8e51229339da36a78",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/send-intent/-/send-intent-3.0.11.tgz",
    "hash": "85bf84b57e147a79a24429f8e51229339da36a78",
    "integrity": "sha512-v272/VBygddJdCz/Xk6o6Clh4NJMfCIzB0h8ZVqbnGvNeK1raCZ+LlXPYdkRw1zY5I0LiwEDudumWREd7AgzwA==",
    "registry": "npm",
    "packageName": "send-intent",
    "cacheIntegrity": "sha512-v272/VBygddJdCz/Xk6o6Clh4NJMfCIzB0h8ZVqbnGvNeK1raCZ+LlXPYdkRw1zY5I0LiwEDudumWREd7AgzwA== sha1-hb+EtX4UenmiRCn45RIpM52jang="
  },
  "registry": "npm",
  "hash": "85bf84b57e147a79a24429f8e51229339da36a78"
}