{"version":3,"file":"net.js","sourceRoot":"","sources":["../../../src/main/transports/net.ts"],"names":[],"mappings":"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","sourcesContent":["import { Transports } from '@sentry/node';\nimport { Event, Response, SentryRequest, SentryRequestType, Status, TransportOptions } from '@sentry/types';\nimport { logger, PromiseBuffer, SentryError, timestampWithMs } from '@sentry/utils';\nimport { net } from 'electron';\nimport { Readable, Writable } from 'stream';\nimport * as url from 'url';\nimport { createGzip } from 'zlib';\n\nimport { isAppReady } from '../backend';\n\n// Estimated maximum size for reasonable standalone event\nconst GZIP_THRESHOLD = 1024 * 32;\n\n/**\n * SentryElectronRequest\n */\nexport interface SentryElectronRequest extends Omit<SentryRequest, 'body'> {\n  body: string | Buffer;\n}\n\n/**\n * Gets a stream from a Buffer or string\n * We don't have Readable.from in earlier versions of node\n */\nfunction streamFromBody(body: Buffer | string): Readable {\n  return new Readable({\n    read() {\n      this.push(body);\n      this.push(null);\n    },\n  });\n}\n\n/** Using net module of electron */\nexport class NetTransport extends Transports.BaseTransport {\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<Response> = new PromiseBuffer(30);\n\n  /** Create a new instance and set this.agent */\n  public constructor(public options: TransportOptions) {\n    super(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async sendEvent(event: Event): Promise<Response> {\n    const envelopeHeaders = JSON.stringify({\n      event_id: event.event_id,\n      // Internal helper that uses `perf_hooks` to get clock reading\n      sent_at: new Date(timestampWithMs() * 1000).toISOString(),\n    });\n    const type = event.type === 'transaction' ? 'transaction' : 'event';\n    const itemHeaders = JSON.stringify({\n      content_type: 'application/json',\n      // Internal helper that uses `perf_hooks` to get clock reading\n      type: event.type === 'transaction' ? 'transaction' : 'event',\n    });\n\n    if (this._isRateLimited(type)) {\n      return Promise.reject(\n        new SentryError(`Transport locked till ${JSON.stringify(this._rateLimits, null, 2)} due to too many requests.`),\n      );\n    }\n\n    const eventPayload = JSON.stringify(event);\n    const bodyBuffer = Buffer.from(`${envelopeHeaders}\\n${itemHeaders}\\n${eventPayload}\\n`);\n\n    return this.sendRequest({\n      body: bodyBuffer,\n      url: this._api.getEnvelopeEndpointWithUrlEncodedAuth(),\n      type,\n    });\n  }\n\n  /**\n   * Checks if a category is rate-limited\n   */\n  public isRateLimited(category: SentryRequestType): boolean {\n    return this._isRateLimited(category);\n  }\n\n  /**\n   * Dispatches a Request to Sentry. Only handles SentryRequest\n   */\n  public async sendRequest(request: SentryElectronRequest): Promise<Response> {\n    if (!this._buffer.isReady()) {\n      return Promise.reject(new SentryError('Not adding Promise due to buffer limit reached.'));\n    }\n\n    await isAppReady();\n\n    const options = this._getRequestOptions(new url.URL(request.url));\n    options.headers = {\n      ...options.headers,\n      'Content-Type': 'application/x-sentry-envelope',\n    };\n\n    let bodyStream = streamFromBody(request.body);\n\n    if (request.body.length > GZIP_THRESHOLD) {\n      options.headers['Content-Encoding'] = 'gzip';\n      bodyStream = bodyStream.pipe(createGzip());\n    }\n\n    return this._buffer.add(\n      new Promise<Response>((resolve, reject) => {\n        const req = net.request(options as Electron.ClientRequestConstructorOptions);\n        req.on('error', reject);\n        req.on('response', (res: Electron.IncomingMessage) => {\n          res.on('error', reject);\n\n          const status = Status.fromHttpCode(res.statusCode);\n          if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\n            resolve({ status });\n          } else {\n            if (status === Status.RateLimit) {\n              let retryAfterHeader = res.headers ? res.headers['retry-after'] : '';\n              retryAfterHeader = (Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader) as string;\n\n              let rlHeader = res.headers ? res.headers['x-sentry-rate-limits'] : '';\n              rlHeader = (Array.isArray(rlHeader) ? rlHeader[0] : rlHeader) as string;\n\n              const headers = {\n                'x-sentry-rate-limits': rlHeader,\n                'retry-after': retryAfterHeader,\n              };\n\n              const limited = this._handleRateLimit(headers);\n              if (limited) logger.warn(`Too many requests, backing off until: ${this._disabledUntil(request.type)}`);\n            }\n\n            // tslint:disable:no-unsafe-any\n            if (res.headers && res.headers['x-sentry-error']) {\n              let reason: string | string[] = res.headers['x-sentry-error'];\n              if (Array.isArray(reason)) {\n                reason = reason.join(', ');\n              }\n              // tslint:enable:no-unsafe-any\n              reject(new SentryError(`HTTP Error (${res.statusCode}): ${reason}`));\n            } else {\n              reject(new SentryError(`HTTP Error (${res.statusCode})`));\n            }\n          }\n          // force the socket to drain\n          res.on('data', () => {\n            // Drain\n          });\n          res.on('end', () => {\n            // Drain\n          });\n        });\n\n        // The docs say that ClientRequest is Writable but the types don't match exactly\n        bodyStream.pipe((req as any) as Writable);\n      }),\n    );\n  }\n}\n"]}