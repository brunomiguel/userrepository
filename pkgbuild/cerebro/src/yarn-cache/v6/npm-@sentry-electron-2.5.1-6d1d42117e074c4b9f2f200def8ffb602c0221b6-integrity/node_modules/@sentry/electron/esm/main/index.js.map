{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/main/index.ts"],"names":[],"mappings":";AAAA,OAAO,EAOL,QAAQ,EAGR,MAAM,GAGP,MAAM,eAAe,CAAC;AAEvB,OAAO,EACL,uBAAuB,EACvB,aAAa,EACb,gBAAgB,EAChB,YAAY,EACZ,cAAc,EACd,cAAc,EACd,iBAAiB,EACjB,aAAa,EACb,GAAG,EACH,KAAK,EACL,UAAU,EACV,QAAQ,EACR,SAAS,EACT,MAAM,EACN,OAAO,EACP,OAAO,EACP,SAAS,GACV,MAAM,cAAc,CAAC;AAEtB,OAAO,EAAE,aAAa,EAAE,WAAW,EAAE,MAAM,cAAc,CAAC;AAC1D,OAAO,EAAE,aAAa,EAAE,MAAM,iBAAiB,CAAC;AAChD,OAAO,EAAE,mBAAmB,EAAE,MAAM,cAAc,CAAC;AAInD,OAAO,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AACtC,OAAO,EAAE,QAAQ,EAAE,mBAAmB,EAAE,MAAM,gBAAgB,CAAC;AAC/D,OAAO,EAAE,YAAY,EAAE,MAAM,kBAAkB,CAAC;AAChD,OAAO,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AACtC,OAAO,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AACxC,OAAO,EAAE,YAAY,EAAE,MAAM,kBAAkB,CAAC;AAChD,OAAO,EAAE,YAAY,IAAI,gBAAgB,EAAE,MAAM,cAAc,CAAC;AAEhE,MAAM,CAAC,IAAM,oBAAoB,GAAG,EAAE,QAAQ,UAAA,EAAE,mBAAmB,qBAAA,EAAE,CAAC;AAEtE;;;GAGG;AACH,MAAM,UAAU,IAAI,CAAC,OAAwB;IAC3C,IAAM,oBAAoB,GAAG,mBAAmB,CAAC,MAAM,CAAC,UAAA,WAAW,IAAI,OAAA,WAAW,CAAC,IAAI,KAAK,qBAAqB,EAA1C,CAA0C,CAAC,CAAC;IACnH,IAAI,OAAO,CAAC,mBAAmB,KAAK,SAAS,EAAE;QAC7C,OAAO,CAAC,mBAAmB,0CACtB,oBAAoB;YACvB,6DAA6D;YAC7D,IAAI,mBAAmB,CAAC,EAAE,YAAY,EAAE,OAAO,CAAC,YAAY,EAAE,CAAC;YAC/D,IAAI,QAAQ,EAAE;UACf,CAAC;KACH;IACD,WAAW,CAAC,UAAU,aACpB,SAAS,EAAE,YAAY,IACpB,OAAO,EACV,CAAC;AACL,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,gBAAgB;IAC9B,OAAO;AACT,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,eAAe,CAAC,IAAY,EAAE,KAAiB;IAAjB,sBAAA,EAAA,UAAiB;IAC7D,aAAa,CAAC,iBAAiB,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;AAChD,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAgB,KAAK,CAAC,OAAgB;;;;YACpC,MAAM,GAAG,aAAa,EAAE,CAAC,SAAS,EAAc,CAAC;YACvD,IAAI,MAAM,EAAE;gBACV,sBAAO,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,EAAC;aAC9B;YACD,sBAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,EAAC;;;CAC9B;AAED;;;;;GAKG;AACH,MAAM,UAAgB,KAAK,CAAC,OAAgB;;;;YACpC,MAAM,GAAG,aAAa,EAAE,CAAC,SAAS,EAAc,CAAC;YACvD,IAAI,MAAM,EAAE;gBACV,sBAAO,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,EAAC;aAC9B;YACD,sBAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,EAAC;;;CAC9B","sourcesContent":["export {\n  Breadcrumb,\n  Request,\n  SdkInfo,\n  Event,\n  Exception,\n  Response,\n  Severity,\n  StackFrame,\n  Stacktrace,\n  Status,\n  Thread,\n  User,\n} from '@sentry/types';\n\nexport {\n  addGlobalEventProcessor,\n  addBreadcrumb,\n  captureException,\n  captureEvent,\n  captureMessage,\n  configureScope,\n  getHubFromCarrier,\n  getCurrentHub,\n  Hub,\n  Scope,\n  setContext,\n  setExtra,\n  setExtras,\n  setTag,\n  setTags,\n  setUser,\n  withScope,\n} from '@sentry/core';\n\nimport { getCurrentHub, initAndBind } from '@sentry/core';\nimport { _callOnClient } from '@sentry/minimal';\nimport { defaultIntegrations } from '@sentry/node';\nimport { Event } from '@sentry/types';\n\nimport { ElectronOptions } from '../common';\nimport { MainClient } from './client';\nimport { Electron, OnUncaughtException } from './integrations';\nimport { NetTransport } from './transports/net';\nexport { MainClient } from './client';\nexport { MainBackend } from './backend';\nexport { NetTransport } from './transports/net';\nexport { Integrations as NodeIntegrations } from '@sentry/node';\n\nexport const ElectronIntegrations = { Electron, OnUncaughtException };\n\n/**\n * Init call to node, if no transport is set, we use net of electron\n * @param options ElectronOptions\n */\nexport function init(options: ElectronOptions): void {\n  const electronIntegrations = defaultIntegrations.filter(integration => integration.name !== 'OnUncaughtException');\n  if (options.defaultIntegrations === undefined) {\n    options.defaultIntegrations = [\n      ...electronIntegrations,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      new OnUncaughtException({ onFatalError: options.onFatalError }),\n      new Electron(),\n    ];\n  }\n  initAndBind(MainClient, {\n    transport: NetTransport,\n    ...options,\n  });\n}\n\n/**\n * This function does nothing, call it in the renderer\n */\nexport function showReportDialog(): void {\n  // noop\n}\n\n/**\n * Uploads a native crash dump (Minidump) to Sentry.\n *\n * @param path The relative or absolute path to the minidump.\n * @param event Optional event payload to attach to the minidump.\n */\nexport function captureMinidump(path: string, event: Event = {}): void {\n  _callOnClient('captureMinidump', path, event);\n}\n\n/**\n * A promise that resolves when all current events have been sent.\n * If you provide a timeout and the queue takes longer to drain the promise returns false.\n *\n * @param timeout Maximum time in ms the client should wait.\n */\nexport async function flush(timeout?: number): Promise<boolean> {\n  const client = getCurrentHub().getClient<MainClient>();\n  if (client) {\n    return client.flush(timeout);\n  }\n  return Promise.reject(false);\n}\n\n/**\n * A promise that resolves when all current events have been sent.\n * If you provide a timeout and the queue takes longer to drain the promise returns false.\n *\n * @param timeout Maximum time in ms the client should wait.\n */\nexport async function close(timeout?: number): Promise<boolean> {\n  const client = getCurrentHub().getClient<MainClient>();\n  if (client) {\n    return client.close(timeout);\n  }\n  return Promise.reject(false);\n}\n"]}