import { __assign, __awaiter, __generator } from "tslib";
import { getCurrentHub } from '@sentry/core';
import { Severity } from '@sentry/types';
import { isError } from '@sentry/utils';
import { dialog } from 'electron';
/** Capture unhandled erros. */
var OnUncaughtException = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function OnUncaughtException(_options) {
        if (_options === void 0) { _options = {}; }
        this._options = _options;
        /**
         * @inheritDoc
         */
        this.name = OnUncaughtException.id;
    }
    /**
     * @inheritDoc
     */
    OnUncaughtException.prototype.setupOnce = function () {
        var _this = this;
        global.process.on('uncaughtException', function (error) {
            var self = getCurrentHub().getIntegration(OnUncaughtException);
            if (self) {
                getCurrentHub().withScope(function (scope) { return __awaiter(_this, void 0, void 0, function () {
                    var theError, nodeClient, ref, stack, message;
                    var _this = this;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                scope.addEventProcessor(function (event) { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        return [2 /*return*/, (__assign(__assign({}, event), { level: Severity.Fatal }))];
                                    });
                                }); });
                                theError = error;
                                if (!isError(error) && error.stack) {
                                    theError = new Error();
                                    theError.message = error.message;
                                    theError.stack = error.stack;
                                    theError.name = error.name;
                                }
                                nodeClient = getCurrentHub().getClient();
                                nodeClient.captureException(theError, { originalException: error }, getCurrentHub().getScope());
                                return [4 /*yield*/, nodeClient.flush(nodeClient.getOptions().shutdownTimeout || 2000)];
                            case 1:
                                _a.sent();
                                if (this._options.onFatalError) {
                                    this._options.onFatalError(error);
                                }
                                else if (global.process.listenerCount('uncaughtException') <= 2) {
                                    // In addition to this handler there is always one in Electron
                                    // The dialog is only shown if there are no other handlers
                                    // eslint-disable-next-line no-console
                                    console.error('Uncaught Exception:');
                                    // eslint-disable-next-line no-console
                                    console.error(error);
                                    ref = error.stack;
                                    stack = ref !== undefined ? ref : error.name + ": " + error.message;
                                    message = "Uncaught Exception:\n" + stack;
                                    dialog.showErrorBox('A JavaScript error occurred in the main process', message);
                                }
                                return [2 /*return*/];
                        }
                    });
                }); });
            }
        });
    };
    /**
     * @inheritDoc
     */
    OnUncaughtException.id = 'OnUncaughtException';
    return OnUncaughtException;
}());
export { OnUncaughtException };
//# sourceMappingURL=onuncaughtexception.js.map