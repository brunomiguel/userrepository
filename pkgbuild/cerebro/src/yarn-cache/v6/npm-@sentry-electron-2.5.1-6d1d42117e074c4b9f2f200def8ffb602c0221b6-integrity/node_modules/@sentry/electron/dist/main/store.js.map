{"version":3,"file":"store.js","sourceRoot":"","sources":["../../src/main/store.ts"],"names":[],"mappings":";;AAAA,uCAAuC;AACvC,yBAA6D;AAC7D,6BAAqC;AAErC,2BAAkC;AAElC;;;;GAIG;AACH;IAUE;;;;;;OAMG;IACH,eAAmB,IAAY,EAAE,EAAU,EAAE,OAAU;QACrD,IAAI,CAAC,KAAK,GAAG,WAAI,CAAC,IAAI,EAAK,EAAE,UAAO,CAAC,CAAC;QACtC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;IACzB,CAAC;IAED;;;OAGG;IACI,mBAAG,GAAV,UAAW,IAAO;QAAlB,iBASC;QARC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAElB,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;YACtB,YAAY,CAAC;gBACX,KAAI,CAAC,MAAM,EAAE,CAAC;YAChB,CAAC,CAAC,CAAC;SACJ;IACH,CAAC;IAED;;;OAGG;IACI,sBAAM,GAAb,UAAc,EAAqB;QACjC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;IAC3B,CAAC;IAED;;;;;;OAMG;IACI,mBAAG,GAAV;QACE,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE;YAC5B,IAAI;gBACF,IAAI,CAAC,KAAK,GAAG,eAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAE,IAAI,CAAC,KAAK,CAAC,iBAAY,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,CAAO,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;aAC3G;YAAC,OAAO,CAAC,EAAE;gBACV,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC;aAC5B;SACF;QAED,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED,yCAAyC;IAClC,qBAAK,GAAZ;QACE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC1B,CAAC;IAED,sDAAsD;IAC9C,sBAAM,GAAd;QACE,IAAI;YACF,eAAU,CAAC,cAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;YAChC,kBAAa,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;SACvD;QAAC,OAAO,CAAC,EAAE;YACV,cAAM,CAAC,IAAI,CAAC,uBAAuB,EAAE,CAAC,CAAC,CAAC;YACxC,oEAAoE;YACpE,wEAAwE;YACxE,wEAAwE;SACzE;gBAAS;YACR,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;SACxB;IACH,CAAC;IACH,YAAC;AAAD,CAAC,AApFD,IAoFC;AApFY,sBAAK","sourcesContent":["import { logger } from '@sentry/utils';\nimport { existsSync, readFileSync, writeFileSync } from 'fs';\nimport { dirname, join } from 'path';\n\nimport { mkdirpSync } from './fs';\n\n/**\n * Note, this class is only compatible with Node.\n * Lazily serializes data to a JSON file to persist. When created, it loads data\n * from that file if it already exists.\n */\nexport class Store<T> {\n  /** Internal path for JSON file. */\n  private readonly _path: string;\n  /** Value used to initialize data for the first time. */\n  private readonly _initial: T;\n  /** Current state of the data. */\n  private _data?: T;\n  /** State whether a flush to disk has been requested in this cycle. */\n  private _flushing: boolean;\n\n  /**\n   * Creates a new store.\n   *\n   * @param path A unique filename to store this data.\n   * @param id A unique filename to store this data.\n   * @param initial An initial value to initialize data with.\n   */\n  public constructor(path: string, id: string, initial: T) {\n    this._path = join(path, `${id}.json`);\n    this._initial = initial;\n    this._flushing = false;\n  }\n\n  /**\n   * Updates data by replacing it with the given value.\n   * @param next New data to replace the previous one.\n   */\n  public set(next: T): void {\n    this._data = next;\n\n    if (!this._flushing) {\n      this._flushing = true;\n      setImmediate(() => {\n        this._flush();\n      });\n    }\n  }\n\n  /**\n   * Updates data by passing it through the given function.\n   * @param fn A function receiving the current data and returning new one.\n   */\n  public update(fn: (current: T) => T): void {\n    this.set(fn(this.get()));\n  }\n\n  /**\n   * Returns the current data.\n   *\n   * When invoked for the first time, it will try to load previously stored data\n   * from disk. If the file does not exist, the initial value provided to the\n   * constructor is used.\n   */\n  public get(): T {\n    if (this._data === undefined) {\n      try {\n        this._data = existsSync(this._path) ? (JSON.parse(readFileSync(this._path, 'utf8')) as T) : this._initial;\n      } catch (e) {\n        this._data = this._initial;\n      }\n    }\n\n    return this._data;\n  }\n\n  /** Returns store to its initial state */\n  public clear(): void {\n    this.set(this._initial);\n  }\n\n  /** Serializes the current data into the JSON file. */\n  private _flush(): void {\n    try {\n      mkdirpSync(dirname(this._path));\n      writeFileSync(this._path, JSON.stringify(this._data));\n    } catch (e) {\n      logger.warn('Failed to flush store', e);\n      // This usually fails due to anti virus scanners, issues in the file\n      // system, or problems with network drives. We cannot fix or handle this\n      // issue and must resume gracefully. Thus, we have to ignore this error.\n    } finally {\n      this._flushing = false;\n    }\n  }\n}\n"]}