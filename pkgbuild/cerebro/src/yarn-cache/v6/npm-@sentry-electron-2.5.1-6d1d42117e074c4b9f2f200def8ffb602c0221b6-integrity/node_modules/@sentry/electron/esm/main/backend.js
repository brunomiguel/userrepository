import { __assign, __awaiter, __extends, __generator, __values } from "tslib";
/* eslint-disable max-lines */
import { addBreadcrumb, BaseBackend, captureEvent, captureMessage, configureScope, getCurrentHub, Scope, } from '@sentry/core';
import { NodeBackend } from '@sentry/node';
import { Severity } from '@sentry/types';
import { Dsn, forget, logger, SentryError } from '@sentry/utils';
import { app, crashReporter, ipcMain } from 'electron';
import { join } from 'path';
import { getNameFallback, IPC } from '../common';
import { supportsGetPathCrashDumps, supportsRenderProcessGone } from '../electron-version';
import { addEventDefaults } from './context';
import { captureMinidump } from './index';
import { normalizeEvent, normalizeUrl } from './normalize';
import { Store } from './store';
import { NetTransport } from './transports/net';
import { MinidumpUploader } from './uploader';
/** Gets the path to the Sentry cache directory. */
function getCachePath() {
    return join(app.getPath('userData'), 'sentry');
}
/**
 * Returns a promise that resolves when app is ready.
 */
export function isAppReady() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, (app.isReady() ||
                    new Promise(function (resolve) {
                        app.once('ready', function () {
                            resolve(true);
                        });
                    }))];
        });
    });
}
/** Is object defined and has keys */
function hasKeys(obj) {
    return obj != undefined && Object.keys(obj).length > 0;
}
/** Gets a Scope object with user, tags and extra */
function getScope() {
    var scope = getCurrentHub().getScope();
    if (!scope) {
        return {};
    }
    return __assign(__assign(__assign({}, (hasKeys(scope._user) && { user: scope._user })), (hasKeys(scope._tags) && { tags: scope._tags })), (hasKeys(scope._extra) && { extra: scope._extra }));
}
/** Backend implementation for Electron renderer backends. */
var MainBackend = /** @class */ (function (_super) {
    __extends(MainBackend, _super);
    /** Creates a new Electron backend instance. */
    function MainBackend(options) {
        var _this = this;
        // Disable session tracking until we've decided how this should work with Electron
        options.autoSessionTracking = false;
        _this = _super.call(this, options) || this;
        _this._inner = new NodeBackend(options);
        _this._scopeStore = new Store(getCachePath(), 'scope_v2', new Scope());
        // We need to store the scope in a variable here so it can be attached to minidumps
        _this._scopeLastRun = _this._scopeStore.get();
        _this._updateEpoch = 0;
        _this._setupScopeListener();
        if (_this._isNativeEnabled()) {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            forget(_this._installNativeHandler());
        }
        _this._installIPC();
        return _this;
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    MainBackend.prototype.eventFromException = function (exception, hint) {
        return this._inner.eventFromException(exception, hint);
    };
    /**
     * @inheritDoc
     */
    MainBackend.prototype.eventFromMessage = function (message, level, hint) {
        if (level === void 0) { level = Severity.Info; }
        return this._inner.eventFromMessage(message, level, hint);
    };
    /**
     * @inheritDoc
     */
    MainBackend.prototype.sendEvent = function (event) {
        this._inner.sendEvent(event);
    };
    /**
     * Uploads the given minidump and attaches event information.
     *
     * @param path A relative or absolute path to the minidump file.
     * @param event Optional event information to add to the minidump request.
     */
    MainBackend.prototype.uploadMinidump = function (path, event) {
        if (event === void 0) { event = {}; }
        if (this._uploader) {
            forget(this._uploader.uploadMinidump({ path: path, event: event }));
        }
    };
    /**
     * Setup Transport
     */
    MainBackend.prototype._setupTransport = function () {
        if (!this._options.dsn) {
            // We return the noop transport here in case there is no Dsn.
            return _super.prototype._setupTransport.call(this);
        }
        var transportOptions = __assign(__assign(__assign(__assign(__assign({}, this._options.transportOptions), (this._options.httpProxy && { httpProxy: this._options.httpProxy })), (this._options.httpsProxy && { httpsProxy: this._options.httpsProxy })), (this._options.caCerts && { caCerts: this._options.caCerts })), { dsn: this._options.dsn });
        if (this._options.transport) {
            return new this._options.transport(transportOptions);
        }
        return new NetTransport(transportOptions);
    };
    /**
     * Adds a scope listener to persist changes to disk.
     */
    MainBackend.prototype._setupScopeListener = function () {
        var _this = this;
        var hubScope = getCurrentHub().getScope();
        if (hubScope) {
            hubScope.addScopeListener(function (updatedScope) {
                var scope = Scope.clone(updatedScope);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                scope._eventProcessors = [];
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                scope._scopeListeners = [];
                _this._scopeStore.set(scope);
                // If we use the Crashpad minidump uploader we have to set extra whenever the scope updates
                //
                // We do not currently set addExtraParameter on Linux because Breakpad is limited
                if (_this._options.useCrashpadMinidumpUploader === true && process.platform !== 'linux') {
                    _this._updateExtraParams(scope);
                }
            });
        }
    };
    /** Updates Electron uploader extra params */
    MainBackend.prototype._updateExtraParams = function (scope) {
        var _this = this;
        this._updateEpoch += 1;
        var currentEpoch = this._updateEpoch;
        forget(this._getNativeUploaderEvent(scope).then(function (event) {
            var e_1, _a;
            if (currentEpoch !== _this._updateEpoch)
                return;
            // Update the extra parameters in the main process
            var mainParams = _this._getNativeUploaderExtraParams(event);
            try {
                for (var _b = __values(Object.keys(mainParams)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    crashReporter.addExtraParameter(key, mainParams[key]);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }));
    };
    /** Builds up an event to send with the native Electron uploader */
    MainBackend.prototype._getNativeUploaderEvent = function (scope) {
        return __awaiter(this, void 0, void 0, function () {
            var event;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        event = {
                            tags: { event_type: 'native' },
                        };
                        // Apply the scope to the event
                        return [4 /*yield*/, scope.applyToEvent(event)];
                    case 1:
                        // Apply the scope to the event
                        _a.sent();
                        return [4 /*yield*/, addEventDefaults(this._options.appName, event)];
                    case 2:
                        // Add all the extra context
                        event = _a.sent();
                        return [2 /*return*/, normalizeEvent(event)];
                }
            });
        });
    };
    /** Chunks up event JSON into 1 or more parameters for use with the native Electron uploader
     *
     * Returns chunks with keys and values:
     * {
     *    sentry__1: '{ json...',
     *    sentry__2: 'more json...',
     *    sentry__x: 'end json }',
     * }
     */
    MainBackend.prototype._getNativeUploaderExtraParams = function (event) {
        var maxBytes = 20300;
        /** Max chunk sizes are in bytes so we can't chunk by characters or UTF8 could bite us.
         *
         * We attempt to split by space (32) and double quote characters (34) as there are plenty in JSON
         * and they are guaranteed to not be the first byte of a multi-byte UTF8 character.
         */
        var buf = Buffer.from(JSON.stringify(event));
        var chunks = [];
        while (buf.length) {
            // Find last '"'
            var i = buf.lastIndexOf(34, maxBytes + 1);
            // Or find last ' '
            if (i < 0)
                i = buf.lastIndexOf(32, maxBytes + 1);
            // Or find first '"'
            if (i < 0)
                i = buf.indexOf(34, maxBytes);
            // Or find first ' '
            if (i < 0)
                i = buf.indexOf(32, maxBytes);
            // We couldn't find any space or quote chars so split at maxBytes and hope for the best 🤷‍♂️
            if (i < 0)
                i = maxBytes;
            chunks.push(buf.slice(0, i + 1).toString());
            buf = buf.slice(i + 1);
        }
        return chunks.reduce(function (acc, cur, i) {
            acc["sentry__" + (i + 1)] = cur;
            return acc;
        }, {});
    };
    /** Returns whether native reports are enabled. */
    MainBackend.prototype._isNativeEnabled = function () {
        // Mac AppStore builds cannot run the crash reporter due to the sandboxing
        // requirements. In this case, we prevent enabling native crashes entirely.
        // https://electronjs.org/docs/tutorial/mac-app-store-submission-guide#limitations-of-mas-build
        if (process.mas) {
            return false;
        }
        return this._options.enableNative !== false;
    };
    /** Activates the Electron CrashReporter. */
    MainBackend.prototype._installNativeHandler = function () {
        return __awaiter(this, void 0, void 0, function () {
            var dsnString, globalExtra, dsn, crashesDirectory, sendRendererCrash;
            var _this = this;
            return __generator(this, function (_a) {
                dsnString = this._options.dsn;
                if (!dsnString) {
                    throw new SentryError('Attempted to enable Electron native crash reporter but no DSN was supplied');
                }
                globalExtra = process.platform !== 'linux' ? { sentry___initialScope: JSON.stringify(getScope()) } : undefined;
                dsn = new Dsn(dsnString);
                // We will manually submit errors, but CrashReporter requires a submitURL in
                // some versions. Also, provide a productName and companyName, which we will
                // add manually to the event's context during submission.
                crashReporter.start({
                    companyName: '',
                    ignoreSystemCrashHandler: true,
                    productName: this._options.appName || getNameFallback(),
                    submitURL: MinidumpUploader.minidumpUrlFromDsn(dsn),
                    uploadToServer: this._options.useCrashpadMinidumpUploader || false,
                    compress: true,
                    globalExtra: globalExtra,
                });
                if (this._options.useSentryMinidumpUploader !== false) {
                    crashesDirectory = supportsGetPathCrashDumps()
                        ? app.getPath('crashDumps')
                        : // unsafe member access required because of older versions of Electron
                            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                            crashReporter.getCrashesDirectory();
                    this._uploader = new MinidumpUploader(dsn, crashesDirectory, getCachePath(), this.getTransport());
                    // Flush already cached minidumps from the queue.
                    forget(this._uploader.flushQueue());
                    // Start to submit recent minidump crashes. This will load breadcrumbs and
                    // context information that was cached on disk prior to the crash.
                    forget(this._sendNativeCrashes({}));
                }
                sendRendererCrash = function (contents, details) { return __awaiter(_this, void 0, void 0, function () {
                    var e_2;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!(this._options.useSentryMinidumpUploader !== false)) return [3 /*break*/, 4];
                                _a.label = 1;
                            case 1:
                                _a.trys.push([1, 3, , 4]);
                                return [4 /*yield*/, this._sendNativeCrashes(this._getNewEventWithElectronContext(contents, details))];
                            case 2:
                                _a.sent();
                                return [3 /*break*/, 4];
                            case 3:
                                e_2 = _a.sent();
                                // eslint-disable-next-line no-console
                                console.error(e_2);
                                return [3 /*break*/, 4];
                            case 4:
                                addBreadcrumb({
                                    category: 'exception',
                                    level: Severity.Critical,
                                    message: 'Renderer Crashed',
                                });
                                return [2 /*return*/];
                        }
                    });
                }); };
                // Every time a subprocess or renderer crashes, start sending minidumps
                // right away.
                app.on('web-contents-created', function (_, contents) {
                    if (supportsRenderProcessGone()) {
                        contents.on('render-process-gone', function (_event, details) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, sendRendererCrash(contents, details)];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                    }
                    else {
                        // unsafe member access required because of older versions of Electron
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        contents.on('crashed', function () { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, sendRendererCrash(contents)];
                                    case 1:
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                    }
                    if (_this._options.enableUnresponsive !== false) {
                        contents.on('unresponsive', function () {
                            captureMessage('BrowserWindow Unresponsive');
                        });
                    }
                });
                return [2 /*return*/];
            });
        });
    };
    /** Installs IPC handlers to receive events and metadata from renderers. */
    MainBackend.prototype._installIPC = function () {
        var _this = this;
        ipcMain.on(IPC.PING, function (event) {
            event.sender.send(IPC.PING);
        });
        ipcMain.on(IPC.EVENT, function (ipc, jsonEvent) {
            var event;
            try {
                event = JSON.parse(jsonEvent);
            }
            catch (_a) {
                // eslint-disable-next-line no-console
                console.warn('sentry-electron received an invalid IPC_EVENT message');
                return;
            }
            event.contexts = __assign(__assign({}, _this._getNewEventWithElectronContext(ipc.sender).contexts), event.contexts);
            captureEvent(event);
        });
        ipcMain.on(IPC.SCOPE, function (_, jsonRendererScope) {
            var rendererScope;
            try {
                rendererScope = JSON.parse(jsonRendererScope);
            }
            catch (_a) {
                // eslint-disable-next-line no-console
                console.warn('sentry-electron received an invalid IPC_SCOPE message');
                return;
            }
            var sentScope = Scope.clone(rendererScope);
            /* eslint-disable @typescript-eslint/no-unsafe-member-access */
            configureScope(function (scope) {
                if (hasKeys(sentScope._user)) {
                    scope.setUser(sentScope._user);
                }
                if (hasKeys(sentScope._tags)) {
                    scope.setTags(sentScope._tags);
                }
                if (hasKeys(sentScope._extra)) {
                    scope.setExtras(sentScope._extra);
                }
                // Since we do not have updates for individual breadcrumbs any more and only for the whole scope
                // we just add the last added breadcrumb on scope updates
                scope.addBreadcrumb(sentScope._breadcrumbs.pop(), _this._options.maxBreadcrumbs);
            });
            /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        });
    };
    /** Loads new native crashes from disk and sends them to Sentry. */
    MainBackend.prototype._sendNativeCrashes = function (event) {
        return __awaiter(this, void 0, void 0, function () {
            var uploader, paths, currentCloned, storedScope, newEvent_1, _oO_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Whenever we are called, assume that the crashes we are going to load down
                        // below have occurred recently. This means, we can use the same event data
                        // for all minidumps that we load now. There are two conditions:
                        //
                        //  1. The application crashed and we are just starting up. The stored
                        //     breadcrumbs and context reflect the state during the application
                        //     crash.
                        //
                        //  2. A renderer process crashed recently and we have just been notified
                        //     about it. Just use the breadcrumbs and context information we have
                        //     right now and hope that the delay was not too long.
                        if (this._options.useSentryMinidumpUploader === false) {
                            // In case we are not using the Sentry Minidump uploader we don't want to throw an error
                            return [2 /*return*/];
                        }
                        uploader = this._uploader;
                        if (uploader === undefined) {
                            throw new SentryError('Invariant violation: Native crashes not enabled');
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 7, , 8]);
                        return [4 /*yield*/, uploader.getNewMinidumps()];
                    case 2:
                        paths = _a.sent();
                        if (!(paths.length > 0)) return [3 /*break*/, 6];
                        currentCloned = Scope.clone(getCurrentHub().getScope());
                        storedScope = Scope.clone(this._scopeLastRun);
                        return [4 /*yield*/, storedScope.applyToEvent(event)];
                    case 3:
                        newEvent_1 = _a.sent();
                        if (!newEvent_1) return [3 /*break*/, 5];
                        return [4 /*yield*/, currentCloned.applyToEvent(newEvent_1)];
                    case 4:
                        newEvent_1 = _a.sent();
                        paths.map(function (path) {
                            captureMinidump(path, __assign({}, newEvent_1));
                        });
                        _a.label = 5;
                    case 5:
                        // Unset to recover memory
                        this._scopeLastRun = undefined;
                        _a.label = 6;
                    case 6: return [3 /*break*/, 8];
                    case 7:
                        _oO_1 = _a.sent();
                        logger.error('Error while sending native crash.');
                        return [3 /*break*/, 8];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /** Returns extra information from a renderer's web contents. */
    MainBackend.prototype._getNewEventWithElectronContext = function (contents, details) {
        var customName = this._options.getRendererName && this._options.getRendererName(contents);
        var electronContext = {
            crashed_process: customName || "renderer[" + contents.id + "]",
            crashed_url: normalizeUrl(contents.getURL()),
        };
        if (details) {
            // We need to do it like this, otherwise we normalize undefined to "[undefined]" in the UI
            electronContext.details = details;
        }
        return {
            contexts: {
                electron: electronContext,
            },
        };
    };
    return MainBackend;
}(BaseBackend));
export { MainBackend };
//# sourceMappingURL=backend.js.map