import { __awaiter, __generator } from "tslib";
import { mkdir, mkdirSync, readdir, readFile, rename, stat, statSync, unlink } from 'fs';
import { dirname, resolve } from 'path';
/**
 * Asynchronously reads given files content.
 *
 * @param path A relative or absolute path to the file
 * @returns A Promise that resolves when the file has been read.
 */
export function readFileAsync(path, options) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            // We cannot use util.promisify here because that was only introduced in Node
            // 8 and we need to support older Node versions.
            return [2 /*return*/, new Promise(function (res, reject) {
                    readFile(path, options, function (err, data) {
                        if (err) {
                            reject(err);
                        }
                        else {
                            res(data);
                        }
                    });
                })];
        });
    });
}
/**
 * Asynchronously creates the given directory.
 *
 * @param path A relative or absolute path to the directory.
 * @param mode The permission mode.
 * @returns A Promise that resolves when the path has been created.
 */
function mkdirAsync(path, mode) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            // We cannot use util.promisify here because that was only introduced in Node
            // 8 and we need to support older Node versions.
            return [2 /*return*/, new Promise(function (res, reject) {
                    mkdir(path, mode, function (err) {
                        if (err) {
                            reject(err);
                        }
                        else {
                            res();
                        }
                    });
                })];
        });
    });
}
/**
 * Recursively creates the given path.
 *
 * @param path A relative or absolute path to create.
 * @returns A Promise that resolves when the path has been created.
 */
export function mkdirp(path) {
    return __awaiter(this, void 0, void 0, function () {
        var realPath, err_1, error;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    realPath = resolve(path);
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 2, , 5]);
                    return [2 /*return*/, mkdirAsync(realPath, 511)];
                case 2:
                    err_1 = _a.sent();
                    error = err_1;
                    if (!(error && error.code === 'ENOENT')) return [3 /*break*/, 4];
                    return [4 /*yield*/, mkdirp(dirname(realPath))];
                case 3:
                    _a.sent();
                    return [2 /*return*/, mkdirAsync(realPath, 511)];
                case 4:
                    try {
                        if (!statSync(realPath).isDirectory()) {
                            throw err_1;
                        }
                    }
                    catch (_) {
                        throw err_1;
                    }
                    return [3 /*break*/, 5];
                case 5: return [2 /*return*/];
            }
        });
    });
}
/**
 * Synchronous version of {@link mkdirp}.
 *
 * @param path A relative or absolute path to create.
 */
export function mkdirpSync(path) {
    var realPath = resolve(path);
    try {
        mkdirSync(realPath, 511);
    }
    catch (err) {
        var error = err;
        if (error && error.code === 'ENOENT') {
            mkdirpSync(dirname(realPath));
            mkdirSync(realPath, 511);
        }
        else {
            try {
                if (!statSync(realPath).isDirectory()) {
                    throw err;
                }
            }
            catch (_) {
                throw err;
            }
        }
    }
}
/**
 * Read stats async
 */
export function statAsync(path) {
    return new Promise(function (res, reject) {
        stat(path, function (err, stats) {
            if (err) {
                reject(err);
                return;
            }
            res(stats);
        });
    });
}
/**
 * unlink async
 */
export function unlinkAsync(path) {
    return new Promise(function (res, reject) {
        unlink(path, function (err) {
            if (err) {
                reject(err);
                return;
            }
            res();
        });
    });
}
/**
 * readdir async
 */
export function readDirAsync(path) {
    return new Promise(function (res, reject) {
        readdir(path, function (err, files) {
            if (err) {
                reject(err);
                return;
            }
            res(files);
        });
    });
}
/**
 * rename async
 */
export function renameAsync(oldPath, newPath) {
    return new Promise(function (res, reject) {
        rename(oldPath, newPath, function (err) {
            if (err) {
                reject(err);
                return;
            }
            res();
        });
    });
}
//# sourceMappingURL=fs.js.map