{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/main/index.ts"],"names":[],"mappings":";;;AAAA,uCAauB;AANrB,iGAAA,QAAQ,OAAA;AAGR,+FAAA,MAAM,OAAA;AAKR,qCAkBsB;AAjBpB,+GAAA,uBAAuB,OAAA;AACvB,qGAAA,aAAa,OAAA;AACb,wGAAA,gBAAgB,OAAA;AAChB,oGAAA,YAAY,OAAA;AACZ,sGAAA,cAAc,OAAA;AACd,sGAAA,cAAc,OAAA;AACd,yGAAA,iBAAiB,OAAA;AACjB,qGAAA,aAAa,OAAA;AACb,2FAAA,GAAG,OAAA;AACH,6FAAA,KAAK,OAAA;AACL,kGAAA,UAAU,OAAA;AACV,gGAAA,QAAQ,OAAA;AACR,iGAAA,SAAS,OAAA;AACT,8FAAA,MAAM,OAAA;AACN,+FAAA,OAAO,OAAA;AACP,+FAAA,OAAO,OAAA;AACP,iGAAA,SAAS,OAAA;AAGX,qCAA0D;AAC1D,2CAAgD;AAChD,qCAAmD;AAInD,mCAAsC;AACtC,+CAA+D;AAC/D,wCAAgD;AAChD,mCAAsC;AAA7B,oGAAA,UAAU,OAAA;AACnB,qCAAwC;AAA/B,sGAAA,WAAW,OAAA;AACpB,wCAAgD;AAAvC,mGAAA,YAAY,OAAA;AACrB,qCAAgE;AAAvD,wGAAA,YAAY,OAAoB;AAE5B,QAAA,oBAAoB,GAAG,EAAE,QAAQ,yBAAA,EAAE,mBAAmB,oCAAA,EAAE,CAAC;AAEtE;;;GAGG;AACH,SAAgB,IAAI,CAAC,OAAwB;IAC3C,IAAM,oBAAoB,GAAG,0BAAmB,CAAC,MAAM,CAAC,UAAA,WAAW,IAAI,OAAA,WAAW,CAAC,IAAI,KAAK,qBAAqB,EAA1C,CAA0C,CAAC,CAAC;IACnH,IAAI,OAAO,CAAC,mBAAmB,KAAK,SAAS,EAAE;QAC7C,OAAO,CAAC,mBAAmB,kEACtB,oBAAoB;YACvB,6DAA6D;YAC7D,IAAI,kCAAmB,CAAC,EAAE,YAAY,EAAE,OAAO,CAAC,YAAY,EAAE,CAAC;YAC/D,IAAI,uBAAQ,EAAE;UACf,CAAC;KACH;IACD,kBAAW,CAAC,mBAAU,qBACpB,SAAS,EAAE,kBAAY,IACpB,OAAO,EACV,CAAC;AACL,CAAC;AAdD,oBAcC;AAED;;GAEG;AACH,SAAgB,gBAAgB;IAC9B,OAAO;AACT,CAAC;AAFD,4CAEC;AAED;;;;;GAKG;AACH,SAAgB,eAAe,CAAC,IAAY,EAAE,KAAiB;IAAjB,sBAAA,EAAA,UAAiB;IAC7D,uBAAa,CAAC,iBAAiB,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;AAChD,CAAC;AAFD,0CAEC;AAED;;;;;GAKG;AACH,SAAsB,KAAK,CAAC,OAAgB;;;;YACpC,MAAM,GAAG,oBAAa,EAAE,CAAC,SAAS,EAAc,CAAC;YACvD,IAAI,MAAM,EAAE;gBACV,sBAAO,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,EAAC;aAC9B;YACD,sBAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,EAAC;;;CAC9B;AAND,sBAMC;AAED;;;;;GAKG;AACH,SAAsB,KAAK,CAAC,OAAgB;;;;YACpC,MAAM,GAAG,oBAAa,EAAE,CAAC,SAAS,EAAc,CAAC;YACvD,IAAI,MAAM,EAAE;gBACV,sBAAO,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,EAAC;aAC9B;YACD,sBAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,EAAC;;;CAC9B;AAND,sBAMC","sourcesContent":["export {\n  Breadcrumb,\n  Request,\n  SdkInfo,\n  Event,\n  Exception,\n  Response,\n  Severity,\n  StackFrame,\n  Stacktrace,\n  Status,\n  Thread,\n  User,\n} from '@sentry/types';\n\nexport {\n  addGlobalEventProcessor,\n  addBreadcrumb,\n  captureException,\n  captureEvent,\n  captureMessage,\n  configureScope,\n  getHubFromCarrier,\n  getCurrentHub,\n  Hub,\n  Scope,\n  setContext,\n  setExtra,\n  setExtras,\n  setTag,\n  setTags,\n  setUser,\n  withScope,\n} from '@sentry/core';\n\nimport { getCurrentHub, initAndBind } from '@sentry/core';\nimport { _callOnClient } from '@sentry/minimal';\nimport { defaultIntegrations } from '@sentry/node';\nimport { Event } from '@sentry/types';\n\nimport { ElectronOptions } from '../common';\nimport { MainClient } from './client';\nimport { Electron, OnUncaughtException } from './integrations';\nimport { NetTransport } from './transports/net';\nexport { MainClient } from './client';\nexport { MainBackend } from './backend';\nexport { NetTransport } from './transports/net';\nexport { Integrations as NodeIntegrations } from '@sentry/node';\n\nexport const ElectronIntegrations = { Electron, OnUncaughtException };\n\n/**\n * Init call to node, if no transport is set, we use net of electron\n * @param options ElectronOptions\n */\nexport function init(options: ElectronOptions): void {\n  const electronIntegrations = defaultIntegrations.filter(integration => integration.name !== 'OnUncaughtException');\n  if (options.defaultIntegrations === undefined) {\n    options.defaultIntegrations = [\n      ...electronIntegrations,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      new OnUncaughtException({ onFatalError: options.onFatalError }),\n      new Electron(),\n    ];\n  }\n  initAndBind(MainClient, {\n    transport: NetTransport,\n    ...options,\n  });\n}\n\n/**\n * This function does nothing, call it in the renderer\n */\nexport function showReportDialog(): void {\n  // noop\n}\n\n/**\n * Uploads a native crash dump (Minidump) to Sentry.\n *\n * @param path The relative or absolute path to the minidump.\n * @param event Optional event payload to attach to the minidump.\n */\nexport function captureMinidump(path: string, event: Event = {}): void {\n  _callOnClient('captureMinidump', path, event);\n}\n\n/**\n * A promise that resolves when all current events have been sent.\n * If you provide a timeout and the queue takes longer to drain the promise returns false.\n *\n * @param timeout Maximum time in ms the client should wait.\n */\nexport async function flush(timeout?: number): Promise<boolean> {\n  const client = getCurrentHub().getClient<MainClient>();\n  if (client) {\n    return client.flush(timeout);\n  }\n  return Promise.reject(false);\n}\n\n/**\n * A promise that resolves when all current events have been sent.\n * If you provide a timeout and the queue takes longer to drain the promise returns false.\n *\n * @param timeout Maximum time in ms the client should wait.\n */\nexport async function close(timeout?: number): Promise<boolean> {\n  const client = getCurrentHub().getClient<MainClient>();\n  if (client) {\n    return client.close(timeout);\n  }\n  return Promise.reject(false);\n}\n"]}