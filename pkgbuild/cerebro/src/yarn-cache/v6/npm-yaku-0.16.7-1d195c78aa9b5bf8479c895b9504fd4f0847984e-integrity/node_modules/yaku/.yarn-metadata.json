{
  "manifest": {
    "name": "yaku",
    "version": "0.16.7",
    "description": "A lightweight promise library",
    "main": "lib/yaku.js",
    "typings": "lib/yaku.d.ts",
    "scripts": {
      "no": "no",
      "test": "no test test-core",
      "prepublish": "no clean build"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/ysmood/yaku.git"
    },
    "keywords": [
      "light-weight",
      "es6",
      "promise",
      "performance",
      "promises",
      "promises-a",
      "promises-aplus",
      "async",
      "await",
      "deferred",
      "deferreds",
      "future",
      "flow control"
    ],
    "author": {
      "name": "http://ysmood.org"
    },
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/ysmood/yaku/issues"
    },
    "homepage": "https://github.com/ysmood/yaku",
    "files": [
      "lib",
      "dist/yaku.min.js",
      "dist/yaku.core.min.js",
      "dist/yaku.browser.full.min.js",
      "dist/yaku.browser.global.min.js"
    ],
    "devDependencies": {
      "bluebird": "3.4.1",
      "co": "4.6.0",
      "core-js": "2.4.0",
      "coveralls": "2.11.9",
      "es6-promise": "3.2.1",
      "es6-shim": "0.35.1",
      "eslint": "2.13.1",
      "istanbul": "0.4.4",
      "junit": "1.4.4",
      "mocha": "2.5.3",
      "my-promise": "1.1.0",
      "nokit": "0.21.0",
      "phantomjs-prebuilt": "2.1.7",
      "promises-aplus-tests": "*",
      "promises-es6-tests": "*",
      "q": "1.4.1",
      "setprototypeof": "1.0.1",
      "uglify-js": "2.6.4",
      "webpack": "1.13.1"
    },
    "eslintConfig": {
      "env": {
        "browser": true,
        "node": true,
        "es6": true
      },
      "extends": "eslint:recommended",
      "rules": {
        "indent": [
          2,
          4
        ],
        "linebreak-style": [
          2,
          "unix"
        ],
        "semi": [
          2,
          "always"
        ],
        "quotes": [
          2,
          "double"
        ],
        "no-cond-assign": 0,
        "no-trailing-spaces": 2,
        "space-before-function-paren": [
          2,
          "always"
        ],
        "eqeqeq": [
          2,
          "allow-null"
        ]
      }
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-yaku-0.16.7-1d195c78aa9b5bf8479c895b9504fd4f0847984e-integrity/node_modules/yaku/package.json",
    "readmeFilename": "readme.md",
    "readme": "<a href=\"http://promisesaplus.com/\">\n    <img src=\"http://promisesaplus.com/assets/logo-small.png\" alt=\"Promises/A+ logo\"\n         title=\"Promises/A+ 1.1 compliant\" align=\"right\" />\n</a>\n\n# Overview\n\nYaku is full compatible with ES6's native [Promise][native], but much faster, and more error friendly.\nIf you want to learn how Promise works, read the minimum implementation [docs/minPromiseAplus.js][]. Without comments, it is only 80 lines of code (gzipped size is 0.5KB).\nIt only implements the `constructor` and `then`.\n\nYaku passed all the tests of [promises-aplus-tests][], [promises-es6-tests][], and even the [core-js tests][].\n\nI am not an optimization freak, I try to keep the source code readable and maintainable.\nI write this lib to research one of my data structure ideas: [docs/lazyTree.md][].\n\n[![NPM version](https://badge.fury.io/js/yaku.svg)](http://badge.fury.io/js/yaku) [![Build Status](https://travis-ci.org/ysmood/yaku.svg)](https://travis-ci.org/ysmood/yaku) [![Deps Up to Date](https://david-dm.org/ysmood/yaku.svg?style=flat)](https://david-dm.org/ysmood/yaku) [![Coverage Status](https://coveralls.io/repos/ysmood/yaku/badge.svg?branch=master&service=github)](https://coveralls.io/github/ysmood/yaku?branch=master)\n\n\n\n# Features\n\n- The minified file is only 4.1KB (1.8KB gzipped)\n- Supports \"uncaught rejection\" and \"long stack trace\", [Comparison][docs/debugHelperComparison.md]\n- Designed to work on IE5+ and other major browsers\n- 100% statement and branch test coverage\n- Much better performance than the native Promise\n- Well commented source code with every Promises/A+ spec\n\n\n\n# Quick Start\n\n## Node.js\n\n```shell\nnpm install yaku\n```\n\nThen:\n\n```js\nvar Promise = require('yaku');\n```\n\nOr if you don't want any extra debug helper, ES6 only version is here:\n\n```js\nvar Promise = require('yaku/lib/yaku.core');\n```\n\n## Browser\n\nUse something like [Browserify][] or [Webpack][], or download the `yaku.js` file from [release page][].\nRaw usage without:\n\n```html\n<script type=\"text/javascript\" src =\"yaku.js\"></script>\n<script>\n    // Yaku will be assigned to `window.Yaku`.\n    var Promise = Yaku;\n</script>\n```\n\n\n\n# Change Log\n\n[docs/changelog.md](docs/changelog.md)\n\n\n\n# Compare to Other Promise Libs\n\nThese comparisons only reflect some limited truth, no one is better than all others on all aspects.\nThere are tons of Promises/A+ implementations, you can see them [here](https://promisesaplus.com/implementations). Only some of the famous ones were tested.\n\n```\nDate: Tue Jun 28 2016 14:12:35 GMT+0800 (CST)\nNode v6.2.2\nOS   darwin\nArch x64\nCPU  Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz\n```\n\n| name | unit tests | coverage | 1ms async task | optional helpers | helpers | min js |\n| ---- | ---------- | -------- | -------------- | ---------------- | ------- | ------ |\n| [yaku][]@0.16.6 | ✓ | 100% 100% | 327ms / 108MB | ✓ | 33 | 4.1KB |\n| [yaku.core][]@0.16.6 | ✓ | 100% 100% | 317ms / 108MB | ✓ | 27 | 3.3KB |\n| [bluebird][]@3.4.1 | x (33 failing) | 99% 96% | 212ms / 91MB | partial | 102 | 52.8KB |\n| [es6-promise][]@3.2.1 | x (48 failing) | ? ? | 473ms / 107MB | x | 10 | 6.4KB |\n| [native][]@0.16.1 | x (12 failing) | ? ? | 682ms / 164MB | x | 13 | 0KB |\n| [core-js][]@2.4.0 | x (10 failing) | ? ? | 600ms / 185MB | x | 11 | 12.3KB |\n| [es6-shim][]@0.35.1 | x (12 failing) | ? ? | 684ms / 165MB | x | 11 | 54.7KB |\n| [q][]@1.4.1 | x (47 failing) | ? ? | 1341ms / 389MB | x | 74 | 15.4KB |\n| [my-promise][]@1.1.0 | x (7 failing) | ? ? | 864ms / 226MB | x | 10 | 8.4KB |\n\n- **unit test**: [promises-aplus-tests][], [promises-es6-tests][], and even the [core-js tests][].\n\n- **coverage**: statement coverage and branch coverage.\n\n- **helpers**: extra methods that help with your promise programming, such as\n  async flow control helpers, debug helpers. For more details: [docs/debugHelperComparison.md][].\n\n- **1ms async task**: `npm run no -- benchmark`, the smaller the better (total time / memory rss).\n\n- **promises-es6-tests**: If you want to test `bluebird` against promises-es6-tests,\n  run `npm run no -- test-es6 --shim bluebird`.\n\n- **optional helpers**: Whether the helpers can be imported separately or not,\n  which means you can load the lib without helpers. Such as the `bluebird-core`, it will inevitably load\n  some nonstandard helpers: `spread`, `promisify`, etc.\n\n\n# FAQ\n\n- `catch` on old brwoser (IE7, IE8 etc)?\n\n  > In ECMA-262 spec, `catch` cannot be used as method name. You have to alias the method name or use something like `Promise.resolve()['catch'](function() {})` or `Promise.resolve().then(null, function() {})`.\n\n- Will Yaku implement `done`, etc?\n\n  > No. All non-ES6 APIs are only implemented for debugging and testing, which means when you remove Yaku, everything\n  > should work well with ES6 native promise.\n\n- When using with Babel and Regenerator, the unhandled rejection doesn't work.\n\n  > Because Regenerator use global Promise directly and don't have an api to set the Promise lib.\n  > You have to import Yaku globally to make it use Yaku: `require(\"yaku/lib/global\");`.\n\n- The name Yaku is weird?\n\n  > The name `yaku` comes from the word `約束(yaku soku)` which means promise.\n\n\n# Unhandled Rejection\n\nYaku will report any unhandled rejection via `console.error` by default, in case you forget to write `catch`.\nYou can catch them manually:\n\n- Browser: `window.onunhandledrejection = ({ promise, reason }) => { /* Your Code */ };`\n- Node: `process.on(\"unhandledRejection\", (reason, promise) => { /* Your Code */ });`\n\nFor more spec read [Unhandled Rejection Tracking Browser Events](https://github.com/domenic/unhandled-rejections-browser-spec).\n\n\n# API\n\n- #### require('yaku')\n  - [Yaku(executor)](#yakuexecutor)\n  - [then(onFulfilled, onRejected)](#thenonfulfilled-onrejected)\n  - [catch(onRejected)](#catchonrejected)\n  - [Yaku.resolve(value)](#yakuresolvevalue)\n  - [Yaku.reject(reason)](#yakurejectreason)\n  - [Yaku.race(iterable)](#yakuraceiterable)\n  - [Yaku.all(iterable)](#yakualliterable)\n  - [Yaku.Symbol](#yakusymbol)\n  - [Yaku.speciesConstructor(O, defaultConstructor)](#yakuspeciesconstructoro-defaultconstructor)\n  - [Yaku.unhandledRejection(reason, p)](#yakuunhandledrejectionreason-p)\n  - [Yaku.rejectionHandled(reason, p)](#yakurejectionhandledreason-p)\n  - [Yaku.enableLongStackTrace](#yakuenablelongstacktrace)\n  - [Yaku.nextTick](#yakunexttick)\n\n- #### require('yaku/lib/utils')\n  - [all(limit, list)](#alllimit-list)\n  - [any(iterable)](#anyiterable)\n  - [async(gen)](#asyncgen)\n  - [callbackify(fn, self)](#callbackifyfn-self)\n  - [Deferred](#deferred)\n  - [flow(list)](#flowlist)\n  - [guard(type, onRejected)](#guardtype-onrejected)\n  - [if(cond, trueFn, falseFn)](#ifcond-truefn-falsefn)\n  - [isPromise(obj)](#ispromiseobj)\n  - [never()](#never)\n  - [promisify(fn, self)](#promisifyfn-self)\n  - [sleep(time, val)](#sleeptime-val)\n  - [Observable](#observable)\n  - [retry(countdown, span, fn, this)](#retrycountdown-span-fn-this)\n  - [throw(err)](#throwerr)\n\n- #### require('yaku/lib/Observable')\n  - [Observable(executor)](#observableexecutor)\n  - [next(value)](#nextvalue)\n  - [error(value)](#errorvalue)\n  - [publisher](#publisher)\n  - [subscribers](#subscribers)\n  - [subscribe(onNext, onError)](#subscribeonnext-onerror)\n  - [unsubscribe](#unsubscribe)\n  - [Observable.merge(iterable)](#observablemergeiterable)\n\n---------------------------------------\n\n\n- ### **[Yaku(executor)](src/yaku.js?source#L49)**\n\n    This class follows the [Promises/A+](https://promisesaplus.com) and\n    [ES6](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects) spec\n    with some extra helpers.\n\n    - **<u>param</u>**: `executor` { _Function_ }\n\n        Function object with two arguments resolve, reject.\n        The first argument fulfills the promise, the second argument rejects it.\n        We can call these functions, once our operation is completed.\n\n- ### **[then(onFulfilled, onRejected)](src/yaku.js?source#L97)**\n\n    Appends fulfillment and rejection handlers to the promise,\n    and returns a new promise resolving to the return value of the called handler.\n\n    - **<u>param</u>**: `onFulfilled` { _Function_ }\n\n        Optional. Called when the Promise is resolved.\n\n    - **<u>param</u>**: `onRejected` { _Function_ }\n\n        Optional. Called when the Promise is rejected.\n\n    - **<u>return</u>**: { _Yaku_ }\n\n        It will return a new Yaku which will resolve or reject after\n\n    - **<u>example</u>**:\n\n        the current Promise.\n        ```js\n        var Promise = require('yaku');\n        var p = Promise.resolve(10);\n\n        p.then((v) => {\n            console.log(v);\n        });\n        ```\n\n- ### **[catch(onRejected)](src/yaku.js?source#L124)**\n\n    The `catch()` method returns a Promise and deals with rejected cases only.\n    It behaves the same as calling `Promise.prototype.then(undefined, onRejected)`.\n\n    - **<u>param</u>**: `onRejected` { _Function_ }\n\n        A Function called when the Promise is rejected.\n        This function has one argument, the rejection reason.\n\n    - **<u>return</u>**: { _Yaku_ }\n\n        A Promise that deals with rejected cases only.\n\n    - **<u>example</u>**:\n\n        ```js\n        var Promise = require('yaku');\n        var p = Promise.reject(new Error(\"ERR\"));\n\n        p['catch']((v) => {\n            console.log(v);\n        });\n        ```\n\n- ### **[Yaku.resolve(value)](src/yaku.js?source#L151)**\n\n    The `Promise.resolve(value)` method returns a Promise object that is resolved with the given value.\n    If the value is a thenable (i.e. has a then method), the returned promise will \"follow\" that thenable,\n    adopting its eventual state; otherwise the returned promise will be fulfilled with the value.\n\n    - **<u>param</u>**: `value` { _Any_ }\n\n        Argument to be resolved by this Promise.\n        Can also be a Promise or a thenable to resolve.\n\n    - **<u>return</u>**: { _Yaku_ }\n\n    - **<u>example</u>**:\n\n        ```js\n        var Promise = require('yaku');\n        var p = Promise.resolve(10);\n        ```\n\n- ### **[Yaku.reject(reason)](src/yaku.js?source#L165)**\n\n    The `Promise.reject(reason)` method returns a Promise object that is rejected with the given reason.\n\n    - **<u>param</u>**: `reason` { _Any_ }\n\n        Reason why this Promise rejected.\n\n    - **<u>return</u>**: { _Yaku_ }\n\n    - **<u>example</u>**:\n\n        ```js\n        var Promise = require('yaku');\n        var p = Promise.reject(new Error(\"ERR\"));\n        ```\n\n- ### **[Yaku.race(iterable)](src/yaku.js?source#L189)**\n\n    The `Promise.race(iterable)` method returns a promise that resolves or rejects\n    as soon as one of the promises in the iterable resolves or rejects,\n    with the value or reason from that promise.\n\n    - **<u>param</u>**: `iterable` { _iterable_ }\n\n        An iterable object, such as an Array.\n\n    - **<u>return</u>**: { _Yaku_ }\n\n        The race function returns a Promise that is settled\n        the same way as the first passed promise to settle.\n        It resolves or rejects, whichever happens first.\n\n    - **<u>example</u>**:\n\n        ```js\n        var Promise = require('yaku');\n        Promise.race([\n            123,\n            Promise.resolve(0)\n        ])\n        .then((value) => {\n            console.log(value); // => 123\n        });\n        ```\n\n- ### **[Yaku.all(iterable)](src/yaku.js?source#L245)**\n\n    The `Promise.all(iterable)` method returns a promise that resolves when\n    all of the promises in the iterable argument have resolved.\n\n    The result is passed as an array of values from all the promises.\n    If something passed in the iterable array is not a promise,\n    it's converted to one by Promise.resolve. If any of the passed in promises rejects,\n    the all Promise immediately rejects with the value of the promise that rejected,\n    discarding all the other promises whether or not they have resolved.\n\n    - **<u>param</u>**: `iterable` { _iterable_ }\n\n        An iterable object, such as an Array.\n\n    - **<u>return</u>**: { _Yaku_ }\n\n    - **<u>example</u>**:\n\n        ```js\n        var Promise = require('yaku');\n        Promise.all([\n            123,\n            Promise.resolve(0)\n        ])\n        .then((values) => {\n            console.log(values); // => [123, 0]\n        });\n        ```\n\n    - **<u>example</u>**:\n\n        Use with iterable.\n        ```js\n        var Promise = require('yaku');\n        Promise.all((function * () {\n            yield 10;\n            yield new Promise(function (r) { setTimeout(r, 1000, \"OK\") });\n        })())\n        .then((values) => {\n            console.log(values); // => [123, 0]\n        });\n        ```\n\n- ### **[Yaku.Symbol](src/yaku.js?source#L281)**\n\n    The ES6 Symbol object that Yaku should use, by default it will use the\n    global one.\n\n    - **<u>type</u>**: { _Object_ }\n\n    - **<u>example</u>**:\n\n        ```js\n        var core = require(\"core-js/library\");\n        var Promise = require(\"yaku\");\n        Promise.Symbol = core.Symbol;\n        ```\n\n- ### **[Yaku.speciesConstructor(O, defaultConstructor)](src/yaku.js?source#L296)**\n\n    Use this api to custom the species behavior.\n    https://tc39.github.io/ecma262/#sec-speciesconstructor\n\n    - **<u>param</u>**: `O` { _Any_ }\n\n        The current this object.\n\n    - **<u>param</u>**: `defaultConstructor` { _Function_ }\n\n- ### **[Yaku.unhandledRejection(reason, p)](src/yaku.js?source#L322)**\n\n    Catch all possibly unhandled rejections. If you want to use specific\n    format to display the error stack, overwrite it.\n    If it is set, auto `console.error` unhandled rejection will be disabled.\n\n    - **<u>param</u>**: `reason` { _Any_ }\n\n        The rejection reason.\n\n    - **<u>param</u>**: `p` { _Yaku_ }\n\n        The promise that was rejected.\n\n    - **<u>example</u>**:\n\n        ```js\n        var Promise = require('yaku');\n        Promise.onUnhandledRejection = (reason) => {\n            console.error(reason);\n        };\n\n        // The console will log an unhandled rejection error message.\n        Promise.reject('my reason');\n\n        // The below won't log the unhandled rejection error message.\n        Promise.reject('v').catch(() => {});\n        ```\n\n- ### **[Yaku.rejectionHandled(reason, p)](src/yaku.js?source#L337)**\n\n    Emitted whenever a Promise was rejected and an error handler was\n    attached to it (for example with `.catch()`) later than after an event loop turn.\n\n    - **<u>param</u>**: `reason` { _Any_ }\n\n        The rejection reason.\n\n    - **<u>param</u>**: `p` { _Yaku_ }\n\n        The promise that was rejected.\n\n- ### **[Yaku.enableLongStackTrace](src/yaku.js?source#L355)**\n\n    It is used to enable the long stack trace.\n    Once it is enabled, it can't be reverted.\n    While it is very helpful in development and testing environments,\n    it is not recommended to use it in production. It will slow down\n    application and eat up memory.\n    It will add an extra property `longStack` to the Error object.\n\n    - **<u>example</u>**:\n\n        ```js\n        var Promise = require('yaku');\n        Promise.enableLongStackTrace();\n        Promise.reject(new Error(\"err\")).catch((err) => {\n            console.log(err.longStack);\n        });\n        ```\n\n- ### **[Yaku.nextTick](src/yaku.js?source#L378)**\n\n    Only Node has `process.nextTick` function. For browser there are\n    so many ways to polyfill it. Yaku won't do it for you, instead you\n    can choose what you prefer. For example, this project\n    [setImmediate](https://github.com/YuzuJS/setImmediate).\n    By default, Yaku will use `process.nextTick` on Node, `setTimeout` on browser.\n\n    - **<u>type</u>**: { _Function_ }\n\n    - **<u>example</u>**:\n\n        ```js\n        var Promise = require('yaku');\n        Promise.nextTick = fn => window.setImmediate(fn);\n        ```\n\n    - **<u>example</u>**:\n\n        You can even use sync resolution if you really know what you are doing.\n        ```js\n        var Promise = require('yaku');\n        Promise.nextTick = fn => fn();\n        ```\n\n\n\n\n\n# Utils\n\nIt's a bundle of all the following functions. You can require them all with `var yutils = require(\"yaku/lib/utils\")`,\nor require them separately like `require(\"yaku/lib/flow\")`. If you want to use it in the browser, you have to use `browserify` or `webpack`. You can even use another Promise lib, such as:\n\n```js\nrequire(\"yaku/lib/_\").Promise = require(\"bluebird\");\nvar source = require(\"yaku/lib/source\");\n\n// now \"source\" use bluebird instead of yaku.\n```\n\n- ### **[all(limit, list)](src/utils.js?source#L46)**\n\n    A function that helps run functions under a concurrent limitation.\n    To run functions sequentially, use `yaku/lib/flow`.\n\n    - **<u>param</u>**: `limit` { _Int_ }\n\n        The max task to run at a time. It's optional.\n        Default is `Infinity`.\n\n    - **<u>param</u>**: `list` { _Iterable_ }\n\n        Any [iterable](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Iteration_protocols) object. It should be a lazy iteralbe object,\n        don't pass in a normal Array with promises.\n\n    - **<u>return</u>**: { _Promise_ }\n\n    - **<u>example</u>**:\n\n        ```js\n        var kit = require('nokit');\n        var all = require('yaku/lib/all');\n\n        var urls = [\n            'http://a.com',\n            'http://b.com',\n            'http://c.com',\n            'http://d.com'\n        ];\n        var tasks = function * () {\n            var i = 0;\n            yield kit.request(url[i++]);\n            yield kit.request(url[i++]);\n            yield kit.request(url[i++]);\n            yield kit.request(url[i++]);\n        }();\n\n        all(tasks).then(() => kit.log('all done!'));\n\n        all(2, tasks).then(() => kit.log('max concurrent limit is 2'));\n\n        all(3, { next: () => {\n            var url = urls.pop();\n            return {\n                 done: !url,\n                 value: url && kit.request(url)\n            };\n        } })\n        .then(() => kit.log('all done!'));\n        ```\n\n- ### **[any(iterable)](src/utils.js?source#L65)**\n\n    Similar with the `Promise.race`, but only rejects when every entry rejects.\n\n    - **<u>param</u>**: `iterable` { _iterable_ }\n\n        An iterable object, such as an Array.\n\n    - **<u>return</u>**: { _Yaku_ }\n\n    - **<u>example</u>**:\n\n        ```js\n        var any = require('yaku/lib/any');\n        any([\n            123,\n            Promise.resolve(0),\n            Promise.reject(new Error(\"ERR\"))\n        ])\n        .then((value) => {\n            console.log(value); // => 123\n        });\n        ```\n\n- ### **[async(gen)](src/utils.js?source#L85)**\n\n    Generator based async/await wrapper.\n\n    - **<u>param</u>**: `gen` { _Generator_ }\n\n        A generator function\n\n    - **<u>return</u>**: { _Yaku_ }\n\n    - **<u>example</u>**:\n\n        ```js\n        var async = require('yaku/lib/async');\n        var sleep = require('yaku/lib/sleep');\n\n        var fn = async(function * () {\n            return yield sleep(1000, 'ok');\n        });\n\n        fn().then(function (v) {\n            console.log(v);\n        });\n        ```\n\n- ### **[callbackify(fn, self)](src/utils.js?source#L94)**\n\n    If a function returns promise, convert it to\n    node callback style function.\n\n    - **<u>param</u>**: `fn` { _Function_ }\n\n    - **<u>param</u>**: `self` { _Any_ }\n\n        The `this` to bind to the fn.\n\n    - **<u>return</u>**: { _Function_ }\n\n- ### **[Deferred](src/utils.js?source#L100)**\n\n    **deprecate** Create a `jQuery.Deferred` like object.\n    It will cause some buggy problems, please don't use it.\n\n- ### **[flow(list)](src/utils.js?source#L158)**\n\n    Creates a function that is the composition of the provided functions.\n    See `yaku/lib/async`, if you need concurrent support.\n\n    - **<u>param</u>**: `list` { _Iterable_ }\n\n        Any [iterable](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Iteration_protocols) object. It should be a lazy iteralbe object,\n        don't pass in a normal Array with promises.\n\n    - **<u>return</u>**: { _Function_ }\n\n        `(val) -> Promise` A function that will return a promise.\n\n    - **<u>example</u>**:\n\n        It helps to decouple sequential pipeline code logic.\n        ```js\n        var kit = require('nokit');\n        var flow = require('yaku/lib/flow');\n\n        function createUrl (name) {\n            return \"http://test.com/\" + name;\n        }\n\n        function curl (url) {\n            return kit.request(url).then((body) => {\n                kit.log('get');\n                return body;\n            });\n        }\n\n        function save (str) {\n            kit.outputFile('a.txt', str).then(() => {\n                kit.log('saved');\n            });\n        }\n\n        var download = flow(createUrl, curl, save);\n        // same as \"download = flow([createUrl, curl, save])\"\n\n        download('home');\n        ```\n\n    - **<u>example</u>**:\n\n        Walk through first link of each page.\n        ```js\n        var kit = require('nokit');\n        var flow = require('yaku/lib/flow');\n\n        var list = [];\n        function iter (url) {\n            return {\n                done: !url,\n                value: url && kit.request(url).then((body) => {\n                    list.push(body);\n                    var m = body.match(/href=\"(.+?)\"/);\n                    if (m) return m[0];\n                });\n            };\n        }\n\n        var walker = flow(iter);\n        walker('test.com');\n        ```\n\n- ### **[guard(type, onRejected)](src/utils.js?source#L187)**\n\n    Enable a helper to catch specific error type.\n    It will be directly attach to the prototype of the promise.\n\n    - **<u>param</u>**: `type` { _class_ }\n\n    - **<u>param</u>**: `onRejected` { _Function_ }\n\n    - **<u>return</u>**: { _Promise_ }\n\n        ```js\n        var Promise = require('yaku');\n        require('yaku/lib/guard');\n\n        class AnError extends Error {\n        }\n\n        Promise.reject(new AnError('hey'))\n        .guard(AnError, (err) => {\n             // only log AnError type\n             console.log(err);\n        })\n        .then(() => {\n             console.log('done');\n        })\n        .guard(Error, (err) => {\n             // log all error type\n             console.log(err)\n        });\n        ```\n\n- ### **[if(cond, trueFn, falseFn)](src/utils.js?source#L207)**\n\n    if-else helper\n\n    - **<u>param</u>**: `cond` { _Promise_ }\n\n    - **<u>param</u>**: `trueFn` { _Function_ }\n\n    - **<u>param</u>**: `falseFn` { _Function_ }\n\n    - **<u>return</u>**: { _Promise_ }\n\n    - **<u>example</u>**:\n\n        ```js\n        var Promise = require('yaku');\n        var yutils = require('yaku/lib/utils');\n\n        yutils.if(Promise.resolve(false), () => {\n            // true\n        }, () => {\n            // false\n        })\n        ```\n\n- ### **[isPromise(obj)](src/utils.js?source#L215)**\n\n    **deprecate** Check if an object is a promise-like object.\n    Don't use it to coercive a value to Promise, instead use `Promise.resolve`.\n\n    - **<u>param</u>**: `obj` { _Any_ }\n\n    - **<u>return</u>**: { _Boolean_ }\n\n- ### **[never()](src/utils.js?source#L221)**\n\n    Create a promise that never ends.\n\n    - **<u>return</u>**: { _Promise_ }\n\n        A promise that will end the current pipeline.\n\n- ### **[promisify(fn, self)](src/utils.js?source#L250)**\n\n    Convert a node callback style function to a function that returns\n    promise when the last callback is not supplied.\n\n    - **<u>param</u>**: `fn` { _Function_ }\n\n    - **<u>param</u>**: `self` { _Any_ }\n\n        The `this` to bind to the fn.\n\n    - **<u>return</u>**: { _Function_ }\n\n    - **<u>example</u>**:\n\n        ```js\n        var promisify = require('yaku/lib/promisify');\n        function foo (val, cb) {\n            setTimeout(() => {\n                cb(null, val + 1);\n            });\n        }\n\n        var bar = promisify(foo);\n\n        bar(0).then((val) => {\n            console.log val // output => 1\n        });\n\n        // It also supports the callback style.\n        bar(0, (err, val) => {\n            console.log(val); // output => 1\n        });\n        ```\n\n- ### **[sleep(time, val)](src/utils.js?source#L263)**\n\n    Create a promise that will wait for a while before resolution.\n\n    - **<u>param</u>**: `time` { _Integer_ }\n\n        The unit is millisecond.\n\n    - **<u>param</u>**: `val` { _Any_ }\n\n        What the value this promise will resolve.\n\n    - **<u>return</u>**: { _Promise_ }\n\n    - **<u>example</u>**:\n\n        ```js\n        var sleep = require('yaku/lib/sleep');\n        sleep(1000).then(() => console.log('after one second'));\n        ```\n\n- ### **[Observable](src/utils.js?source#L269)**\n\n    Read the `Observable` section.\n\n    - **<u>type</u>**: { _Function_ }\n\n- ### **[retry(countdown, span, fn, this)](src/utils.js?source#L319)**\n\n    Retry a function until it resolves before a mount of times, or reject with all\n    the error states.\n\n    - **<u>version_added</u>**:\n\n        v0.7.10\n\n    - **<u>param</u>**: `countdown` { _Number | Function_ }\n\n        How many times to retry before rejection.\n\n    - **<u>param</u>**: `span` { _Number_ }\n\n        Optional. How long to wait before each retry in millisecond.\n        When it's a function `(errs) => Boolean | Promise.resolve(Boolean)`,\n        you can use it to create complex countdown logic,\n        it can even return a promise to create async countdown logic.\n\n    - **<u>param</u>**: `fn` { _Function_ }\n\n        The function can return a promise or not.\n\n    - **<u>param</u>**: `this` { _Any_ }\n\n        Optional. The context to call the function.\n\n    - **<u>return</u>**: { _Function_ }\n\n        The wrapped function. The function will reject an array\n        of reasons that throwed by each try.\n\n    - **<u>example</u>**:\n\n        Retry 3 times before rejection, wait 1 second before each retry.\n        ```js\n        var retry = require('yaku/lib/retry');\n        var { request } = require('nokit');\n\n        retry(3, 1000, request)('http://test.com').then(\n           (body) => console.log(body),\n           (errs) => console.error(errs)\n        );\n        ```\n\n    - **<u>example</u>**:\n\n        Here a more complex retry usage, it shows an random exponential backoff algorithm to\n        wait and retry again, which means the 10th attempt may take 10 minutes to happen.\n        ```js\n        var retry = require('yaku/lib/retry');\n        var sleep = require('yaku/lib/sleep');\n        var { request } = require('nokit');\n\n        function countdown (retries) {\n           var attempt = 0;\n           return async () => {\n                var r = Math.random() * Math.pow(2, attempt) * 1000;\n                var t = Math.min(r, 1000 * 60 * 10);\n                await sleep(t);\n                return attempt++ < retries;\n           };\n        }\n\n        retry(countdown(10), request)('http://test.com').then(\n           (body) => console.log(body),\n           (errs) => console.error(errs)\n        );\n        ```\n\n- ### **[throw(err)](src/utils.js?source#L333)**\n\n    Throw an error to break the program.\n\n    - **<u>param</u>**: `err` { _Any_ }\n\n    - **<u>example</u>**:\n\n        ```js\n        var ythrow = require('yaku/lib/throw');\n        Promise.resolve().then(() => {\n            // This error won't be caught by promise.\n            ythrow('break the program!');\n        });\n        ```\n\n\n\n\n# Observable\n\n- ### **[Observable(executor)](src/Observable.js?source#L60)**\n\n    Create a composable observable object.\n    Promise can't resolve multiple times, this class makes it possible, so\n    that you can easily map, filter and even back pressure events in a promise way.\n    For live example: [Double Click Demo](https://jsbin.com/niwuti/edit?html,js,output).\n\n    - **<u>version_added</u>**:\n\n        v0.7.2\n\n    - **<u>param</u>**: `executor` { _Function_ }\n\n        `(next) ->` It's optional.\n\n    - **<u>return</u>**: { _Observable_ }\n\n    - **<u>example</u>**:\n\n        ```js\n        var Observable = require(\"yaku/lib/Observable\");\n        var linear = new Observable();\n\n        var x = 0;\n        setInterval(linear.next, 1000, x++);\n\n        // Wait for 2 sec then emit the next value.\n        var quad = linear.subscribe(async x => {\n            await sleep(2000);\n            return x * x;\n        });\n\n        var another = linear.subscribe(x => -x);\n\n        quad.subscribe(\n            value => { console.log(value); },\n            reason => { console.error(reason); }\n        );\n\n        // Emit error\n        linear.error(new Error(\"reason\"));\n\n        // Unsubscribe an observable.\n        quad.unsubscribe();\n\n        // Unsubscribe all subscribers.\n        linear.subscribers = [];\n        ```\n\n    - **<u>example</u>**:\n\n        Use it with DOM.\n        ```js\n        var filter = fn => v => fn(v) ? v : new Promise(() => {});\n\n        var keyup = new Observable((next) => {\n            document.querySelector('input').onkeyup = next;\n        });\n\n        var keyupText = keyup.subscribe(e => e.target.value);\n\n        // Now we only get the input when the text length is greater than 3.\n        var keyupTextGT3 = keyupText.subscribe(filter(text => text.length > 3));\n\n        keyupTextGT3.subscribe(v => console.log(v));\n        ```\n\n- ### **[next(value)](src/Observable.js?source#L77)**\n\n    Emit a value.\n\n    - **<u>param</u>**: `value` { _Any_ }\n\n        so that the event will go to `onError` callback.\n\n- ### **[error(value)](src/Observable.js?source#L83)**\n\n    Emit an error.\n\n    - **<u>param</u>**: `value` { _Any_ }\n\n- ### **[publisher](src/Observable.js?source#L89)**\n\n    The publisher observable of this.\n\n    - **<u>type</u>**: { _Observable_ }\n\n- ### **[subscribers](src/Observable.js?source#L95)**\n\n    All the subscribers subscribed this observable.\n\n    - **<u>type</u>**: { _Array_ }\n\n- ### **[subscribe(onNext, onError)](src/Observable.js?source#L103)**\n\n    It will create a new Observable, like promise.\n\n    - **<u>param</u>**: `onNext` { _Function_ }\n\n    - **<u>param</u>**: `onError` { _Function_ }\n\n    - **<u>return</u>**: { _Observable_ }\n\n- ### **[unsubscribe](src/Observable.js?source#L118)**\n\n    Unsubscribe this.\n\n- ### **[Observable.merge(iterable)](src/Observable.js?source#L178)**\n\n    Merge multiple observables into one.\n\n    - **<u>version_added</u>**:\n\n        0.9.6\n\n    - **<u>param</u>**: `iterable` { _Iterable_ }\n\n    - **<u>return</u>**: { _Observable_ }\n\n    - **<u>example</u>**:\n\n        ```js\n        var Observable = require(\"yaku/lib/Observable\");\n        var sleep = require(\"yaku/lib/sleep\");\n\n        var src = new Observable(next => setInterval(next, 1000, 0));\n\n        var a = src.subscribe(v => v + 1; });\n        var b = src.subscribe((v) => sleep(10, v + 2));\n\n        var out = Observable.merge([a, b]);\n\n        out.subscribe((v) => {\n            console.log(v);\n        })\n        ```\n\n\n\n\n\n# Unit Test\n\nThis project use [promises-aplus-tests][] to test the compliance of Promises/A+ specification. There are about 900 test cases.\n\nUse `npm run no -- test` to run the unit test against yaku.\n\n## Test other libs\n\n### basic test\n\nTo test `bluebird`: `npm run no -- test-basic --shim bluebird`\n\nThe `bluebird` can be replaced with other lib, see the `test/getPromise.js` for which libs are supported.\n\n### aplus test\n\nTo test `bluebird`: `npm run no -- test-aplus --shim bluebird`\n\nThe `bluebird` can be replaced with other lib, see the `test/getPromise.js` for which libs are supported.\n\n### es6 test\n\nTo test `bluebird`: `npm run no -- test-es6 --shim bluebird`\n\nThe `bluebird` can be replaced with other lib, see the `test/getPromise.js` for which libs are supported.\n\n\n# Benchmark\n\nUse `npm run no -- benchmark` to run the benchmark.\n\n## async/await generator wrapper\n\n```\nNode v5.6.0\nOS   darwin\nArch x64\nCPU  Intel(R) Core(TM) i7-4770HQ CPU @ 2.20GHz\n\nyaku: 117ms\nco: 283ms\nbluebird: 643ms\n```\n\n# Contribution\n\nOther than use `gulp`, all my projects use [nokit][] to deal with automation.\nRun `npm run no -- -h` to print all the tasks that you can use.\n\n\n\n[docs/lazyTree.md]: docs/lazyTree.md\n[docs/debugHelperComparison.md]: docs/debugHelperComparison.md\n[Bluebird]: https://github.com/petkaantonov/bluebird\n[ES6-promise]: https://github.com/jakearchibald/es6-promise\n[core-js tests]: https://github.com/ysmood/core-js/tree/promise-yaku\n[native]: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects\n[q]: https://github.com/kriskowal/q\n[my-promise]: https://github.com/hax/my-promise\n[core-js]: https://github.com/zloirock/core-js\n[yaku]: https://github.com/ysmood/yaku\n[yaku.core]: https://github.com/ysmood/yaku\n[es6-shim]: https://github.com/paulmillr/es6-shim\n[release page]: https://github.com/ysmood/yaku/releases\n[docs/minPromiseAplus.js]: docs/minPromiseAplus.js\n[promises-aplus-tests]: https://github.com/promises-aplus/promises-tests\n[promises-es6-tests]: https://github.com/promises-es6/promises-es6\n[longjohn]: https://github.com/mattinsler/longjohn\n[crhome-lst]: http://www.html5rocks.com/en/tutorials/developertools/async-call-stack\n[Browserify]: http://browserify.org\n[Webpack]: http://webpack.github.io/\n[nokit]: https://github.com/ysmood/nokit\n[nofile.js]: nofile.js",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2015 Yad Smood\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/yaku/-/yaku-0.16.7.tgz#1d195c78aa9b5bf8479c895b9504fd4f0847984e",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/yaku/-/yaku-0.16.7.tgz",
    "hash": "1d195c78aa9b5bf8479c895b9504fd4f0847984e",
    "integrity": "sha1-HRlceKqbW/hHnIlblQT9TwhHmE4=",
    "registry": "npm",
    "packageName": "yaku",
    "cacheIntegrity": "sha512-Syu3IB3rZvKvYk7yTiyl1bo/jiEFaaStrgv1V2TIJTqYPStSMQVO8EQjg/z+DRzLq/4LIIharNT3iH1hylEIRw== sha1-HRlceKqbW/hHnIlblQT9TwhHmE4="
  },
  "registry": "npm",
  "hash": "1d195c78aa9b5bf8479c895b9504fd4f0847984e"
}