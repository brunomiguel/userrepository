/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import type {Config} from '@jest/types';
import type {RawSourceMap} from 'source-map';
import type {TransformTypes} from '@jest/types';

export declare interface AsyncTransformer<OptionType = unknown> {
  /**
   * Indicates if the transformer is capable of instrumenting the code for code coverage.
   *
   * If V8 coverage is _not_ active, and this is `true`, Jest will assume the code is instrumented.
   * If V8 coverage is _not_ active, and this is `false`. Jest will instrument the code returned by this transformer using Babel.
   */
  canInstrument?: boolean;
  createTransformer?: (options?: OptionType) => AsyncTransformer<OptionType>;
  getCacheKey?: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<OptionType>,
  ) => string;
  getCacheKeyAsync?: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<OptionType>,
  ) => Promise<string>;
  process?: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<OptionType>,
  ) => TransformedSource;
  processAsync: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<OptionType>,
  ) => Promise<TransformedSource>;
}

export declare interface CallerTransformOptions {
  supportsDynamicImport: boolean;
  supportsExportNamespaceFrom: boolean;
  supportsStaticESM: boolean;
  supportsTopLevelAwait: boolean;
}

export declare function createScriptTransformer(
  config: Config.ProjectConfig,
  cacheFS?: StringMap,
): Promise<ScriptTransformer>;

export declare function createTranspilingRequire(
  config: Config.ProjectConfig,
): Promise<
  <TModuleType = unknown>(
    resolverPath: string,
    applyInteropRequireDefault?: boolean,
  ) => Promise<TModuleType>
>;

declare interface ErrorWithCodeFrame extends Error {
  codeFrame?: string;
}

declare interface FixedRawSourceMap extends Omit<RawSourceMap, 'version'> {
  version: number;
}

export declare function handlePotentialSyntaxError(
  e: ErrorWithCodeFrame,
): ErrorWithCodeFrame;

declare interface ReducedTransformOptions extends CallerTransformOptions {
  instrument: boolean;
}

declare interface RequireAndTranspileModuleOptions
  extends ReducedTransformOptions {
  applyInteropRequireDefault: boolean;
}

export declare type ScriptTransformer = ScriptTransformer_2;

declare class ScriptTransformer_2 {
  private readonly _config;
  private readonly _cacheFS;
  private readonly _cache;
  private readonly _transformCache;
  private _transformsAreLoaded;
  constructor(_config: Config.ProjectConfig, _cacheFS: StringMap);
  private _buildCacheKeyFromFileInfo;
  private _getCacheKey;
  private _getCacheKeyAsync;
  private _createFolderFromCacheKey;
  private _getFileCachePath;
  private _getFileCachePathAsync;
  private _getTransformPath;
  loadTransformers(): Promise<void>;
  private _getTransformer;
  private _instrumentFile;
  private _buildTransformResult;
  transformSource(
    filepath: string,
    content: string,
    options: ReducedTransformOptions,
  ): TransformResult;
  transformSourceAsync(
    filepath: string,
    content: string,
    options: ReducedTransformOptions,
  ): Promise<TransformResult>;
  private _transformAndBuildScriptAsync;
  private _transformAndBuildScript;
  transformAsync(
    filename: string,
    options: TransformationOptions,
    fileSource?: string,
  ): Promise<TransformResult>;
  transform(
    filename: string,
    options: TransformationOptions,
    fileSource?: string,
  ): TransformResult;
  transformJson(
    filename: string,
    options: TransformationOptions,
    fileSource: string,
  ): string;
  requireAndTranspileModule<ModuleType = unknown>(
    moduleName: string,
    callback?: (module: ModuleType) => void | Promise<void>,
    options?: RequireAndTranspileModuleOptions,
  ): Promise<ModuleType>;
  shouldTransform(filename: string): boolean;
}

export declare function shouldInstrument(
  filename: string,
  options: ShouldInstrumentOptions,
  config: Config.ProjectConfig,
): boolean;

export declare interface ShouldInstrumentOptions
  extends Pick<
    Config.GlobalConfig,
    | 'collectCoverage'
    | 'collectCoverageFrom'
    | 'collectCoverageOnlyFrom'
    | 'coverageProvider'
  > {
  changedFiles?: Set<string>;
  sourcesRelatedToTestsInChangedFiles?: Set<string>;
}

declare type StringMap = Map<string, string>;

export declare interface SyncTransformer<OptionType = unknown> {
  /**
   * Indicates if the transformer is capable of instrumenting the code for code coverage.
   *
   * If V8 coverage is _not_ active, and this is `true`, Jest will assume the code is instrumented.
   * If V8 coverage is _not_ active, and this is `false`. Jest will instrument the code returned by this transformer using Babel.
   */
  canInstrument?: boolean;
  createTransformer?: (options?: OptionType) => SyncTransformer<OptionType>;
  getCacheKey?: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<OptionType>,
  ) => string;
  getCacheKeyAsync?: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<OptionType>,
  ) => Promise<string>;
  process: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<OptionType>,
  ) => TransformedSource;
  processAsync?: (
    sourceText: string,
    sourcePath: string,
    options: TransformOptions<OptionType>,
  ) => Promise<TransformedSource>;
}

export declare interface TransformationOptions
  extends ShouldInstrumentOptions,
    CallerTransformOptions {
  isInternalModule?: boolean;
}

export declare type TransformedSource =
  | {
      code: string;
      map?: FixedRawSourceMap | string | null;
    }
  | string;

declare type Transformer_2<OptionType = unknown> =
  | SyncTransformer<OptionType>
  | AsyncTransformer<OptionType>;
export {Transformer_2 as Transformer};

export declare interface TransformOptions<OptionType = unknown>
  extends ReducedTransformOptions {
  /** a cached file system which is used in jest-runtime - useful to improve performance */
  cacheFS: StringMap;
  config: Config.ProjectConfig;
  /** A stringified version of the configuration - useful in cache busting */
  configString: string;
  /** the options passed through Jest's config by the user */
  transformerConfig: OptionType;
}

export declare type TransformResult = TransformTypes.TransformResult;

export {};
