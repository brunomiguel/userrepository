{
  "manifest": {
    "name": "@humanwhocodes/object-schema",
    "version": "1.2.0",
    "description": "An object schema merger/validator",
    "main": "src/index.js",
    "scripts": {
      "test": "mocha tests/"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/humanwhocodes/object-schema.git"
    },
    "keywords": [
      "object",
      "validation",
      "schema",
      "merge"
    ],
    "author": {
      "name": "Nicholas C. Zakas"
    },
    "license": "BSD-3-Clause",
    "bugs": {
      "url": "https://github.com/humanwhocodes/object-schema/issues"
    },
    "homepage": "https://github.com/humanwhocodes/object-schema#readme",
    "devDependencies": {
      "chai": "^4.2.0",
      "eslint": "^5.13.0",
      "mocha": "^5.2.0"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-@humanwhocodes-object-schema-1.2.0-integrity/node_modules/@humanwhocodes/object-schema/package.json",
    "readmeFilename": "README.md",
    "readme": "# JavaScript ObjectSchema Package\n\nby [Nicholas C. Zakas](https://humanwhocodes.com)\n\nIf you find this useful, please consider supporting my work with a [donation](https://humanwhocodes.com/donate).\n\n## Overview\n\nA JavaScript object merge/validation utility where you can define a different merge and validation strategy for each key. This is helpful when you need to validate complex data structures and then merge them in a way that is more complex than `Object.assign()`.\n\n## Installation\n\nYou can install using either npm:\n\n```\nnpm install @humanwhocodes/object-schema\n```\n\nOr Yarn:\n\n```\nyarn add @humanwhocodes/object-schema\n```\n\n## Usage\n\nUse CommonJS to get access to the `ObjectSchema` constructor:\n\n```js\nconst { ObjectSchema } = require(\"@humanwhocodes/object-schema\");\n\nconst schema = new ObjectSchema({\n\n    // define a definition for the \"downloads\" key\n    downloads: {\n        required: true,\n        merge(value1, value2) {\n            return value1 + value2;\n        },\n        validate(value) {\n            if (typeof value !== \"number\") {\n                throw new Error(\"Expected downloads to be a number.\");\n            }\n        }\n    },\n\n    // define a strategy for the \"versions\" key\n    version: {\n        required: true,\n        merge(value1, value2) {\n            return value1.concat(value2);\n        },\n        validate(value) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"Expected versions to be an array.\");\n            }\n        }\n    }\n});\n\nconst record1 = {\n    downloads: 25,\n    versions: [\n        \"v1.0.0\",\n        \"v1.1.0\",\n        \"v1.2.0\"\n    ]\n};\n\nconst record2 = {\n    downloads: 125,\n    versions: [\n        \"v2.0.0\",\n        \"v2.1.0\",\n        \"v3.0.0\"\n    ]\n};\n\n// make sure the records are valid\nschema.validate(record1);\nschema.validate(record2);\n\n// merge together (schema.merge() accepts any number of objects)\nconst result = schema.merge(record1, record2);\n\n// result looks like this:\n\nconst result = {\n    downloads: 75,\n    versions: [\n        \"v1.0.0\",\n        \"v1.1.0\",\n        \"v1.2.0\",\n        \"v2.0.0\",\n        \"v2.1.0\",\n        \"v3.0.0\"\n    ]\n};\n```\n\n## Tips and Tricks\n\n### Named merge strategies\n\nInstead of specifying a `merge()` method, you can specify one of the following strings to use a default merge strategy:\n\n* `\"assign\"` - use `Object.assign()` to merge the two values into one object.\n* `\"overwrite\"` - the second value always replaces the first.\n* `\"replace\"` - the second value replaces the first if the second is not `undefined`.\n\nFor example:\n\n```js\nconst schema = new ObjectSchema({\n    name: {\n        merge: \"replace\",\n        validate() {}\n    }\n});\n```\n\n### Named validation strategies\n\nInstead of specifying a `validate()` method, you can specify one of the following strings to use a default validation strategy:\n\n* `\"array\"` - value must be an array.\n* `\"boolean\"` - value must be a boolean.\n* `\"number\"` - value must be a number.\n* `\"object\"` - value must be an object.\n* `\"object?\"` - value must be an object or null.\n* `\"string\"` - value must be a string.\n* `\"string!\"` - value must be a non-empty string.\n\nFor example:\n\n```js\nconst schema = new ObjectSchema({\n    name: {\n        merge: \"replace\",\n        validate: \"string\"\n    }\n});\n```\n\n### Subschemas\n\nIf you are defining a key that is, itself, an object, you can simplify the process by using a subschema. Instead of defining `merge()` and `validate()`, assign a `schema` key that contains a schema definition, like this:\n\n```js\nconst schema = new ObjectSchema({\n    name: {\n        schema: {\n            first: {\n                merge: \"replace\",\n                validate: \"string\"\n            },\n            last: {\n                merge: \"replace\",\n                validate: \"string\"\n            }\n        }\n    }\n});\n\nschema.validate({\n    name: {\n        first: \"n\",\n        last: \"z\"\n    }\n});\n```\n\n### Remove Keys During Merge\n\nIf the merge strategy for a key returns `undefined`, then the key will not appear in the final object. For example:\n\n```js\nconst schema = new ObjectSchema({\n    date: {\n        merge() {\n            return undefined;\n        },\n        validate(value) {\n            Date.parse(value);  // throws an error when invalid\n        }\n    }\n});\n\nconst object1 = { date: \"5/5/2005\" };\nconst object2 = { date: \"6/6/2006\" };\n\nconst result = schema.merge(object1, object2);\n\nconsole.log(\"date\" in result);  // false\n```\n\n### Requiring Another Key Be Present\n\nIf you'd like the presence of one key to require the presence of another key, you can use the `requires` property to specify an array of other properties that any key requires. For example:\n\n```js\nconst schema = new ObjectSchema();\n\nconst schema = new ObjectSchema({\n    date: {\n        merge() {\n            return undefined;\n        },\n        validate(value) {\n            Date.parse(value);  // throws an error when invalid\n        }\n    },\n    time: {\n        requires: [\"date\"],\n        merge(first, second) {\n            return second;\n        },\n        validate(value) {\n            // ...\n        }\n    }\n});\n\n// throws error: Key \"time\" requires keys \"date\"\nschema.validate({\n    time: \"13:45\"\n});\n```\n\nIn this example, even though `date` is an optional key, it is required to be present whenever `time` is present.\n\n## License\n\nBSD 3-Clause\n",
    "licenseText": "BSD 3-Clause License\n\nCopyright (c) 2019, Human Who Codes\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the name of the copyright holder nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-1.2.0.tgz",
    "type": "tarball",
    "reference": "https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-1.2.0.tgz",
    "hash": "",
    "integrity": "sha512-wdppn25U8z/2yiaT6YGquE6X8sSv7hNMWSXYSSU1jGv/yd6XqjXgTDJ8KP4NgjTXfJ3GbRjeeb8RTV7a/VpM+w==",
    "registry": "npm",
    "packageName": "@humanwhocodes/object-schema",
    "cacheIntegrity": "sha512-wdppn25U8z/2yiaT6YGquE6X8sSv7hNMWSXYSSU1jGv/yd6XqjXgTDJ8KP4NgjTXfJ3GbRjeeb8RTV7a/VpM+w== sha1-h956+cIxgm/daKxyWPd8Qp4OX88="
  },
  "registry": "npm",
  "hash": "c1da699f6e54f33ff6ca2693e981aab84e97f2c4afee134c5925d84925358c6bffc9de97aa35e04c327c28fe0d8234d77c9dc66d18de79bf114d5edafd5a4cfb"
}