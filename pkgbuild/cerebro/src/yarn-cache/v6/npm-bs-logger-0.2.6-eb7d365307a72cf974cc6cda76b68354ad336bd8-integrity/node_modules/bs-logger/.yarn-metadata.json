{
  "manifest": {
    "name": "bs-logger",
    "version": "0.2.6",
    "description": "Bare simple logger for NodeJS",
    "author": {
      "name": "Huafu Gandon",
      "email": "huafu.gandon@gmail.com"
    },
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/huafu/bs-logger.git"
    },
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "scripts": {
      "build": "tsc -p tsconfig.build.json",
      "clean": "rimraf dist coverage",
      "typecheck": "tsc -p . --noEmit",
      "lint": "tslint --project tsconfig.json --format stylish",
      "lint:fix": "tslint --fix --project tsconfig.json",
      "test": "jest --coverage",
      "test:watch": "jest --watch",
      "prebuild": "npm run clean",
      "posttest": "npm run typecheck && npm run lint",
      "prepare": "npm run build",
      "prepublishOnly": "npm run test",
      "preversion": "npm test",
      "version": "npm run changelog && git add CHANGELOG.md",
      "postversion": "git push && git push --tags",
      "changelog": "conventional-changelog -p angular -i CHANGELOG.md -s -r 0",
      "commitmsg": "commitlint -E GIT_PARAMS",
      "precommit": "lint-staged",
      "postcommit": "git reset"
    },
    "keywords": [
      "bare simple logger",
      "simple logger",
      "simple",
      "logger",
      "typescript",
      "lib",
      "library"
    ],
    "files": [
      "dist"
    ],
    "devDependencies": {
      "@commitlint/cli": "7.x",
      "@commitlint/config-conventional": "7.x",
      "@types/jest": "23.x",
      "@types/node": "10.x",
      "conventional-changelog-cli": "2.x",
      "husky": "0.x",
      "jest": "23.x",
      "lint-staged": "7.x",
      "prettier": "1.x",
      "rimraf": "2.x",
      "ts-jest": "23.x",
      "tslint": "5.x",
      "tslint-config-prettier": "1.x",
      "tslint-plugin-prettier": "2.x",
      "typescript": "3.x"
    },
    "dependencies": {
      "fast-json-stable-stringify": "2.x"
    },
    "lint-staged": {
      "linters": {
        "*.{ts,tsx}": [
          "tslint --fix",
          "git add"
        ]
      }
    },
    "engines": {
      "node": ">= 6"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-bs-logger-0.2.6-eb7d365307a72cf974cc6cda76b68354ad336bd8-integrity/node_modules/bs-logger/package.json",
    "readmeFilename": "README.md",
    "readme": "<img align=\"right\" src=\"icon.png\"></img>\n\n# B.S. Logger [![Build Status](https://travis-ci.org/huafu/bs-logger.svg?branch=master)](https://travis-ci.org/huafu/bs-logger) [![Coverage Status](https://img.shields.io/coveralls/huafu/bs-logger/master.svg)](https://coveralls.io/github/huafu/bs-logger?branch=master) [![Beerpay](https://beerpay.io/huafu/bs-logger/badge.svg?style=beer-square)](https://beerpay.io/huafu/bs-logger)  [![Beerpay](https://beerpay.io/huafu/bs-logger/make-wish.svg?style=flat-square)](https://beerpay.io/huafu/bs-logger?focus=wish)\n\n**Opinionated bare simple logger for NodeJS (with TypeScript typings)**.\n\nBSLogger has been created after being disapointed not finding a matching logger on the internet. Not that others aren't good, they just did not fit what I was looking for.\n\nHere is what I was looking for (and tried to implemented in BSLogger):\n- light memory usage\n- easily extendable (see `child` method)\n- as few dependencies as possible\n- ability to define all targets in a string (so that `ENV` vars can be used)\n- when using file targets, not re-opening them\n- reasonable defautls:\n  - logs warnings and above to `stderr`\n  - logs JSON to files\n- no overhead if it's not going to log anywhere\n\n## TL,DR:\n\nInstall:\n```sh\nnpm install --save bs-logger\n# or\nyarn add bs-logger\n```\nUse:\n```js\nconst { logger } = require('bs-logger');\n//    or\n// import logger from 'bs-logger';\n//    or\n// import { logger } from 'bs-logger';\n//    as default exports the logger\n\nlogger('foo');\nlogger.debug('bar');\nlogger.warn({foo: 'bar'}, 'dummy', 'other'/*, ...*/);\n```\n\nMore complex example:\n```js\n// env MY_LOG_TARGETS=\"debug.log:trace,stderr:warn%json\"\nimport { createLogger } from 'bs-logger';\nconst logger = createLogger({\n  context: {namespace: 'http'},\n  targets: process.env.MY_LOG_TARGETS,\n  translate: (m) => {\n    if (process.env.NODE_ENV === 'production') {\n      m.context = { ...m.context, secret: null };\n    }\n    return m;\n  },\n});\n// [...]\nlogger.debug({secret: 'xyz'}, 'trying to login')\n// will log into debug.log `trying to login` with secret in the context except in prod\n\nconst login = logger.wrap(function login() {\n  // your login code\n})\n// [...]\nlogin();\n// will log `calling login` with the arguments in context\n```\n\n## Usage\n\n### Creating a logger\n\n#### Root logger\n\nBSLogger exports a global logger lazyly created on first use, but it is advised to create your own using the `createLogger()` helper:\n\n- If you are using it in a library wich is meant to be re-distributed:\n  ```js\n  import { createLogger, LogContexts } 'bs-logger';\n  const logger = createLogger({ [LogContexts.package]: 'my-pacakge' });\n  ```\n\n- If you are using it in an application of your own:\n  ```js\n  import { createLogger, LogContexts } 'bs-logger';\n  const logger = createLogger({ [LogContexts.application]: 'my-app' });\n  ```\n\n#### Child logger\n\nChild loggers extends the context, targets and message translators from their parent. You create a child logger using the `child` method:\n\n```js\nconst childLogger = logger.child({ [LogContexts.namespace]: 'http' })\n// childLogger becomes a new logger\n```\n\n### Logging\n\nAny helper to log within BSLogger is a function which has the same signature as `console.log()`, and also accepts an **optional** first argument being the context. A context is any `object`, with some specific (but optional) properties which we'll see later.\n\n```ts\nlogMethod(message: string, ...args: any[]): void\n  // or\nlogMethod(context: LogContext, message: string, ...args: any[]): void\n```\n\n#### Directly\n\nYou can log using any logger as a function directly (if the logger or its possible parent(s) has not been created with any log level in its context, no level will be attached):\n```js\nimport { createLogger } from 'bs-logger'\nconst logger = createLogger()\n// [...]\nlogger('my message');\n```\n\n#### Using level helpers\n\nBSLogger is aware of 6 log levels (`trace`, `debug`, `info`, `warn`, `error` and `fatal`) but you can create your owns. A log level is basically a number. The higher it is, the more important will be the message. You can find log levels constants in `LogLevels` export:\n```js\nimport { LogLevels } from 'bs-logger';\n\nconst traceLevelValue = LogLevels.trace;\nconst debugLevelValue = LogLevels.debug;\n// etc.\n```\n\nFor each log level listed above, a logger will have a helper method to directly log using this level:\n```js\nimport { createLogger } from 'bs-logger'\nconst logger = createLogger()\n// [...]\nlogger.trace('foo')\nlogger.debug('bar')\n// etc.\n```\n\nThose helpers are the equivalent to\n```js\nlogger({ [LogContexts.logLevel]: level }, 'foo')\n```\n...except that they'll be replaced with an empty function on the first call if their level will not be handled by any target.\n\n### Wrapping functions\n\nEach logger has a `wrap` method which you can use to wrap a function. If there is no matching log target, the `wrap` method will simply return your function, else it'll wrap it in another function of same signature. The wrapper will, before calling your function, log a message with received arguments in the context.\n\n```ts\n// With `F` being the type of your funciton:\nlogger.wrap(func: F): F\n  // or\nlogger.wrap(message: string, func: F): F\n  // or\nlogger.wrap(context: LogContext, messages: string, func: F): F\n```\n\n### Defining target(s)\n\nEach root logger (created using `createLogger` helper) is attached to 0 or more \"target\". A target is responsible of writing a log entry somewhere. It is an object with the following properties:\n\n- **minLevel** `string`: The minimum log level this target's strem writer will be called for\n- **stream** `{ write: (str: string) => void }`: An object with a write function (like node's `stream.Writable`) which will be used to write log entries\n- **format** `(msg: LogMessage) => string`: A formatter which will be used to transform a log entry (message object) into a string\n\n#### Using targets\n\nWhen using the global logger, or if no `targets` specified when creating a logger, calling log methods will output to STDERR anything which has log level higher or equal to `warn`. This can be modified as follow by defineing the `LOG_TARGETS` environment variable or passing the `targets` option to `createLogger`. The `targets` can be an array of `LogTarget` (see above) or a `string` defining a list of one or more targets separated by comma (`,`). A `string` target is composed as follow:\n- The file path, absolute or relative to CWD. It can also be the specials `stdout` or `stderr` strings (case insensitive). When giving a path to a file, if it ends with the plus sign (`+`) the log data will be appended to the file instead of re-creating the file for each run.\n- An optional minimum log level after a colon (`:`). It should be a `number` or the log level name (ie `trace`, `error`, ...).\n- An optional formatter name after a percent sign (`%`). There are 2 included formatter: `json` (used for files by default) and `simple` (used for `stdout` and `stderr` by default). See below to define your own.\n\nExamples:\n- `debug.log%simple,stdout:fatal`\n  - Log everything to `debug.log` file in CWD dir (re-creates the file for each run). Uses the `simple` formatter.\n  - Log only messages with level >= `fatal` to the standard out.\n- `errors.log+:error,debug.log:15`\n  - Log only messages with level >= `error` to `errors.log` file (without re-creating the file at each run).\n  - Log only messages with level >= 15 to `debug.log` file (re-creates the file for each run).\n\n#### Custom formatters\n\nA custom formatter is a function that takes a `LogMessage` object and returns a `string`. It can be registered giving it a name using the `registerLogFormatter` helper:\n\n```js\nimport { registerLogFormatter, createLogger } from 'bs-logger';\nregisterLogFormatter('foo', m => `${m.sequence} ${new Date(m.tim).toLocaleString()} ${m.message}`);\nconst logger = createLogger({\n  targets: 'stdout%foo', // specifying out formatter\n  });\n```\n\n### Testing\n\nThe whole `testing` namespace has useful helpers for using BSLogger while unit testing your product.\n\nIn your tests you would usually prefer not having any logging to happen, or you would like to check what has been logged but without actually logging it to any target.\n\nThe `testing` namespace holds all testing utilities:\n```js\nimport { testing } from 'bs-logger'\n```\n\n- If you use the root logger, here is how to disable its output:\n```js\ntesting.setup()\n```\nand the `logger` (or `default`) export will become a `LoggerMock` instance (see below).\n\n- If you create logger(s) using `createLogger`, when testing use the `testing.createLoggerMock` instead. It accepts the same first argument, with an extra second argument, optional, being the `LogTargetMock` to be used (see below).\n\n#### LoggerMock\n\nLoggers created using the `testing` namespace will have one and only one log target being a `LogTargetMock`, and that target will be set on the `target` extra property of the logger.\n\nHere are the extra properties of `LogTargetMock` which you can then use for testing:\n\n- **messages** `LogMessage[]`: all log message objects which would have normally be logged\n  - **last** `LogMessage`: the last one being logged\n  - **trace** `LogMessage[]`: all log message objects with `trace` level\n    - **last** `LogMessage`: last one with `trace` level\n  - **debug** `LogMessage[]`: all log message objects with `debug` level\n    - **last** `LogMessage`: last one with `debug` level\n  - ...\n- **lines** `string[]`: all formatted log message lines which would have normally be logged\n  - **last** `string`: the last one being logged\n  - **trace** `string[]`: all formatted log message lines with `trace` level\n    - **last** `string`: last one with `trace` level\n  - **debug** `string[]`: all formatted log message lines with `debug` level\n    - **last** `string`: last one with `debug` level\n  - ...\n- **clear** `() => void`: method to clear all log message objects and formatted lines\n- **filteredMessages** `(level: number | null, untilLevel?: number) => LogMessage[]`: method to filter log message objects\n- **filteredLins** `(level: number | null, untilLevel?: number) => string[]`: method to filter formatted log message lines\n\n#### Example\n\nLet's say you have a `logger.js` file in which you create the logger for your app:\n```js\n// file: logger.js\nimport { testing, createLogger, LogContexts } from 'bs-logger';\n\nconst factory = process.env.TEST ? testing.createLoggerMock : createLogger;\n\nexport default factory({ [LogContexts.application]: 'foo' });\n```\n\nIn a test you could:\n```js\nimport logger from './logger';\n// in `fetch(url)` you'd use the logger like `logger.debug({url}, 'GET')` when the request is actually made\nimport fetch from './http';\n\ntest('it should cache request', () => {\n  logger.target.clear();\n  fetch('http://foo.bar/dummy.json');\n  expect(logger.target.messages.length).toBe(1);\n  fetch('http://foo.bar/dummy.json');\n  expect(logger.target.messages.length).toBe(1);\n  // you can also expect on the message:\n  expect(logger.target.messages.last.message).toBe('GET')\n  expect(logger.target.messages.last.context.url).toBe('http://foo.bar/dummy.json')\n  // or (mock target formater prefix the message with `[level:xxx] ` when there is a level)\n  expect(logger.target.lines.last).toBe('[level:20] GET')\n  // or filtering with level:\n  expect(logger.target.lines.debug.last).toBe('[level:20] GET')\n});\n```\n\n## Installing\n\nAdd to your project with `npm`:\n\n```bash\nnpm install --save bs-logger\n```\n\nor with `yarn`:\n\n```bash\nyarn add bs-logger\n```\n\n## Running the tests\n\nYou need to get a copy of the repository to run the tests:\n\n```bash\ngit clone https://github.com/huafu/bs-logger.git\ncd bs-logger\nnpm run test\n```\n\n## Built With\n\n* [TypeScript](https://www.typescriptlang.org/)\n* [ts-jest](https://github.com/kulshekhar/ts-jest)\n\n## Contributing\n\nPull requests welcome!\n\n## Versioning\n\nWe use [SemVer](http://semver.org/) for versioning. For the versions available, see the [tags on this repository](https://github.com/huafu/bs-logger/tags).\n\n## Authors\n\n* **Huafu Gandon** - *Initial work* - [huafu](https://github.com/huafu)\n\nSee also the list of [contributors](https://github.com/huafu/bs-logger/contributors) who participated in this project.\n\n## License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details\n\n## Support on Beerpay\nHey dude! Help me out for a couple of :beers:!\n\n[![Beerpay](https://beerpay.io/huafu/bs-logger/badge.svg?style=beer-square)](https://beerpay.io/huafu/bs-logger)  [![Beerpay](https://beerpay.io/huafu/bs-logger/make-wish.svg?style=flat-square)](https://beerpay.io/huafu/bs-logger?focus=wish)\n",
    "licenseText": "MIT License\n\nCopyright (c) 2018 Huafu Gandon\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/bs-logger/-/bs-logger-0.2.6.tgz#eb7d365307a72cf974cc6cda76b68354ad336bd8",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/bs-logger/-/bs-logger-0.2.6.tgz",
    "hash": "eb7d365307a72cf974cc6cda76b68354ad336bd8",
    "integrity": "sha512-pd8DCoxmbgc7hyPKOvxtqNcjYoOsABPQdcCUjGp3d42VR2CX1ORhk2A87oqqu5R1kk+76nsxZupkmyd+MVtCog==",
    "registry": "npm",
    "packageName": "bs-logger",
    "cacheIntegrity": "sha512-pd8DCoxmbgc7hyPKOvxtqNcjYoOsABPQdcCUjGp3d42VR2CX1ORhk2A87oqqu5R1kk+76nsxZupkmyd+MVtCog== sha1-6302UwenLPl0zGzadraDVK0za9g="
  },
  "registry": "npm",
  "hash": "eb7d365307a72cf974cc6cda76b68354ad336bd8"
}