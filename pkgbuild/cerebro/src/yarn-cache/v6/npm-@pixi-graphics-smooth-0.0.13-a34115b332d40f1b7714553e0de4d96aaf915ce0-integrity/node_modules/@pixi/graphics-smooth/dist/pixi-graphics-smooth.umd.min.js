/* eslint-disable */
this.PIXI=this.PIXI||{},this.PIXI.smooth=this.PIXI.smooth||{},function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@pixi/math"),require("@pixi/core"),require("@pixi/constants"),require("@pixi/graphics"),require("@pixi/utils"),require("@pixi/display")):"function"==typeof define&&define.amd?define(["exports","@pixi/math","@pixi/core","@pixi/constants","@pixi/graphics","@pixi/utils","@pixi/display"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self)._pixi_graphics_smooth={},t.PIXI,t.PIXI,t.PIXI,t.PIXI,t.PIXI.utils,t.PIXI)}(this,(function(t,e,n,i,s,a,r){"use strict";function l(t,e,n=.001){return this===e||Math.abs(t.a-e.a)<n&&Math.abs(t.b-e.b)<n&&Math.abs(t.c-e.c)<n&&Math.abs(t.d-e.d)<n&&Math.abs(t.tx-e.tx)<n&&Math.abs(t.ty-e.ty)<n}class o{constructor(){this.textureIds=[],this.matrices=[],this.lines=[],this.count=0}clear(){for(let t=0;t<this.count;t++)this.textureIds[t]=null,this.matrices[t]=null;this.count=0}add(t,e,n,i,s){const{textureIds:a,matrices:r,lines:o,count:h}=this;for(let s=0;s<h;s++)if(o[2*s]===n&&o[2*s+1]===i&&a[s]===t&&l(r[s],e))return s;return h>=s.maxStyles?-1:(a[h]=t,r[h]=e,o[2*h]=n,o[2*h+1]=i,this.count++,h)}}class h{constructor(){this.texArray=new n.BatchTextureArray,this.styleArray=new o,this.shader=null,this.blend=i.BLEND_MODES.NORMAL,this.start=0,this.size=0,this.TICK=0,this.settings=null,this.data=null}clear(){this.texArray.clear(),this.styleArray.clear(),this.settings=null,this.data=null,this.shader=null}begin(t,e){this.TICK=++n.BaseTexture._globalBatch,this.settings=t,this.shader=e,this.start=0,this.size=0,this.data=null,e&&e.settings&&(this.settings=e.settings)}check(t){return 0===this.size?(this.shader=t,!0):this.shader===t}add(t,n,i,s){const{texArray:a,TICK:r,styleArray:l,settings:o}=this,{baseTexture:h}=t;if(h._batchEnabled!==r&&a.count===o.maxTextures)return-1;const c=h._batchEnabled!==r?a.count:h._batchLocation,u=l.add(c,n||e.Matrix.IDENTITY,i,s,o);return u>=0&&h._batchEnabled!==r&&(h._batchEnabled=r,h._batchLocation=a.count,a.elements[a.count++]=h),u}}class c{constructor(){this.reset()}begin(t,e,n){this.reset(),this.style=t,this.start=e,this.attribStart=n,this.jointEnd=0}end(t,e){this.attribSize=e-this.attribStart,this.size=t-this.start}reset(){this.style=null,this.size=0,this.start=0,this.attribStart=0,this.attribSize=0,this.styleId=-1,this.rgba=0,this.jointEnd=0}}class u{constructor(){this.reset()}toJSON(){return this.copyTo({})}clone(){return this.copyTo(new u)}copyTo(t){return t.color=this.color,t.alpha=this.alpha,t.texture=this.texture,t.matrix=this.matrix,t.shader=this.shader,t.visible=this.visible,t.smooth=this.smooth,t.matrixTex=null,t}packLineWidth(){return 0}reset(){this.color=16777215,this.alpha=1,this.texture=n.Texture.WHITE,this.matrix=null,this.shader=null,this.visible=!1,this.smooth=!1,this.matrixTex=null}destroy(){this.texture=null,this.matrix=null,this.matrixTex=null}getTextureMatrix(){const t=this.texture;return this.matrix?t.frame.width===t.baseTexture.width&&t.frame.height===t.baseTexture.height?this.matrix:(this.matrixTex?this.matrixTex.copyFrom(this.matrix):this.matrixTex=this.matrix.clone(),this.matrixTex.translate(Number(t.frame.x),Number(t.frame.y)),this.matrixTex):null}}t.LINE_SCALE_MODE=void 0,function(t){t.NONE="none";t.NORMAL="normal"}(t.LINE_SCALE_MODE||(t.LINE_SCALE_MODE={}));class d extends u{clone(){return this.copyTo(new d)}copyTo(t){return t.color=this.color,t.alpha=this.alpha,t.texture=this.texture,t.matrix=this.matrix,t.shader=this.shader,t.visible=this.visible,t.width=this.width,t.alignment=this.alignment,t.cap=this.cap,t.join=this.join,t.miterLimit=this.miterLimit,t.scaleMode=this.scaleMode,t}packLineWidth(){return this.scaleMode===t.LINE_SCALE_MODE.NORMAL?this.width:-this.width}reset(){super.reset(),this.smooth=!0,this.color=0,this.width=0,this.alignment=.5,this.cap=s.LINE_CAP.BUTT,this.join=s.LINE_JOIN.MITER,this.miterLimit=10,this.scaleMode=t.LINE_SCALE_MODE.NORMAL}}class p{constructor(){p.prototype.__init.call(this),p.prototype.__init2.call(this),p.prototype.__init3.call(this),p.prototype.__init4.call(this),p.prototype.__init5.call(this)}__init(){this.verts=[]}__init2(){this.joints=[]}__init3(){this.vertexSize=0}__init4(){this.indexSize=0}__init5(){this.closePointEps=1e-4}clear(){this.verts.length=0,this.joints.length=0,this.vertexSize=0,this.indexSize=0}destroy(){this.verts.length=0,this.joints.length=0}}t.JOINT_TYPE=void 0,function(t){t[t.NONE=0]="NONE";t[t.FILL=1]="FILL";t[t.JOINT_BEVEL=4]="JOINT_BEVEL";t[t.JOINT_MITER=8]="JOINT_MITER";t[t.JOINT_ROUND=12]="JOINT_ROUND";t[t.JOINT_CAP_BUTT=16]="JOINT_CAP_BUTT";t[t.JOINT_CAP_SQUARE=18]="JOINT_CAP_SQUARE";t[t.JOINT_CAP_ROUND=20]="JOINT_CAP_ROUND";t[t.FILL_EXPAND=24]="FILL_EXPAND";t[t.CAP_BUTT=32]="CAP_BUTT";t[t.CAP_SQUARE=64]="CAP_SQUARE";t[t.CAP_ROUND=96]="CAP_ROUND";t[t.CAP_BUTT2=128]="CAP_BUTT2"}(t.JOINT_TYPE||(t.JOINT_TYPE={}));class f{constructor(){f.prototype.__init.call(this),f.prototype.__init2.call(this),f.prototype.__init3.call(this)}static __initStatic(){this.vertsByJoint=[]}__init(){this.strideFloats=12}updateBufferSize(e,n,i,s){const{joints:a}=s;let r=!1,l=0,o=0;for(let i=e;i<e+n;i++){const e=-32&a[i],n=31&a[i];if(n===t.JOINT_TYPE.FILL){r=!0,l++;continue}if(n>=t.JOINT_TYPE.FILL_EXPAND){l+=3,o+=3;continue}const s=f.vertsByJoint[n]+f.vertsByJoint[e];s>=4&&(l+=s,o+=6+3*Math.max(s-6,0))}r&&(o+=i),s.vertexSize+=l,s.indexSize+=o}__init2(){this.bufferPos=0}__init3(){this.indexPos=0}beginPack(t,e,n,i,s=0,a=0){this.buildData=t,this.bufFloat=e,this.bufUint=n,this.indices=i,this.bufferPos=s,this.indexPos=a}endPack(){this.buildData=null,this.bufFloat=null,this.bufUint=null,this.indices=null}packInterleavedGeometry(e,n,i,s,a){const{bufFloat:r,bufUint:l,indices:o,buildData:h,strideFloats:c}=this,{joints:u,verts:d}=h;let p,T,y,_,x,m,g,E,N=this.bufferPos,I=this.indexPos,v=this.bufferPos/this.strideFloats,P=!1,b=0;for(let i=e;i<e+n;i++){const e=u[i],n=-32&u[i],h=31&u[i];if(h===t.JOINT_TYPE.FILL){P=!0,p=d[2*i],T=d[2*i+1],r[N]=p,r[N+1]=T,r[N+2]=p,r[N+3]=T,r[N+4]=p,r[N+5]=T,r[N+6]=p,r[N+7]=T,r[N+8]=b,r[N+9]=16*h,r[N+10]=s,l[N+11]=a,N+=c;continue}if(h>=t.JOINT_TYPE.FILL_EXPAND){x=d[2*i],m=d[2*i+1],p=d[2*i+2],T=d[2*i+3],y=d[2*i+4],_=d[2*i+5];const t=i+3;for(let n=0;n<3;n++)r[N]=x,r[N+1]=m,r[N+2]=p,r[N+3]=T,r[N+4]=y,r[N+5]=_,r[N+6]=d[2*(t+n)],r[N+7]=d[2*(t+n)+1],r[N+8]=b,r[N+9]=16*e+n,r[N+10]=s,l[N+11]=a,N+=c;o[I]=v,o[I+1]=v+1,o[I+2]=v+2,I+=3,v+=3;continue}const O=f.vertsByJoint[h]+f.vertsByJoint[n];if(0===O)continue;p=d[2*i],T=d[2*i+1],y=d[2*i+2],_=d[2*i+3],x=d[2*i-2],m=d[2*i-1];const S=Math.sqrt((y-p)*(y-p)+(_-T)*(_-T));0===f.vertsByJoint[h]&&(b-=S),(-3&h)!==t.JOINT_TYPE.JOINT_CAP_BUTT?(g=d[2*i+4],E=d[2*i+5]):(g=p,E=T);for(let t=0;t<O;t++)r[N]=x,r[N+1]=m,r[N+2]=p,r[N+3]=T,r[N+4]=y,r[N+5]=_,r[N+6]=g,r[N+7]=E,r[N+8]=b,r[N+9]=16*e+t,r[N+10]=s,l[N+11]=a,N+=c;b+=S,o[I]=v,o[I+1]=v+1,o[I+2]=v+2,o[I+3]=v,o[I+4]=v+2,o[I+5]=v+3,I+=6;for(let t=5;t+1<O;t++)o[I]=v+4,o[I+1]=v+t,o[I+2]=v+t+1,I+=3;v+=O}if(P){for(let t=0;t<i.length;t++)o[I+t]=i[t]+v;I+=i.length}this.bufferPos=N,this.indexPos=I}}f.__initStatic();const T=f.vertsByJoint;for(let t=0;t<256;t++)T.push(0);T[t.JOINT_TYPE.FILL]=1;for(let e=0;e<8;e++)T[t.JOINT_TYPE.FILL_EXPAND+e]=3;T[t.JOINT_TYPE.JOINT_BEVEL]=7,T[t.JOINT_TYPE.JOINT_BEVEL+1]=7,T[t.JOINT_TYPE.JOINT_BEVEL+2]=7,T[t.JOINT_TYPE.JOINT_BEVEL+3]=7,T[t.JOINT_TYPE.JOINT_ROUND]=9,T[t.JOINT_TYPE.JOINT_ROUND+1]=9,T[t.JOINT_TYPE.JOINT_ROUND+2]=9,T[t.JOINT_TYPE.JOINT_ROUND+3]=9,T[t.JOINT_TYPE.JOINT_MITER]=8,T[t.JOINT_TYPE.JOINT_MITER+1]=8,T[t.JOINT_TYPE.JOINT_MITER+2]=4,T[t.JOINT_TYPE.JOINT_MITER+3]=4,T[t.JOINT_TYPE.JOINT_CAP_BUTT]=4,T[t.JOINT_TYPE.JOINT_CAP_BUTT+1]=4,T[t.JOINT_TYPE.JOINT_CAP_SQUARE]=4,T[t.JOINT_TYPE.JOINT_CAP_SQUARE+1]=4,T[t.JOINT_TYPE.JOINT_CAP_ROUND]=8,T[t.JOINT_TYPE.JOINT_CAP_ROUND+1]=8,T[t.JOINT_TYPE.CAP_ROUND]=4;class y{constructor(t,e=null,n=null,i=null){this.shape=t,this.lineStyle=n,this.fillStyle=e,this.matrix=i,this.type=t.type,this.points=[],this.holes=[],this.triangles=[],this.closeStroke=!1,this.clearBuild()}clearPath(){this.points.length=0,this.closeStroke=!0}clearBuild(){this.triangles.length=0,this.fillStart=0,this.fillLen=0,this.strokeStart=0,this.strokeLen=0,this.fillAA=!1}clone(){return new y(this.shape,this.fillStyle,this.lineStyle,this.matrix)}capType(){let e;switch(this.lineStyle.cap){case s.LINE_CAP.SQUARE:e=t.JOINT_TYPE.CAP_SQUARE;break;case s.LINE_CAP.ROUND:e=t.JOINT_TYPE.CAP_ROUND;break;default:e=t.JOINT_TYPE.CAP_BUTT}return e}goodJointType(){let e;switch(this.lineStyle.join){case s.LINE_JOIN.BEVEL:e=t.JOINT_TYPE.JOINT_BEVEL;break;case s.LINE_JOIN.ROUND:e=t.JOINT_TYPE.JOINT_ROUND;break;default:e=t.JOINT_TYPE.JOINT_MITER+3}return e}jointType(){let e;switch(this.lineStyle.join){case s.LINE_JOIN.BEVEL:e=t.JOINT_TYPE.JOINT_BEVEL;break;case s.LINE_JOIN.ROUND:e=t.JOINT_TYPE.JOINT_ROUND;break;default:e=t.JOINT_TYPE.JOINT_MITER}return e}destroy(){this.shape=null,this.holes.length=0,this.holes=null,this.points.length=0,this.points=null,this.lineStyle=null,this.fillStyle=null,this.triangles=null}}class _{path(t,n){const i=t.shape,s=t.points,a=i.x,r=i.y;let l,o;if(t.type===e.SHAPES.CIRC)l=i.radius,o=i.radius;else{const e=t.shape;l=e.width,o=e.height}if(l<=0||o<=0)return;s.push(a,r);let h=Math.floor(30*Math.sqrt(i.radius))||Math.floor(15*Math.sqrt(l+o));h/=2.3,h<3&&(h=3);const c=2*Math.PI/h;for(let t=0;t<h-.5;t++)s.push(a+Math.sin(-c*t)*l,r+Math.cos(-c*t)*o)}fill(e,n){const{verts:i,joints:s}=n,{points:a,triangles:r}=e;let l=1;if(!e.fillAA){for(let e=0;e<a.length;e+=2)i.push(a[e],a[e+1]),s.push(t.JOINT_TYPE.FILL),e>2&&r.push(l++,0,l);return void r.push(l,0,1)}const o=a[0],h=a[1],c=e.shape.radius;for(let e=2;e<a.length;e+=2){const n=e,r=e+2<a.length?e+2:2;i.push(o),i.push(h),i.push(a[n]),i.push(a[n+1]),i.push(a[r]),i.push(a[r+1]),i.push(0),i.push(0),i.push((a[n]-o)/c),i.push((a[n+1]-h)/c),i.push((a[r]-o)/c),i.push((a[r+1]-h)/c),s.push(t.JOINT_TYPE.FILL_EXPAND+2),s.push(t.JOINT_TYPE.NONE),s.push(t.JOINT_TYPE.NONE),s.push(t.JOINT_TYPE.NONE),s.push(t.JOINT_TYPE.NONE),s.push(t.JOINT_TYPE.NONE)}}line(e,n){const{verts:i,joints:s}=n,{points:a}=e,r=e.goodJointType(),l=a.length;i.push(a[l-2],a[l-1]),s.push(t.JOINT_TYPE.NONE);for(let t=2;t<l;t+=2)i.push(a[t],a[t+1]),s.push(r);i.push(a[2],a[3]),s.push(t.JOINT_TYPE.NONE),i.push(a[4],a[5]),s.push(t.JOINT_TYPE.NONE)}}class x{path(t,e){const n=t.shape,i=n.x,s=n.y,a=n.width,r=n.height,l=t.points;l.length=0,l.push(i,s,i+a,s,i+a,s+r,i,s+r)}line(e,n){const{verts:i,joints:s}=n,{points:a}=e,r=e.goodJointType(),l=a.length;i.push(a[l-2],a[l-1]),s.push(t.JOINT_TYPE.NONE);for(let t=0;t<l;t+=2)i.push(a[t],a[t+1]),s.push(r);i.push(a[0],a[1]),s.push(t.JOINT_TYPE.NONE),i.push(a[2],a[3]),s.push(t.JOINT_TYPE.NONE)}fill(e,n){const{verts:i,joints:s}=n,{points:a,triangles:r}=e;r.length=0,i.push(a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7]),s.push(t.JOINT_TYPE.FILL,t.JOINT_TYPE.FILL,t.JOINT_TYPE.FILL,t.JOINT_TYPE.FILL),r.push(0,1,2,0,2,3)}}function m(t,e,n){return t+(e-t)*n}function g(t,e,n,i,s,a,r=[]){const l=r;let o=0,h=0,c=0,u=0,d=0,p=0;for(let r=0,f=0;r<=20;++r)f=r/20,o=m(t,n,f),h=m(e,i,f),c=m(n,s,f),u=m(i,a,f),d=m(o,c,f),p=m(h,u,f),l.push(d,p);return l}class E{path(t,e){const n=t.shape,{points:i}=t,s=n.x,a=n.y,r=n.width,l=n.height,o=Math.max(0,Math.min(n.radius,Math.min(r,l)/2));i.length=0,o?(g(s,a+o,s,a,s+o,a,i),g(s+r-o,a,s+r,a,s+r,a+o,i),g(s+r,a+l-o,s+r,a+l,s+r-o,a+l,i),g(s+o,a+l,s,a+l,s,a+l-o,i)):i.push(s,a,s+r,a,s+r,a+l,s,a+l)}line(e,n){const{verts:i,joints:s}=n,{points:a}=e,r=8===a.length?e.goodJointType():t.JOINT_TYPE.JOINT_MITER+3,l=a.length;i.push(a[l-2],a[l-1]),s.push(t.JOINT_TYPE.NONE);for(let t=0;t<l;t+=2)i.push(a[t],a[t+1]),s.push(r);i.push(a[0],a[1]),s.push(t.JOINT_TYPE.NONE),i.push(a[2],a[3]),s.push(t.JOINT_TYPE.NONE)}fill(e,n){const{verts:i,joints:s}=n,{points:r}=e;e.triangles=a.earcut(r,null,2);for(let e=0,n=r.length;e<n;e++)i.push(r[e],r[++e]),s.push(t.JOINT_TYPE.FILL)}}const N=[];class I{path(t,n){const i=t.shape,s=t.points=i.points.slice(),a=n.closePointEps,r=a*a;if(0===s.length)return;const l=new e.Point(s[0],s[1]),o=new e.Point(s[s.length-2],s[s.length-1]),h=t.closeStroke=i.closeStroke;let c=s.length,u=2;for(let t=2;t<c;t+=2){const e=s[t-2],n=s[t-1],i=s[t],r=s[t+1];let l=!0;Math.abs(e-i)<a&&Math.abs(n-r)<a&&(l=!1),l&&(s[u]=s[t],s[u+1]=s[t+1],u+=2)}s.length=c=u,u=2;for(let t=2;t+2<c;t+=2){let e=s[t-2],n=s[t-1];const i=s[t],a=s[t+1];let l=s[t+2],o=s[t+3];e-=i,n-=a,l-=i,o-=a;let h=!0;Math.abs(l*n-o*e)<r&&e*l+n*o<-r&&(h=!1),h&&(s[u]=s[t],s[u+1]=s[t+1],u+=2)}if(s[u]=s[c-2],s[u+1]=s[c-1],u+=2,s.length=c=u,!(c<=2)&&h){Math.abs(l.x-o.x)<a&&Math.abs(l.y-o.y)<a&&(s.pop(),s.pop())}}line(e,n){const{closeStroke:i,points:s}=e,a=n.closePointEps,r=s.length;if(r<=2)return;const{verts:l,joints:o}=n,h=e.jointType(),c=e.capType();let u,d,p=0;i?(u=s[r-2],d=s[r-1],o.push(t.JOINT_TYPE.NONE)):(u=s[2],d=s[3],c===t.JOINT_TYPE.CAP_ROUND?(l.push(s[0],s[1]),o.push(t.JOINT_TYPE.NONE),o.push(t.JOINT_TYPE.CAP_ROUND),p=0):(p=c,o.push(t.JOINT_TYPE.NONE))),l.push(u,d);for(let e=0;e<r;e+=2){const n=s[e],f=s[e+1];let T,y;e+2<r?(T=s[e+2],y=s[e+3]):(T=s[0],y=s[1]);const _=T-n,x=y-f;let m,g,E=h;e+2>=r?(m=s[2],g=s[3],i||(E=t.JOINT_TYPE.NONE)):e+4>=r?(m=s[0],g=s[1],i||(c===t.JOINT_TYPE.CAP_ROUND&&(E=t.JOINT_TYPE.JOINT_CAP_ROUND),c===t.JOINT_TYPE.CAP_BUTT&&(E=t.JOINT_TYPE.JOINT_CAP_BUTT),c===t.JOINT_TYPE.CAP_SQUARE&&(E=t.JOINT_TYPE.JOINT_CAP_SQUARE))):(m=s[e+4],g=s[e+5]);const N=n-u,I=f-d;if(h>=t.JOINT_TYPE.JOINT_BEVEL&&h<=t.JOINT_TYPE.JOINT_MITER){const e=m-T,n=g-y;if(E>=t.JOINT_TYPE.JOINT_BEVEL&&E<=t.JOINT_TYPE.JOINT_MITER+3){const i=e*x-n*_;if(Math.abs(i)<a)switch(-4&h){case t.JOINT_TYPE.JOINT_ROUND:E=t.JOINT_TYPE.JOINT_CAP_ROUND;break;default:E=t.JOINT_TYPE.JOINT_CAP_BUTT}}if(h===t.JOINT_TYPE.JOINT_MITER){let i=0;N*_+I*x>-a&&i++,E===t.JOINT_TYPE.JOINT_MITER&&e*_+n*x>-a&&(i+=2),E+=i}}0===p&&Math.abs(N*x-I*_)<a&&(p=t.JOINT_TYPE.CAP_BUTT2),E+=p,p=0,l.push(n,f),o.push(E),u=n,d=f}i?(l.push(s[0],s[1]),o.push(t.JOINT_TYPE.NONE),l.push(s[2],s[3]),o.push(t.JOINT_TYPE.NONE)):(l.push(s[r-4],s[r-3]),o.push(t.JOINT_TYPE.NONE))}fill(e,n){let i=e.points;const s=e.holes,r=n.closePointEps,{verts:l,joints:o}=n;if(i.length<6)return;const h=[];let c=i.length;for(let t=0;t<s.length;t++){const e=s[t];h.push(i.length/2),i=i.concat(e.points)}const u=N;u.length<i.length&&(u.length=i.length);for(let t=0;t<=h.length;t++){let e=c/2;t>0&&(e=t<h.length?h[t]:i.length>>1),u[0]=e-1,u[2*(e-1)+1]=0;for(let t=0;t+1<e;t++)u[2*t+1]=t+1,u[2*t+2]=t}if(e.triangles=a.earcut(i,h,2),!e.triangles)return;if(!e.fillAA){for(let e=0;e<i.length;e+=2)l.push(i[e],i[e+1]),o.push(t.JOINT_TYPE.FILL);return}const{triangles:d}=e;c=i.length;for(let e=0;e<d.length;e+=3){let n=0;for(let t=0;t<3;t++){const i=d[e+t],s=d[e+(t+1)%3];u[2*i]!==s&&u[2*i+1]!==s||(n|=1<<t)}o.push(t.JOINT_TYPE.FILL_EXPAND+n),o.push(t.JOINT_TYPE.NONE),o.push(t.JOINT_TYPE.NONE),o.push(t.JOINT_TYPE.NONE),o.push(t.JOINT_TYPE.NONE),o.push(t.JOINT_TYPE.NONE)}for(let t=0;t<c/2;t++){const e=u[2*t],n=u[2*t+1];let s=i[2*n+1]-i[2*t+1],a=-(i[2*n]-i[2*t]),l=i[2*t+1]-i[2*e+1],o=-(i[2*t]-i[2*e]);const h=Math.sqrt(s*s+a*a);s/=h,a/=h;const c=Math.sqrt(l*l+o*o);l/=c,o/=c;let d=s+l,p=a+o;const f=d*s+p*a;Math.abs(f)<r?(d=s,p=a):(d/=f,p/=f),u[2*t]=d,u[2*t+1]=p}for(let t=0;t<d.length;t+=3){const e=d[t],n=d[t+1],s=d[t+2],a=i[2*s+1]-i[2*n+1],r=-(i[2*s]-i[2*n]),o=i[2*n+1]-i[2*e+1];let h=1;a*-(i[2*n]-i[2*e])-o*r>0&&(h=2);for(let e=0;e<3;e++){const n=d[t+e*h%3];l.push(i[2*n],i[2*n+1])}for(let e=0;e<3;e++){const n=d[t+e*h%3];l.push(u[2*n],u[2*n+1])}}}}const v={[e.SHAPES.POLY]:new I,[e.SHAPES.CIRC]:new _,[e.SHAPES.ELIP]:new _,[e.SHAPES.RECT]:new x,[e.SHAPES.RREC]:new E},P=[],b=[],O=new e.Point,S=new r.Bounds;class D extends n.Geometry{static __initStatic(){this.BATCHABLE_SIZE=100}__init(){this.indicesUint16=null}get points(){return this.buildData.verts}get closePointEps(){return this.buildData.closePointEps}initAttributes(t){this._buffer=new n.Buffer(null,t,!1),this._bufferFloats=new Float32Array,this._bufferUint=new Uint32Array,this._indexBuffer=new n.Buffer(null,t,!0),this.addAttribute("aPrev",this._buffer,2,!1,i.TYPES.FLOAT).addAttribute("aPoint1",this._buffer,2,!1,i.TYPES.FLOAT).addAttribute("aPoint2",this._buffer,2,!1,i.TYPES.FLOAT).addAttribute("aNext",this._buffer,2,!1,i.TYPES.FLOAT).addAttribute("aTravel",this._buffer,1,!1,i.TYPES.FLOAT).addAttribute("aVertexJoint",this._buffer,1,!1,i.TYPES.FLOAT).addAttribute("aStyleId",this._buffer,1,!1,i.TYPES.FLOAT).addAttribute("aColor",this._buffer,4,!0,i.TYPES.UNSIGNED_BYTE).addIndex(this._indexBuffer),this.strideFloats=12}constructor(){super(),D.prototype.__init.call(this),this.initAttributes(!1),this.buildData=new p,this.graphicsData=[],this.dirty=0,this.batchDirty=-1,this.cacheDirty=-1,this.clearDirty=0,this.drawCalls=[],this.batches=[],this.shapeBuildIndex=0,this.shapeBatchIndex=0,this._bounds=new r.Bounds,this.boundsDirty=-1,this.boundsPadding=0,this.batchable=!1,this.indicesUint16=null,this.packer=null,this.packSize=0,this.pack32index=null}checkInstancing(t,e){this.packer||(this.packer=new f,this.pack32index=e)}get bounds(){return this.boundsDirty!==this.dirty&&(this.boundsDirty=this.dirty,this.calculateBounds()),this._bounds}invalidate(){this.boundsDirty=-1,this.dirty++,this.batchDirty++,this.shapeBuildIndex=0,this.shapeBatchIndex=0,this.packSize=0,this.buildData.clear();for(let t=0;t<this.drawCalls.length;t++)this.drawCalls[t].clear(),b.push(this.drawCalls[t]);this.drawCalls.length=0;for(let t=0;t<this.batches.length;t++){const e=this.batches[t];e.reset(),P.push(e)}this.batches.length=0}clear(){return this.graphicsData.length>0&&(this.invalidate(),this.clearDirty++,this.graphicsData.length=0),this}drawShape(t,e=null,n=null,i=null){const s=new y(t,e,n,i);return this.graphicsData.push(s),this.dirty++,this}drawHole(t,e=null){if(!this.graphicsData.length)return null;const n=new y(t,null,null,e),i=this.graphicsData[this.graphicsData.length-1];return n.lineStyle=i.lineStyle,i.holes.push(n),this.dirty++,this}destroy(){super.destroy();for(let t=0;t<this.graphicsData.length;++t)this.graphicsData[t].destroy();this.buildData.destroy(),this.buildData=null,this.indexBuffer.destroy(),this.indexBuffer=null,this.graphicsData.length=0,this.graphicsData=null,this.drawCalls.length=0,this.drawCalls=null,this.batches.length=0,this.batches=null,this._bounds=null}containsPoint(t){const e=this.graphicsData;for(let n=0;n<e.length;++n){const i=e[n];if(i.fillStyle.visible&&(i.shape&&(i.matrix?i.matrix.applyInverse(t,O):O.copyFrom(t),i.shape.contains(O.x,O.y)))){let t=!1;if(i.holes)for(let e=0;e<i.holes.length;e++){if(i.holes[e].shape.contains(O.x,O.y)){t=!0;break}}if(!t)return!0}}return!1}updatePoints(){}updateBufferSize(){this._buffer.update(new Float32Array)}updateBuild(){const{graphicsData:t,buildData:e}=this,n=t.length;for(let i=this.shapeBuildIndex;i<n;i++){const n=t[i];n.strokeStart=0,n.strokeLen=0,n.fillStart=0,n.fillLen=0;const{fillStyle:s,lineStyle:a,holes:r}=n;if(!s.visible&&!a.visible)continue;const l=v[n.type];n.clearPath(),l.path(n,e),n.matrix&&this.transformPoints(n.points,n.matrix),n.clearBuild(),n.points.length<=2||(s.visible&&(r.length&&this.processHoles(r),n.fillAA=n.fillStyle.smooth&&!(n.lineStyle.visible&&n.lineStyle.alpha>=.99&&n.lineStyle.width>=.99),n.fillStart=e.joints.length,l.fill(n,e),n.fillLen=e.joints.length-n.fillStart),a.visible&&(n.strokeStart=e.joints.length,l.line(n,e),n.strokeLen=e.joints.length-n.strokeStart))}this.shapeBuildIndex=n}updateBatches(t){if(!this.graphicsData.length)return void(this.batchable=!0);if(this.updateBuild(),!this.validateBatching())return;const{buildData:e,graphicsData:n}=this,s=n.length;this.cacheDirty=this.dirty;let a=null,r=null;this.batches.length>0&&(a=this.batches[this.batches.length-1],r=a.style);for(let t=this.shapeBatchIndex;t<s;t++){const s=n[t],l=s.fillStyle,o=s.lineStyle;if(s.matrix&&this.transformPoints(s.points,s.matrix),l.visible||o.visible)for(let t=0;t<2;t++){const n=0===t?l:o;if(!n.visible)continue;const h=n.texture.baseTexture,u=e.vertexSize,d=e.indexSize;h.wrapMode=i.WRAP_MODES.REPEAT,0===t?this.packer.updateBufferSize(s.fillStart,s.fillLen,s.triangles.length,e):this.packer.updateBufferSize(s.strokeStart,s.strokeLen,s.triangles.length,e);e.vertexSize!==u&&(a&&!this._compareStyles(r,n)&&(a.end(d,u),a=null),a||(a=P.pop()||new c,a.begin(n,d,u),this.batches.push(a),r=n),a.jointEnd=0===t?s.fillStart+s.fillLen:s.strokeStart+s.strokeLen)}}this.shapeBatchIndex=s,a&&a.end(e.indexSize,e.vertexSize),0!==this.batches.length?(this.batchable=this.isBatchable(),this.batchable?this.packBatches():(this.buildDrawCalls(t),this.updatePack())):this.batchable=!0}updatePack(){const{vertexSize:t,indexSize:e}=this.buildData;if(this.packSize===t)return;const{strideFloats:n,packer:i,buildData:s,batches:a}=this,r=this._buffer,l=this._indexBuffer,o=t*n;if(r.data.length!==o){const t=new ArrayBuffer(4*o);this._bufferFloats=new Float32Array(t),this._bufferUint=new Uint32Array(t),r.data=this._bufferFloats}l.data.length!==e&&(t>65535&&this.pack32index?l.data=new Uint32Array(e):l.data=new Uint16Array(e)),i.beginPack(s,this._bufferFloats,this._bufferUint,l.data);let h=0;for(let t=0;t<this.graphicsData.length;t++){const e=this.graphicsData[t];if(e.fillLen){for(;a[h].jointEnd<=e.fillStart;)h++;i.packInterleavedGeometry(e.fillStart,e.fillLen,e.triangles,a[h].styleId,a[h].rgba)}if(e.strokeLen){for(;a[h].jointEnd<=e.strokeStart;)h++;i.packInterleavedGeometry(e.strokeStart,e.strokeLen,e.triangles,a[h].styleId,a[h].rgba)}}r.update(),l.update(),this.packSize=t}_compareStyles(t,n){if(!t||!n)return!1;if(t.texture.baseTexture!==n.texture.baseTexture)return!1;if(t.color+t.alpha!==n.color+n.alpha)return!1;if(t.packLineWidth()!==n.packLineWidth())return!1;if(t.alignment!==n.alignment)return!1;return l(t.matrix||e.Matrix.IDENTITY,n.matrix||e.Matrix.IDENTITY)}validateBatching(){if(this.dirty===this.cacheDirty||!this.graphicsData.length)return!1;for(let t=0,e=this.graphicsData.length;t<e;t++){const e=this.graphicsData[t],n=e.fillStyle,i=e.lineStyle;if(n&&!n.texture.baseTexture.valid)return!1;if(i&&!i.texture.baseTexture.valid)return!1}return!0}packBatches(){this.batchDirty++;const t=this.batches;for(let e=0,n=t.length;e<n;e++){const n=t[e];for(let t=0;t<n.size;t++){const e=n.start+t;this.indicesUint16[e]=this.indicesUint16[e]-n.attribStart}}}isBatchable(){return!1}buildDrawCalls(t){for(let t=0;t<this.drawCalls.length;t++)this.drawCalls[t].clear(),b.push(this.drawCalls[t]);this.drawCalls.length=0;let e=b.pop()||new h;e.begin(t,null);let n=0;this.drawCalls.push(e);for(let i=0;i<this.batches.length;i++){const s=this.batches[i],r=s.style;if(0===s.attribSize)continue;let l=-1;const o=r.getTextureMatrix();e.check(r.shader)&&(l=e.add(r.texture,o,r.packLineWidth(),r.alignment||0)),l<0&&(e=b.pop()||new h,this.drawCalls.push(e),e.begin(t,r.shader),e.start=n,l=e.add(r.texture,o,r.packLineWidth(),r.alignment||0)),e.size+=s.size,n+=s.size;const{color:c,alpha:u}=r,d=(c>>16)+(65280&c)+((255&c)<<16);s.rgba=a.premultiplyTint(d,u),s.styleId=l}}processHoles(t){for(let e=0;e<t.length;e++){const n=t[e];v[n.type].path(n,this.buildData),n.matrix&&this.transformPoints(n.points,n.matrix)}}calculateBounds(){const t=this._bounds,n=S;let i=e.Matrix.IDENTITY;this._bounds.clear(),n.clear();for(let s=0;s<this.graphicsData.length;s++){const a=this.graphicsData[s],r=a.shape,l=a.type,o=a.lineStyle,h=a.matrix||e.Matrix.IDENTITY;let c=0;if(o&&o.visible){const t=o.alignment;c=o.width,l===e.SHAPES.POLY?c*=.5+Math.abs(.5-t):c*=Math.max(0,t)}if(i!==h&&(n.isEmpty()||(t.addBoundsMatrix(n,i),n.clear()),i=h),l===e.SHAPES.RECT||l===e.SHAPES.RREC){const t=r;n.addFramePad(t.x,t.y,t.x+t.width,t.y+t.height,c,c)}else if(l===e.SHAPES.CIRC){const t=r;n.addFramePad(t.x,t.y,t.x,t.y,t.radius+c,t.radius+c)}else if(l===e.SHAPES.ELIP){const t=r;n.addFramePad(t.x,t.y,t.x,t.y,t.width+c,t.height+c)}else{const e=r;t.addVerticesMatrix(i,e.points,0,e.points.length,c,c)}}n.isEmpty()||t.addBoundsMatrix(n,i),t.pad(this.boundsPadding,this.boundsPadding)}transformPoints(t,e){for(let n=0;n<t.length/2;n++){const i=t[2*n],s=t[2*n+1];t[2*n]=e.a*i+e.c*s+e.tx,t[2*n+1]=e.b*i+e.d*s+e.ty}}}D.__initStatic();class A extends n.Program{constructor(t,e="precision highp float;\nconst float FILL = 1.0;\nconst float BEVEL = 4.0;\nconst float MITER = 8.0;\nconst float ROUND = 12.0;\nconst float JOINT_CAP_BUTT = 16.0;\nconst float JOINT_CAP_SQUARE = 18.0;\nconst float JOINT_CAP_ROUND = 20.0;\n\nconst float FILL_EXPAND = 24.0;\n\nconst float CAP_BUTT = 1.0;\nconst float CAP_SQUARE = 2.0;\nconst float CAP_ROUND = 3.0;\nconst float CAP_BUTT2 = 4.0;\n\nconst float MITER_LIMIT = 10.0;\n\n// === geom ===\nattribute vec2 aPrev;\nattribute vec2 aPoint1;\nattribute vec2 aPoint2;\nattribute vec2 aNext;\nattribute float aVertexJoint;\nattribute float aTravel;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec4 vSignedCoord;\nvarying vec4 vDistance;\nvarying float vType;\n\nuniform float resolution;\nuniform float expand;\n\n// === style ===\nattribute float aStyleId;\nattribute vec4 aColor;\n\nvarying float vTextureId;\nvarying vec4 vColor;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\n\nuniform vec2 styleLine[%MAX_STYLES%];\nuniform vec3 styleMatrix[2 * %MAX_STYLES%];\nuniform float styleTextureId[%MAX_STYLES%];\nuniform vec2 samplerSize[%MAX_TEXTURES%];\n\nvec2 doBisect(vec2 norm, float len, vec2 norm2, float len2,\n    float dy, float inner) {\n    vec2 bisect = (norm + norm2) / 2.0;\n    bisect /= dot(norm, bisect);\n    vec2 shift = dy * bisect;\n    if (inner > 0.5) {\n        if (len < len2) {\n            if (abs(dy * (bisect.x * norm.y - bisect.y * norm.x)) > len) {\n                return dy * norm;\n            }\n        } else {\n            if (abs(dy * (bisect.x * norm2.y - bisect.y * norm2.x)) > len2) {\n                return dy * norm;\n            }\n        }\n    }\n    return dy * bisect;\n}\n\nvoid main(void){\n    vec2 pointA = (translationMatrix * vec3(aPoint1, 1.0)).xy;\n    vec2 pointB = (translationMatrix * vec3(aPoint2, 1.0)).xy;\n\n    vec2 xBasis = pointB - pointA;\n    float len = length(xBasis);\n    vec2 forward = xBasis / len;\n    vec2 norm = vec2(forward.y, -forward.x);\n\n    float type = floor(aVertexJoint / 16.0);\n    float vertexNum = aVertexJoint - type * 16.0;\n    float dx = 0.0, dy = 1.0;\n\n\n    vec2 avgDiag = (translationMatrix * vec3(1.0, 1.0, 0.0)).xy;\n    float avgScale = sqrt(dot(avgDiag, avgDiag) * 0.5);\n\n    float capType = floor(type / 32.0);\n    type -= capType * 32.0;\n\n    int styleId = int(aStyleId + 0.5);\n    float lineWidth = styleLine[styleId].x;\n    if (lineWidth < 0.0) {\n        lineWidth = -lineWidth;\n    } else {\n        lineWidth = lineWidth * avgScale;\n    }\n    lineWidth *= 0.5;\n    float lineAlignment = 2.0 * styleLine[styleId].y - 1.0;\n    vTextureId = styleTextureId[styleId];\n    vTextureCoord = vec2(0.0);\n\n    vec2 pos;\n\n    if (capType == CAP_ROUND) {\n        vertexNum += 4.0;\n        type = JOINT_CAP_ROUND;\n        capType = 0.0;\n    }\n\n    if (type == FILL) {\n        pos = pointA;\n        vDistance = vec4(0.0, -0.5, -0.5, 1.0);\n        vType = 0.0;\n\n        vec2 vTexturePixel;\n        vTexturePixel.x = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2]);\n        vTexturePixel.y = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2 + 1]);\n        vTextureCoord = vTexturePixel / samplerSize[int(vTextureId)];\n    } else if (type >= FILL_EXPAND && type < FILL_EXPAND + 7.5) {\n        // expand vertices\n        float flags = type - FILL_EXPAND;\n        float flag3 = floor(flags / 4.0);\n        float flag2 = floor((flags - flag3 * 4.0) / 2.0);\n        float flag1 = flags - flag3 * 4.0 - flag2 * 2.0;\n\n        vec2 prev = (translationMatrix * vec3(aPrev, 1.0)).xy;\n\n        if (vertexNum < 0.5) {\n            pos = prev;\n        } else if (vertexNum < 1.5) {\n            pos = pointA;\n        } else {\n            pos = pointB;\n        }\n        float len2 = length(aNext);\n        vec2 bisect = (translationMatrix * vec3(aNext, 0.0)).xy;\n        if (len2 > 0.01) {\n            bisect = normalize(bisect) * len2;\n        }\n\n        vec2 n1 = normalize(vec2(pointA.y - prev.y, -(pointA.x - prev.x)));\n        vec2 n2 = normalize(vec2(pointB.y - pointA.y, -(pointB.x - pointA.x)));\n        vec2 n3 = normalize(vec2(prev.y - pointB.y, -(prev.x - pointB.x)));\n\n        if (n1.x * n2.y - n1.y * n2.x < 0.0) {\n            n1 = -n1;\n            n2 = -n2;\n            n3 = -n3;\n        }\n\n        vDistance.w = 1.0;\n        pos += bisect * expand;\n\n        vDistance = vec4(16.0, 16.0, 16.0, -1.0);\n        if (flag1 > 0.5) {\n            vDistance.x = -dot(pos - prev, n1);\n        }\n        if (flag2 > 0.5) {\n            vDistance.y = -dot(pos - pointA, n2);\n        }\n        if (flag3 > 0.5) {\n            vDistance.z = -dot(pos - pointB, n3);\n        }\n        vDistance.xyz *= resolution;\n        vType = 2.0;\n    } else if (type >= BEVEL) {\n        float dy = lineWidth + expand;\n        float inner = 0.0;\n        if (vertexNum >= 1.5) {\n            dy = -dy;\n            inner = 1.0;\n        }\n\n        vec2 base, next, xBasis2, bisect;\n        float flag = 0.0;\n        float sign2 = 1.0;\n        if (vertexNum < 0.5 || vertexNum > 2.5 && vertexNum < 3.5) {\n            next = (translationMatrix * vec3(aPrev, 1.0)).xy;\n            base = pointA;\n            flag = type - floor(type / 2.0) * 2.0;\n            sign2 = -1.0;\n        } else {\n            next = (translationMatrix * vec3(aNext, 1.0)).xy;\n            base = pointB;\n            if (type >= MITER && type < MITER + 3.5) {\n                flag = step(MITER + 1.5, type);\n                // check miter limit here?\n            }\n        }\n        xBasis2 = next - base;\n        float len2 = length(xBasis2);\n        vec2 norm2 = vec2(xBasis2.y, -xBasis2.x) / len2;\n        float D = norm.x * norm2.y - norm.y * norm2.x;\n        if (D < 0.0) {\n            inner = 1.0 - inner;\n        }\n\n        norm2 *= sign2;\n\n        if (abs(lineAlignment) > 0.01) {\n            float shift = lineWidth * lineAlignment;\n            pointA += norm * shift;\n            pointB += norm * shift;\n            if (abs(D) < 0.01) {\n                base += norm * shift;\n            } else {\n                base += doBisect(norm, len, norm2, len2, shift, 0.0);\n            }\n        }\n\n        float collinear = step(0.0, dot(norm, norm2));\n\n        vType = 0.0;\n        float dy2 = -1000.0;\n        float dy3 = -1000.0;\n\n        if (abs(D) < 0.01 && collinear < 0.5) {\n            if (type >= ROUND && type < ROUND + 1.5) {\n                type = JOINT_CAP_ROUND;\n            }\n            //TODO: BUTT here too\n        }\n\n        if (vertexNum < 3.5) {\n            if (abs(D) < 0.01) {\n                pos = dy * norm;\n            } else {\n                if (flag < 0.5 && inner < 0.5) {\n                    pos = dy * norm;\n                } else {\n                    pos = doBisect(norm, len, norm2, len2, dy, inner);\n                }\n            }\n            if (capType >= CAP_BUTT && capType < CAP_ROUND) {\n                float extra = step(CAP_SQUARE, capType) * lineWidth;\n                vec2 back = -forward;\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\n                    pos += back * (expand + extra);\n                    dy2 = expand;\n                } else {\n                    dy2 = dot(pos + base - pointA, back) - extra;\n                }\n            }\n            if (type >= JOINT_CAP_BUTT && type < JOINT_CAP_SQUARE + 0.5) {\n                float extra = step(JOINT_CAP_SQUARE, type) * lineWidth;\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\n                    dy3 = dot(pos + base - pointB, forward) - extra;\n                } else {\n                    pos += forward * (expand + extra);\n                    dy3 = expand;\n                    if (capType >= CAP_BUTT) {\n                        dy2 -= expand + extra;\n                    }\n                }\n            }\n        } else if (type >= JOINT_CAP_ROUND && type < JOINT_CAP_ROUND + 1.5) {\n            if (inner > 0.5) {\n                dy = -dy;\n                inner = 0.0;\n            }\n            vec2 d2 = abs(dy) * vec2(-norm.y, norm.x);\n            if (vertexNum < 4.5) {\n                dy = -dy;\n                pos = dy * norm;\n            } else if (vertexNum < 5.5) {\n                pos = dy * norm;\n            } else if (vertexNum < 6.5) {\n                pos = dy * norm + d2;\n            } else {\n                dy = -dy;\n                pos = dy * norm + d2;\n            }\n            dy = -0.5;\n            dy2 = pos.x;\n            dy3 = pos.y;\n            vType = 3.0;\n        } else if (abs(D) < 0.01) {\n            pos = dy * norm;\n        } else {\n            if (type >= ROUND && type < ROUND + 1.5) {\n                if (inner > 0.5) {\n                    dy = -dy;\n                    inner = 0.0;\n                }\n                if (vertexNum < 4.5) {\n                    pos = doBisect(norm, len, norm2, len2, -dy, 1.0);\n                } else if (vertexNum < 5.5) {\n                    pos = dy * norm;\n                } else if (vertexNum > 7.5) {\n                    pos = dy * norm2;\n                } else {\n                    pos = doBisect(norm, len, norm2, len2, dy, 0.0);\n                    float d2 = abs(dy);\n                    if (length(pos) > abs(dy) * 1.5) {\n                        if (vertexNum < 6.5) {\n                            pos.x = dy * norm.x - d2 * norm.y;\n                            pos.y = dy * norm.y + d2 * norm.x;\n                        } else {\n                            pos.x = dy * norm2.x + d2 * norm2.y;\n                            pos.y = dy * norm2.y - d2 * norm2.x;\n                        }\n                    }\n                }\n                vec2 norm3 = normalize(norm - norm2);\n                dy = pos.x * norm3.y - pos.y * norm3.x - 3.0;\n                dy2 = pos.x;\n                dy3 = pos.y;\n                vType = 3.0;\n            } else {\n                if (type >= MITER && type < MITER + 3.5) {\n                    if (inner > 0.5) {\n                        dy = -dy;\n                        inner = 0.0;\n                    }\n                    float sign = step(0.0, dy) * 2.0 - 1.0;\n                    pos = doBisect(norm, len, norm2, len2, dy, 0.0);\n                    if (length(pos) > abs(dy) * MITER_LIMIT) {\n                        type = BEVEL;\n                    } else {\n                        if (vertexNum < 4.5) {\n                            dy = -dy;\n                            pos = doBisect(norm, len, norm2, len2, dy, 1.0);\n                        } else if (vertexNum < 5.5) {\n                            pos = dy * norm;\n                        } else if (vertexNum > 6.5) {\n                            pos = dy * norm2;\n                            // dy = ...\n                        }\n                    }\n                    vType = 1.0;\n                    dy = -sign * dot(pos, norm);\n                    dy2 = -sign * dot(pos, norm2);\n                }\n                if (type >= BEVEL && type < BEVEL + 1.5) {\n                    if (inner < 0.5) {\n                        dy = -dy;\n                        inner = 1.0;\n                    }\n                    vec2 norm3 = normalize((norm + norm2) / 2.0);\n                    if (vertexNum < 4.5) {\n                        pos = doBisect(norm, len, norm2, len2, dy, 1.0);\n                        dy2 = -abs(dot(pos + dy * norm, norm3));\n                    } else {\n                        dy2 = 0.0;\n                        dy = -dy;\n                        if (vertexNum < 5.5) {\n                            pos = dy * norm;\n                        } else {\n                            pos = dy * norm2;\n                        }\n                    }\n                }\n            }\n        }\n\n        pos += base;\n        vDistance = vec4(dy, dy2, dy3, lineWidth) * resolution;\n        vTravel = aTravel * avgScale + dot(pos - pointA, vec2(-norm.y, norm.x));\n    }\n\n    gl_Position = vec4((projectionMatrix * vec3(pos, 1.0)).xy, 0.0, 1.0);\n\n    vColor = aColor * tint;\n}",n="\nvarying vec4 vColor;\nvarying vec4 vDistance;\nvarying float vType;\nvarying float vTextureId;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\n\nvoid main(void){\n    float alpha = 1.0;\n    float lineWidth = vDistance.w;\n    if (vType < 0.5) {\n        float left = max(vDistance.x - 0.5, -vDistance.w);\n        float right = min(vDistance.x + 0.5, vDistance.w);\n        float near = vDistance.y - 0.5;\n        float far = min(vDistance.y + 0.5, 0.0);\n        float top = vDistance.z - 0.5;\n        float bottom = min(vDistance.z + 0.5, 0.0);\n        alpha = max(right - left, 0.0) * max(bottom - top, 0.0) * max(far - near, 0.0);\n    } else if (vType < 1.5) {\n        float a1 = clamp(vDistance.x + 0.5 - lineWidth, 0.0, 1.0);\n        float a2 = clamp(vDistance.x + 0.5 + lineWidth, 0.0, 1.0);\n        float b1 = clamp(vDistance.y + 0.5 - lineWidth, 0.0, 1.0);\n        float b2 = clamp(vDistance.y + 0.5 + lineWidth, 0.0, 1.0);\n        alpha = a2 * b2 - a1 * b1;\n    } else if (vType < 2.5) {\n        alpha *= max(min(vDistance.x + 0.5, 1.0), 0.0);\n        alpha *= max(min(vDistance.y + 0.5, 1.0), 0.0);\n        alpha *= max(min(vDistance.z + 0.5, 1.0), 0.0);\n    } else {\n        float dist2 = sqrt(dot(vDistance.yz, vDistance.yz));\n        float rad = vDistance.w;\n        float left = max(dist2 - 0.5, -rad);\n        float right = min(dist2 + 0.5, rad);\n        // TODO: something has to be done about artifact at vDistance.x far side\n        alpha = 1.0 - step(vDistance.x, 0.0) * (1.0 - max(right - left, 0.0));\n    }\n\n    vec4 texColor;\n    float textureId = floor(vTextureId+0.5);\n    %FOR_LOOP%\n\n    gl_FragColor = vColor * texColor * alpha;\n}\n",i={}){const{maxStyles:s,maxTextures:a}=t;super(e=e.replace(/%MAX_TEXTURES%/gi,`${a}`).replace(/%MAX_STYLES%/gi,`${s}`),n=n.replace(/%MAX_TEXTURES%/gi,`${a}`).replace(/%FOR_LOOP%/gi,L.generateSampleSrc(a))),this.settings=t}}class L extends n.Shader{constructor(t,e=new A(t),n={}){const{maxStyles:i,maxTextures:s}=t,a=new Int32Array(s);for(let t=0;t<s;t++)a[t]=t;super(e,Object.assign(n,{styleMatrix:new Float32Array(6*i),styleTextureId:new Float32Array(i),styleLine:new Float32Array(2*i),samplerSize:new Float32Array(2*s),uSamplers:a,tint:new Float32Array([1,1,1,1]),resolution:1,expand:1})),this.settings=t}static generateSampleSrc(t){let e="";e+="\n",e+="\n";for(let n=0;n<t;n++)n>0&&(e+="\nelse "),n<t-1&&(e+=`if(textureId < ${n}.5)`),e+="\n{",e+=`\n\ttexColor = texture2D(uSamplers[${n}], vTextureCoord);`,e+="\n}";return e+="\n",e+="\n",e}}const J={LINE_SCALE_MODE:t.LINE_SCALE_MODE.NORMAL,SHADER_MAX_STYLES:24,SHADER_MAX_TEXTURES:4},{BezierUtils:M,QuadraticUtils:C,ArcUtils:w}=s.graphicsUtils,B=new Float32Array(3),R={};class Y extends r.Container{static __initStatic(){this._TEMP_POINT=new e.Point}get geometry(){return this._geometry}constructor(t=null){super(),this._geometry=t||new D,this._geometry.refCount++,this.shader=null,this.shaderSettings={maxStyles:J.SHADER_MAX_STYLES,maxTextures:J.SHADER_MAX_TEXTURES},this.state=n.State.for2d(),this._fillStyle=new u,this._lineStyle=new d,this._matrix=null,this._holeMode=!1,this.currentPath=null,this.batches=[],this.batchTint=-1,this.batchDirty=-1,this.vertexData=null,this.pluginName="smooth",this._transformID=-1,this.tint=16777215,this.blendMode=i.BLEND_MODES.NORMAL}clone(){return this.finishPoly(),new Y(this._geometry)}set blendMode(t){this.state.blendMode=t}get blendMode(){return this.state.blendMode}get tint(){return this._tint}set tint(t){this._tint=t}get fill(){return this._fillStyle}get line(){return this._lineStyle}lineStyle(e=null,n=0,i=1,s=.5,a=J.LINE_SCALE_MODE){if("number"==typeof e)"boolean"==typeof a&&(a=a?t.LINE_SCALE_MODE.NONE:t.LINE_SCALE_MODE.NORMAL),e={width:e,color:n,alpha:i,alignment:s,scaleMode:a};else{const n=e.native;void 0!==n&&(e.scaleMode=n?t.LINE_SCALE_MODE.NONE:t.LINE_SCALE_MODE.NORMAL)}return this.lineTextureStyle(e)}lineTextureStyle(t){t=Object.assign({width:0,texture:n.Texture.WHITE,color:t&&t.texture?16777215:0,alpha:1,matrix:null,alignment:.5,native:!1,cap:s.LINE_CAP.BUTT,join:s.LINE_JOIN.MITER,miterLimit:10,shader:null,scaleMode:J.LINE_SCALE_MODE},t),this.currentPath&&this.startPoly();const e=t.width>0&&t.alpha>0;return e?(t.matrix&&(t.matrix=t.matrix.clone(),t.matrix.invert()),Object.assign(this._lineStyle,{visible:e},t)):this._lineStyle.reset(),this}startPoly(){if(this.currentPath){const t=this.currentPath.points,n=this.currentPath.points.length;n>2&&(this.drawShape(this.currentPath),this.currentPath=new e.Polygon,this.currentPath.closeStroke=!1,this.currentPath.points.push(t[n-2],t[n-1]))}else this.currentPath=new e.Polygon,this.currentPath.closeStroke=!1}finishPoly(){this.currentPath&&(this.currentPath.points.length>2?(this.drawShape(this.currentPath),this.currentPath=null):this.currentPath.points.length=0)}moveTo(t,e){return this.startPoly(),this.currentPath.points[0]=t,this.currentPath.points[1]=e,this}lineTo(t,e){this.currentPath||this.moveTo(0,0);const n=this.currentPath.points,i=n[n.length-2],s=n[n.length-1];return i===t&&s===e||n.push(t,e),this}_initCurve(t=0,e=0){this.currentPath?0===this.currentPath.points.length&&(this.currentPath.points=[t,e]):this.moveTo(t,e)}quadraticCurveTo(t,e,n,i){this._initCurve();const s=this.currentPath.points;return 0===s.length&&this.moveTo(0,0),C.curveTo(t,e,n,i,s),this}bezierCurveTo(t,e,n,i,s,a){return this._initCurve(),M.curveTo(t,e,n,i,s,a,this.currentPath.points),this}arcTo(t,e,n,i,s){this._initCurve(t,e);const a=this.currentPath.points,r=w.curveTo(t,e,n,i,s,a);if(r){const{cx:t,cy:e,radius:n,startAngle:i,endAngle:s,anticlockwise:a}=r;this.arc(t,e,n,i,s,a)}return this}arc(t,n,i,s,a,r=!1){if(s===a)return this;!r&&a<=s?a+=e.PI_2:r&&s<=a&&(s+=e.PI_2);if(0===a-s)return this;const l=t+Math.cos(s)*i,o=n+Math.sin(s)*i,h=this._geometry.closePointEps;let c=this.currentPath?this.currentPath.points:null;if(c){const t=Math.abs(c[c.length-2]-l),e=Math.abs(c[c.length-1]-o);t<h&&e<h||c.push(l,o)}else this.moveTo(l,o),c=this.currentPath.points;return w.arc(l,o,t,n,i,s,a,r,c),this}beginFill(t=0,e=1,i=!1){return this.beginTextureFill({texture:n.Texture.WHITE,color:t,alpha:e,smooth:i})}beginTextureFill(t){t=Object.assign({texture:n.Texture.WHITE,color:16777215,alpha:1,matrix:null,smooth:!1},t),this.currentPath&&this.startPoly();const e=t.alpha>0;return e?(t.matrix&&(t.matrix=t.matrix.clone(),t.matrix.invert()),Object.assign(this._fillStyle,{visible:e},t)):this._fillStyle.reset(),this}endFill(){return this.finishPoly(),this._fillStyle.reset(),this}drawRect(t,n,i,s){return this.drawShape(new e.Rectangle(t,n,i,s))}drawRoundedRect(t,n,i,s,a){return this.drawShape(new e.RoundedRectangle(t,n,i,s,a))}drawCircle(t,n,i){return this.drawShape(new e.Circle(t,n,i))}drawEllipse(t,n,i,s){return this.drawShape(new e.Ellipse(t,n,i,s))}drawPolygon(...t){let n,i=!0;const s=t[0];s.points?(i=s.closeStroke,n=s.points):n=Array.isArray(t[0])?t[0]:t;const a=new e.Polygon(n);return a.closeStroke=i,this.drawShape(a),this}drawShape(t){return this._holeMode?this._geometry.drawHole(t,this._matrix):this._geometry.drawShape(t,this._fillStyle.clone(),this._lineStyle.clone(),this._matrix),this}clear(){return this._geometry.clear(),this._lineStyle.reset(),this._fillStyle.reset(),this._boundsID++,this._matrix=null,this._holeMode=!1,this.currentPath=null,this}isFastRect(){const t=this._geometry.graphicsData;return 1===t.length&&t[0].shape.type===e.SHAPES.RECT&&!(t[0].lineStyle.visible&&t[0].lineStyle.width)}_renderCanvas(t){s.Graphics.prototype._renderCanvas.call(this,t)}_render(t){this.finishPoly();const e=this._geometry,n=t.context.supports.uint32Indices;e.checkInstancing(t.geometry.hasInstance,n),e.updateBatches(this.shaderSettings),e.batchable?(this.batchDirty!==e.batchDirty&&this._populateBatches(),this._renderBatched(t)):(t.batch.flush(),this._renderDirect(t))}_populateBatches(){const t=this._geometry,e=this.blendMode,n=t.batches.length;this.batchTint=-1,this._transformID=-1,this.batchDirty=t.batchDirty,this.batches.length=n,this.vertexData=new Float32Array(t.points);for(let i=0;i<n;i++){const n=t.batches[i],s=n.style.color,r={vertexData:new Float32Array(this.vertexData.buffer,4*n.attribStart*2,2*n.attribSize),blendMode:e,_batchRGB:a.hex2rgb(s),_tintRGB:s,_texture:n.style.texture,alpha:n.style.alpha,worldAlpha:1};this.batches[i]=r}}_renderBatched(t){if(this.batches.length){t.batch.setObjectRenderer(t.plugins[this.pluginName]),this.calculateVertices(),this.calculateTints();for(let e=0,n=this.batches.length;e<n;e++){const n=this.batches[e];n.worldAlpha=this.worldAlpha*n.alpha,t.plugins[this.pluginName].render(n)}}}_renderDirect(t){const e=this._resolveDirectShader(t);let n=e;const s=this._geometry,a=this.tint,r=this.worldAlpha,l=n.uniforms,o=s.drawCalls;l.translationMatrix=this.transform.worldTransform,l.tint[0]=(a>>16&255)/255*r,l.tint[1]=(a>>8&255)/255*r,l.tint[2]=(255&a)/255*r,l.tint[3]=r,l.resolution=t.renderTexture.current?t.renderTexture.current.resolution:t.resolution;const h=t.projection.transform;if(h){const t=Math.sqrt(h.a*h.a+h.b*h.b);l.resolution*=t}l.expand=(t.options.antialias?2:1)/l.resolution,t.shader.bind(n),t.geometry.bind(s,n),t.state.set(this.state),n=null;for(let a=0,r=o.length;a<r;a++){const r=s.drawCalls[a],o=n!==r.shader;o&&(n=r.shader,n&&(n.uniforms.translationMatrix=this.transform.worldTransform,n.uniforms.tint&&(n.uniforms.tint[0]=l.tint[0],n.uniforms.tint[1]=l.tint[1],n.uniforms.tint[2]=l.tint[2],n.uniforms.tint[3]=l.tint[3])));const{texArray:h,styleArray:c,size:u,start:d}=r,p=h.count,f=n||e,T=f.uniforms.styleTextureId,y=f.uniforms.styleMatrix,_=f.uniforms.styleLine;for(let t=0;t<c.count;t++){T[t]=c.textureIds[t],_[2*t]=c.lines[2*t],_[2*t+1]=c.lines[2*t+1];const e=c.matrices[t];y[6*t]=e.a,y[6*t+1]=e.c,y[6*t+2]=e.tx,y[6*t+3]=e.b,y[6*t+4]=e.d,y[6*t+5]=e.ty}const x=f.uniforms.samplerSize;for(let t=0;t<p;t++)x[2*t]=h.elements[t].width,x[2*t+1]=h.elements[t].height;t.shader.bind(f),o&&t.geometry.bind(s);for(let e=0;e<p;e++)t.texture.bind(h.elements[e],e);t.geometry.draw(i.DRAW_MODES.TRIANGLES,u,d)}}_resolveDirectShader(t){let e=this.shader;const n=this.pluginName;return e||(R[n]||(R[n]=new L(this.shaderSettings)),e=R[n]),e}_calculateBounds(){this.finishPoly();const t=this._geometry;if(!t.graphicsData.length)return;const{minX:e,minY:n,maxX:i,maxY:s}=t.bounds;this._bounds.addFrame(this.transform,e,n,i,s)}containsPoint(t){return this.worldTransform.applyInverse(t,Y._TEMP_POINT),this._geometry.containsPoint(Y._TEMP_POINT)}calculateTints(){if(this.batchTint!==this.tint){this.batchTint=this.tint;const t=a.hex2rgb(this.tint,B);for(let e=0;e<this.batches.length;e++){const n=this.batches[e],i=n._batchRGB,s=(t[0]*i[0]*255<<16)+(t[1]*i[1]*255<<8)+(0|t[2]*i[2]*255);n._tintRGB=(s>>16)+(65280&s)+((255&s)<<16)}}}calculateVertices(){const t=this.transform._worldID;if(this._transformID===t)return;this._transformID=t;const e=this.transform.worldTransform,n=e.a,i=e.b,s=e.c,a=e.d,r=e.tx,l=e.ty,o=this._geometry.points,h=this.vertexData;let c=0;for(let t=0;t<o.length;t+=2){const e=o[t],u=o[t+1];h[c++]=n*e+s*u+r,h[c++]=a*u+i*e+l}}closePath(){const t=this.currentPath;return t&&(t.closeStroke=!0),this}setMatrix(t){return this._matrix=t,this}beginHole(){return this.finishPoly(),this._holeMode=!0,this}endHole(){return this.finishPoly(),this._holeMode=!1,this}destroy(t){this._geometry.refCount--,0===this._geometry.refCount&&this._geometry.dispose(),this._matrix=null,this.currentPath=null,this._lineStyle.destroy(),this._lineStyle=null,this._fillStyle.destroy(),this._fillStyle=null,this._geometry=null,this.shader=null,this.vertexData=null,this.batches.length=0,this.batches=null,super.destroy(t)}drawStar(t,e,n,i,s,a=0){return this.drawPolygon(new U(t,e,n,i,s,a))}}Y.__initStatic();class U extends e.Polygon{constructor(t,n,i,s,a,r=0){a=a||s/2;const l=-1*Math.PI/2+r,o=2*i,h=e.PI_2/o,c=[];for(let e=0;e<o;e++){const i=e%2?a:s,r=e*h+l;c.push(t+i*Math.cos(r),n+i*Math.sin(r))}super(c)}}t.BATCH_POOL=P,t.BatchDrawCall=h,t.BatchPart=c,t.BatchStyleArray=o,t.BuildData=p,t.CircleBuilder=_,t.DRAW_CALL_POOL=b,t.DashLineShader=class extends L{constructor(t){const e={maxStyles:16,maxTextures:1};super(e,new A(e,void 0,"\nvarying vec4 vColor;\nvarying vec4 vDistance;\nvarying float vType;\nvarying float vTextureId;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\nuniform float dash;\nuniform float gap;\n\nvoid main(void){\n    float alpha = 1.0;\n    float lineWidth = vDistance.w;\n    if (vType < 0.5) {\n        float left = max(vDistance.x - 0.5, -vDistance.w);\n        float right = min(vDistance.x + 0.5, vDistance.w);\n        float near = vDistance.y - 0.5;\n        float far = min(vDistance.y + 0.5, 0.0);\n        float top = vDistance.z - 0.5;\n        float bottom = min(vDistance.z + 0.5, 0.0);\n        alpha = max(right - left, 0.0) * max(bottom - top, 0.0) * max(far - near, 0.0);\n    } else if (vType < 1.5) {\n        float a1 = clamp(vDistance.x + 0.5 - lineWidth, 0.0, 1.0);\n        float a2 = clamp(vDistance.x + 0.5 + lineWidth, 0.0, 1.0);\n        float b1 = clamp(vDistance.y + 0.5 - lineWidth, 0.0, 1.0);\n        float b2 = clamp(vDistance.y + 0.5 + lineWidth, 0.0, 1.0);\n        alpha = a2 * b2 - a1 * b1;\n    } else if (vType < 2.5) {\n        alpha *= max(min(vDistance.x + 0.5, 1.0), 0.0);\n        alpha *= max(min(vDistance.y + 0.5, 1.0), 0.0);\n        alpha *= max(min(vDistance.z + 0.5, 1.0), 0.0);\n    } else {\n        float dist2 = sqrt(dot(vDistance.yz, vDistance.yz));\n        float rad = vDistance.w;\n        float left = max(dist2 - 0.5, -rad);\n        float right = min(dist2 + 0.5, rad);\n        // TODO: something has to be done about artifact at vDistance.x far side\n        alpha = 1.0 - step(vDistance.x, 0.0) * (1.0 - max(right - left, 0.0));\n    }\n\n    if (dash + gap > 1.0)\n    {\n        float travel = mod(vTravel + gap * 0.5, dash + gap) - (gap * 0.5);\n        float left = max(travel - 0.5, -0.5);\n        float right = min(travel + 0.5, gap + 0.5);\n        alpha *= max(0.0, right - left);\n    }\n\n    vec4 texColor;\n    float textureId = floor(vTextureId+0.5);\n    %FOR_LOOP%\n\n    gl_FragColor = vColor * texColor * alpha;\n}\n"),t||{dash:5,gap:8})}},t.FILL_COMMANDS=v,t.FillStyle=u,t.LineStyle=d,t.PolyBuilder=I,t.RectangleBuilder=x,t.RoundedRectangleBuilder=E,t.SegmentPacker=f,t.SmoothGraphics=Y,t.SmoothGraphicsData=y,t.SmoothGraphicsGeometry=D,t.SmoothGraphicsProgram=A,t.SmoothGraphicsShader=L,t.Star=U,t.matrixEquals=l,t.settings=J,Object.defineProperty(t,"__esModule",{value:!0})})),"undefined"!=typeof _pixi_graphics_smooth&&Object.assign(this.PIXI.smooth,_pixi_graphics_smooth);
//# sourceMappingURL=pixi-graphics-smooth.umd.min.js.map
