{"version":3,"file":"pixi-graphics-smooth.js","sources":["../src/core/BatchDrawCall.ts","../src/core/BatchPart.ts","../src/core/FillStyle.ts","../src/core/LineStyle.ts","../src/core/BuildData.ts","../src/core/const.ts","../src/core/SegmentPacker.ts","../src/core/SmoothGraphicsData.ts","../src/shapes/CircleBuilder.ts","../src/shapes/RectangleBuilder.ts","../src/shapes/RoundedRectangleBuilder.ts","../src/shapes/PolyBuilder.ts","../src/shapes/index.ts","../src/SmoothGraphicsGeometry.ts","../src/SmoothShader.ts","../src/settings.ts","../src/SmoothGraphics.ts","../src/DashLineShader.ts"],"sourcesContent":["import { Matrix } from '@pixi/math';\nimport { BaseTexture, BatchTextureArray, Shader, Texture } from '@pixi/core';\nimport { BLEND_MODES } from '@pixi/constants';\n\nexport interface IGraphicsBatchSettings {\n    maxStyles: number;\n    maxTextures: number;\n}\n\nexport function matrixEquals(th: Matrix, matrix: Matrix, eps = 1e-3)\n{\n    return this === matrix || Math.abs(th.a - matrix.a) < eps\n        && Math.abs(th.b - matrix.b) < eps\n        && Math.abs(th.c - matrix.c) < eps\n        && Math.abs(th.d - matrix.d) < eps\n        && Math.abs(th.tx - matrix.tx) < eps\n        && Math.abs(th.ty - matrix.ty) < eps;\n}\n\nexport class BatchStyleArray\n{\n    public textureIds: number[];\n    public matrices: Matrix[];\n    public lines: number[];\n    public count: number;\n\n    constructor()\n    {\n        this.textureIds = [];\n        this.matrices = [];\n        this.lines = [];\n        this.count = 0;\n        // TODO: mapCoord for atlas cases\n        // TODO: gradients?\n    }\n\n    clear(): void\n    {\n        for (let i = 0; i < this.count; i++)\n        {\n            this.textureIds[i] = null;\n            this.matrices[i] = null;\n        }\n        this.count = 0;\n    }\n\n    add(textureId: number, matrix: Matrix,\n        lineWidth: number, lineAlignment: number,\n        settings: IGraphicsBatchSettings): number\n    {\n        const { textureIds, matrices, lines, count } = this;\n\n        for (let i = 0; i < count; i++)\n        {\n            if (lines[i * 2] === lineWidth && lines[i * 2 + 1] === lineAlignment\n                && textureIds[i] === textureId && (matrixEquals(matrices[i], matrix)))\n            {\n                return i;\n            }\n        }\n        if (count >= settings.maxStyles)\n        {\n            return -1;\n        }\n        textureIds[count] = textureId;\n        matrices[count] = matrix;\n        lines[count * 2] = lineWidth;\n        lines[count * 2 + 1] = lineAlignment;\n        this.count++;\n\n        return count;\n    }\n}\n\nexport class BatchDrawCall\n{\n    texArray: BatchTextureArray;\n    styleArray: BatchStyleArray;\n    blend: BLEND_MODES;\n    start: number;\n    size: number;\n    data: any;\n    shader: Shader;\n    TICK: number;\n    settings: IGraphicsBatchSettings;\n\n    constructor()\n    {\n        this.texArray = new BatchTextureArray();\n        this.styleArray = new BatchStyleArray();\n        this.shader = null;\n        this.blend = BLEND_MODES.NORMAL;\n\n        this.start = 0;\n        this.size = 0;\n        this.TICK = 0; // for filling textures\n        this.settings = null;\n        /**\n         * data for uniforms or custom webgl state\n         * @member {object}\n         */\n        this.data = null;\n    }\n\n    clear()\n    {\n        this.texArray.clear();\n        this.styleArray.clear();\n        this.settings = null;\n        this.data = null;\n        this.shader = null;\n    }\n\n    begin(settings: IGraphicsBatchSettings, shader: Shader)\n    {\n        this.TICK = ++BaseTexture._globalBatch;\n        this.settings = settings;\n        this.shader = shader;\n        // start and size calculated outside\n        this.start = 0;\n        this.size = 0;\n        this.data = null;\n        if (shader && (shader as any).settings)\n        {\n            this.settings = (shader as any).settings;\n        }\n    }\n\n    check(shader: Shader): boolean\n    {\n        if (this.size === 0)\n        {\n            this.shader = shader;\n\n            return true;\n        }\n\n        return (this.shader === shader);\n    }\n\n    add(texture: Texture, matrix: Matrix, lineWidth: number, lineAlignment: number): number\n    {\n        const { texArray, TICK, styleArray, settings } = this;\n        const { baseTexture } = texture;\n        // check tex\n\n        if (baseTexture._batchEnabled !== TICK && texArray.count === settings.maxTextures)\n        {\n            return -1;\n        }\n        const loc = baseTexture._batchEnabled !== TICK ? texArray.count : baseTexture._batchLocation;\n        // check and add style\n        // add1 -> add2 only works in chain, not when there are several adds inside\n        const res = styleArray.add(loc, matrix || Matrix.IDENTITY, lineWidth, lineAlignment, settings);\n\n        if (res >= 0)\n        {\n            // SUCCESS here\n            // add tex\n            if (baseTexture._batchEnabled !== TICK)\n            {\n                baseTexture._batchEnabled = TICK;\n                baseTexture._batchLocation = texArray.count;\n                texArray.elements[texArray.count++] = baseTexture;\n            }\n        }\n\n        return res;\n    }\n}\n","import { LineStyle } from './LineStyle';\r\nimport { FillStyle } from './FillStyle';\r\n\r\nexport class BatchPart\r\n{\r\n    public style: LineStyle | FillStyle;\r\n    public start: number;\r\n    public size: number;\r\n    public jointEnd: number;\r\n    public attribStart: number;\r\n    public attribSize: number;\r\n    public styleId: number;\r\n    public rgba: number;\r\n\r\n    constructor()\r\n    {\r\n        this.reset();\r\n    }\r\n\r\n    public begin(style: LineStyle | FillStyle, startIndex: number, attribStart: number): void\r\n    {\r\n        this.reset();\r\n        this.style = style;\r\n        this.start = startIndex;\r\n        this.attribStart = attribStart;\r\n        this.jointEnd = 0;\r\n    }\r\n\r\n    public end(endIndex: number, endAttrib: number): void\r\n    {\r\n        this.attribSize = endAttrib - this.attribStart;\r\n        this.size = endIndex - this.start;\r\n    }\r\n\r\n    public reset(): void\r\n    {\r\n        this.style = null;\r\n        this.size = 0;\r\n        this.start = 0;\r\n        this.attribStart = 0;\r\n        this.attribSize = 0;\r\n        this.styleId = -1;\r\n        this.rgba = 0;\r\n        this.jointEnd = 0;\r\n    }\r\n}\r\n","import { Shader, Texture } from '@pixi/core';\nimport type { Matrix } from '@pixi/math';\n\nexport class FillStyle\n{\n    constructor()\n    {\n        this.reset();\n    }\n\n    color: number;\n    alpha: number;\n    texture: Texture;\n    matrix: Matrix;\n    matrixTex: Matrix;\n    shader: Shader;\n    visible: boolean;\n    smooth: boolean;\n\n    toJSON()\n    {\n        return this.copyTo({});\n    }\n\n    clone(): FillStyle\n    {\n        return this.copyTo(new FillStyle());\n    }\n\n    copyTo(obj: any): any\n    {\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.shader = this.shader;\n        obj.visible = this.visible;\n        obj.smooth = this.smooth;\n        obj.matrixTex = null;\n\n        return obj;\n    }\n\n    /**\n     * returns width multiplied by scaleMode\n     */\n    packLineWidth(): number\n    {\n        return 0;\n    }\n\n    reset()\n    {\n        this.color = 0xFFFFFF;\n\n        this.alpha = 1;\n\n        this.texture = Texture.WHITE;\n\n        this.matrix = null;\n\n        this.shader = null;\n\n        this.visible = false;\n\n        this.smooth = false;\n\n        this.matrixTex = null;\n    }\n\n    destroy()\n    {\n        this.texture = null;\n        this.matrix = null;\n        this.matrixTex = null;\n    }\n\n    getTextureMatrix()\n    {\n        const tex = this.texture;\n\n        if (!this.matrix)\n        {\n            return null;\n        }\n\n        if (tex.frame.width === tex.baseTexture.width\n            && tex.frame.height === tex.baseTexture.height)\n        {\n            return this.matrix;\n        }\n\n        if (!this.matrixTex)\n        {\n            this.matrixTex = this.matrix.clone();\n        }\n        else\n        {\n            this.matrixTex.copyFrom(this.matrix);\n        }\n        this.matrixTex.translate(Number(tex.frame.x), Number(tex.frame.y));\n\n        return this.matrixTex;\n    }\n}\n","import { LINE_CAP, LINE_JOIN } from '@pixi/graphics';\nimport { FillStyle } from './FillStyle';\n\nexport enum LINE_SCALE_MODE {\n    NONE = 'none',\n    NORMAL = 'normal',\n}\n\nexport class LineStyle extends FillStyle\n{\n    width: number;\n    alignment: number;\n\n    cap: LINE_CAP;\n    join: LINE_JOIN;\n    miterLimit: number;\n    scaleMode: LINE_SCALE_MODE;\n\n    clone(): LineStyle\n    {\n        return this.copyTo(new LineStyle());\n    }\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    copyTo(obj: any): LineStyle\n    {\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.shader = this.shader;\n        obj.visible = this.visible;\n        obj.width = this.width;\n        obj.alignment = this.alignment;\n        obj.cap = this.cap;\n        obj.join = this.join;\n        obj.miterLimit = this.miterLimit;\n        obj.scaleMode = this.scaleMode;\n\n        return obj;\n    }\n\n    /**\n     * returns width multiplied by scaleMode\n     */\n    packLineWidth(): number\n    {\n        return this.scaleMode === LINE_SCALE_MODE.NORMAL ? this.width : -this.width;\n    }\n\n    reset(): void\n    {\n        super.reset();\n\n        this.smooth = true;\n\n        this.color = 0x0;\n\n        this.width = 0;\n\n        this.alignment = 0.5;\n\n        this.cap = LINE_CAP.BUTT;\n        this.join = LINE_JOIN.MITER;\n        this.miterLimit = 10;\n        this.scaleMode = LINE_SCALE_MODE.NORMAL;\n    }\n}\n","export class BuildData\r\n{\r\n    verts: Array<number> = [];\r\n    joints: Array<number> = [];\r\n    vertexSize = 0;\r\n    indexSize = 0;\r\n    closePointEps = 1e-4;\r\n\r\n    clear()\r\n    {\r\n        this.verts.length = 0;\r\n        this.joints.length = 0;\r\n        this.vertexSize = 0;\r\n        this.indexSize = 0;\r\n    }\r\n\r\n    destroy()\r\n    {\r\n        this.verts.length = 0;\r\n        this.joints.length = 0;\r\n    }\r\n}\r\n","export enum JOINT_TYPE {\r\n    NONE = 0,\r\n    FILL = 1,\r\n    JOINT_BEVEL = 4,\r\n    JOINT_MITER = 8,\r\n    JOINT_ROUND = 12,\r\n    JOINT_CAP_BUTT = 16,\r\n    JOINT_CAP_SQUARE = 18,\r\n    JOINT_CAP_ROUND = 20,\r\n    FILL_EXPAND = 24,\r\n    CAP_BUTT = 1 << 5,\r\n    CAP_SQUARE = 2 << 5,\r\n    CAP_ROUND = 3 << 5,\r\n    CAP_BUTT2 = 4 << 5,\r\n}\r\n","import { BuildData } from './BuildData';\nimport { JOINT_TYPE } from './const';\n\nexport class SegmentPacker\n{\n    static vertsByJoint: Array<number> = [];\n\n    strideFloats = 12;\n\n    updateBufferSize(jointStart: number, jointLen: number, triangles: number, target: BuildData)\n    {\n        const { joints } = target;\n        let foundTriangle = false;\n\n        let vertexSize = 0;\n        let indexSize = 0;\n\n        for (let i = jointStart; i < jointStart + jointLen; i++)\n        {\n            const prevCap = joints[i] & ~31;\n            const joint = joints[i] & 31;\n\n            if (joint === JOINT_TYPE.FILL)\n            {\n                foundTriangle = true;\n                vertexSize++;\n                continue;\n            }\n\n            if (joint >= JOINT_TYPE.FILL_EXPAND)\n            {\n                vertexSize += 3;\n                indexSize += 3;\n                continue;\n            }\n\n            const vs = SegmentPacker.vertsByJoint[joint] + SegmentPacker.vertsByJoint[prevCap];\n\n            if (vs >= 4)\n            {\n                vertexSize += vs;\n                indexSize += 6 + (3 * Math.max(vs - 6, 0));\n            }\n        }\n        if (foundTriangle)\n        {\n            indexSize += triangles;\n        }\n\n        target.vertexSize += vertexSize;\n        target.indexSize += indexSize;\n    }\n\n    bufferPos = 0;\n    indexPos = 0;\n    bufFloat: Float32Array;\n    bufUint: Uint32Array;\n    indices: Uint16Array;\n    buildData: BuildData;\n\n    beginPack(buildData: BuildData, bufFloat: Float32Array, bufUint: Uint32Array, indices: Uint16Array, bufferPos = 0, indexPos = 0)\n    {\n        this.buildData = buildData;\n        this.bufFloat = bufFloat;\n        this.bufUint = bufUint;\n        this.indices = indices;\n        this.bufferPos = bufferPos;\n        this.indexPos = indexPos;\n    }\n\n    endPack()\n    {\n        this.buildData = null;\n        this.bufFloat = null;\n        this.bufUint = null;\n        this.indices = null;\n    }\n\n    packInterleavedGeometry(jointStart: number, jointLen: number, triangles: number[],\n        lineStyle: number, color: number)\n    {\n        const { bufFloat, bufUint, indices, buildData, strideFloats } = this;\n        const { joints, verts } = buildData;\n\n        let bufPos = this.bufferPos;\n        let indPos = this.indexPos;\n        let index = this.bufferPos / this.strideFloats;\n\n        // eslint-disable-next-line max-len\n        let x1: number; let y1: number; let x2: number; let y2: number; let prevX: number; let prevY: number; let nextX: number; let\n            nextY: number;\n        // let type: number;\n        let hasTriangle = false;\n\n        let travel = 0;\n\n        for (let j = jointStart; j < jointStart + jointLen; j++)\n        {\n            const fullJoint = joints[j];\n            const prevCap = joints[j] & ~31;\n            const joint = joints[j] & 31;\n\n            if (joint === JOINT_TYPE.FILL)\n            {\n                // just one vertex\n                hasTriangle = true;\n                x1 = verts[(j * 2)];\n                y1 = verts[(j * 2) + 1];\n                bufFloat[bufPos] = x1;\n                bufFloat[bufPos + 1] = y1;\n                bufFloat[bufPos + 2] = x1;\n                bufFloat[bufPos + 3] = y1;\n                bufFloat[bufPos + 4] = x1;\n                bufFloat[bufPos + 5] = y1;\n                bufFloat[bufPos + 6] = x1;\n                bufFloat[bufPos + 7] = y1;\n                bufFloat[bufPos + 8] = travel;\n                bufFloat[bufPos + 9] = 16 * joint;\n                bufFloat[bufPos + 10] = lineStyle;\n                bufUint[bufPos + 11] = color;\n                bufPos += strideFloats;\n                continue;\n            }\n\n            if (joint >= JOINT_TYPE.FILL_EXPAND)\n            {\n                prevX = verts[j * 2];\n                prevY = verts[(j * 2) + 1];\n                x1 = verts[(j * 2) + 2];\n                y1 = verts[(j * 2) + 3];\n                x2 = verts[(j * 2) + 4];\n                y2 = verts[(j * 2) + 5];\n\n                const bis = j + 3;\n\n                for (let i = 0; i < 3; i++)\n                {\n                    bufFloat[bufPos] = prevX;\n                    bufFloat[bufPos + 1] = prevY;\n                    bufFloat[bufPos + 2] = x1;\n                    bufFloat[bufPos + 3] = y1;\n                    bufFloat[bufPos + 4] = x2;\n                    bufFloat[bufPos + 5] = y2;\n                    bufFloat[bufPos + 6] = verts[(bis + i) * 2];\n                    bufFloat[bufPos + 7] = verts[((bis + i) * 2) + 1];\n\n                    bufFloat[bufPos + 8] = travel;\n                    bufFloat[bufPos + 9] = (16 * fullJoint) + i;\n                    bufFloat[bufPos + 10] = lineStyle;\n                    bufUint[bufPos + 11] = color;\n                    bufPos += strideFloats;\n                }\n\n                indices[indPos] = index;\n                indices[indPos + 1] = index + 1;\n                indices[indPos + 2] = index + 2;\n                indPos += 3;\n                index += 3;\n                continue;\n            }\n\n            const vs = SegmentPacker.vertsByJoint[joint] + SegmentPacker.vertsByJoint[prevCap];\n\n            if (vs === 0)\n            {\n                continue;\n            }\n            x1 = verts[j * 2];\n            y1 = verts[(j * 2) + 1];\n            x2 = verts[(j * 2) + 2];\n            y2 = verts[(j * 2) + 3];\n            // TODO: caps here\n            prevX = verts[(j * 2) - 2];\n            prevY = verts[(j * 2) - 1];\n\n            const dist = Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));\n\n            if (SegmentPacker.vertsByJoint[joint] === 0)\n            {\n                travel -= dist;\n            }\n\n            if ((joint & ~2) !== JOINT_TYPE.JOINT_CAP_BUTT)\n            {\n                nextX = verts[(j * 2) + 4];\n                nextY = verts[(j * 2) + 5];\n            }\n            else\n            {\n                nextX = x1;\n                nextY = y1;\n            }\n            // type = joint;\n\n            for (let i = 0; i < vs; i++)\n            {\n                bufFloat[bufPos] = prevX;\n                bufFloat[bufPos + 1] = prevY;\n                bufFloat[bufPos + 2] = x1;\n                bufFloat[bufPos + 3] = y1;\n                bufFloat[bufPos + 4] = x2;\n                bufFloat[bufPos + 5] = y2;\n                bufFloat[bufPos + 6] = nextX;\n                bufFloat[bufPos + 7] = nextY;\n                bufFloat[bufPos + 8] = travel;\n                bufFloat[bufPos + 9] = (16 * fullJoint) + i;\n                bufFloat[bufPos + 10] = lineStyle;\n                bufUint[bufPos + 11] = color;\n                bufPos += strideFloats;\n            }\n\n            travel += dist;\n\n            indices[indPos] = index;\n            indices[indPos + 1] = index + 1;\n            indices[indPos + 2] = index + 2;\n            indices[indPos + 3] = index;\n            indices[indPos + 4] = index + 2;\n            indices[indPos + 5] = index + 3;\n            indPos += 6;\n            for (let j = 5; j + 1 < vs; j++)\n            {\n                indices[indPos] = index + 4;\n                indices[indPos + 1] = index + j;\n                indices[indPos + 2] = index + j + 1;\n                indPos += 3;\n            }\n            index += vs;\n        }\n\n        if (hasTriangle)\n        {\n            for (let i = 0; i < triangles.length; i++)\n            {\n                indices[indPos + i] = triangles[i] + index;\n            }\n            indPos += triangles.length;\n        }\n\n        this.bufferPos = bufPos;\n        this.indexPos = indPos;\n    }\n}\n\nconst verts = SegmentPacker.vertsByJoint;\n\nfor (let i = 0; i < 256; i++)\n{ verts.push(0); }\n// simple fill\nverts[JOINT_TYPE.FILL] = 1;\n\nfor (let i = 0; i < 8; i++)\n{\n    verts[JOINT_TYPE.FILL_EXPAND + i] = 3;\n}\n\n// no caps for now\nverts[JOINT_TYPE.JOINT_BEVEL] = 4 + 3;\nverts[JOINT_TYPE.JOINT_BEVEL + 1] = 4 + 3;\nverts[JOINT_TYPE.JOINT_BEVEL + 2] = 4 + 3;\nverts[JOINT_TYPE.JOINT_BEVEL + 3] = 4 + 3;\nverts[JOINT_TYPE.JOINT_ROUND] = 4 + 5;\nverts[JOINT_TYPE.JOINT_ROUND + 1] = 4 + 5;\nverts[JOINT_TYPE.JOINT_ROUND + 2] = 4 + 5;\nverts[JOINT_TYPE.JOINT_ROUND + 3] = 4 + 5;\nverts[JOINT_TYPE.JOINT_MITER] = 4 + 4;\nverts[JOINT_TYPE.JOINT_MITER + 1] = 4 + 4;\nverts[JOINT_TYPE.JOINT_MITER + 2] = 4;\nverts[JOINT_TYPE.JOINT_MITER + 3] = 4;\nverts[JOINT_TYPE.JOINT_CAP_BUTT] = 4;\nverts[JOINT_TYPE.JOINT_CAP_BUTT + 1] = 4;\nverts[JOINT_TYPE.JOINT_CAP_SQUARE] = 4;\nverts[JOINT_TYPE.JOINT_CAP_SQUARE + 1] = 4;\nverts[JOINT_TYPE.JOINT_CAP_ROUND] = 4 + 4;\nverts[JOINT_TYPE.JOINT_CAP_ROUND + 1] = 4 + 4;\n\nverts[JOINT_TYPE.CAP_ROUND] = 4;\n","import type { Matrix, SHAPES, IShape } from '@pixi/math';\r\nimport { LINE_CAP, LINE_JOIN } from '@pixi/graphics';\r\nimport { JOINT_TYPE } from './const';\r\nimport { FillStyle } from './FillStyle';\r\nimport { LineStyle } from './LineStyle';\r\n\r\n/**\r\n * A class to contain data useful for Graphics objects\r\n *\r\n * @class\r\n * @memberof PIXI\r\n */\r\nexport class SmoothGraphicsData\r\n{\r\n    shape: IShape;\r\n    lineStyle: LineStyle;\r\n    fillStyle: FillStyle;\r\n    matrix: Matrix;\r\n    type: SHAPES;\r\n    holes: Array<SmoothGraphicsData>;\r\n\r\n    // result of simplification\r\n    closeStroke: boolean;\r\n    points: number[];\r\n    triangles: number[];\r\n    // indices in build\r\n    attribStart: number;\r\n    fillStart: number;\r\n    fillLen: number;\r\n    strokeStart: number;\r\n    strokeLen: number;\r\n    fillAA: boolean;\r\n\r\n    constructor(shape: IShape, fillStyle: FillStyle = null, lineStyle: LineStyle = null, matrix: Matrix = null)\r\n    {\r\n        this.shape = shape;\r\n\r\n        this.lineStyle = lineStyle;\r\n\r\n        this.fillStyle = fillStyle;\r\n\r\n        this.matrix = matrix;\r\n\r\n        this.type = shape.type;\r\n\r\n        this.points = [];\r\n\r\n        this.holes = [];\r\n\r\n        this.triangles = [];\r\n\r\n        this.closeStroke = false;\r\n\r\n        this.clearBuild();\r\n    }\r\n\r\n    public clearPath()\r\n    {\r\n        this.points.length = 0;\r\n        this.closeStroke = true;\r\n    }\r\n\r\n    public clearBuild()\r\n    {\r\n        this.triangles.length = 0;\r\n        this.fillStart = 0;\r\n        this.fillLen = 0;\r\n        this.strokeStart = 0;\r\n        this.strokeLen = 0;\r\n        this.fillAA = false;\r\n    }\r\n\r\n    public clone(): SmoothGraphicsData\r\n    {\r\n        return new SmoothGraphicsData(\r\n            this.shape,\r\n            this.fillStyle,\r\n            this.lineStyle,\r\n            this.matrix\r\n        );\r\n    }\r\n\r\n    public capType()\r\n    {\r\n        let cap: number;\r\n\r\n        switch (this.lineStyle.cap)\r\n        {\r\n            case LINE_CAP.SQUARE:\r\n                cap = JOINT_TYPE.CAP_SQUARE;\r\n                break;\r\n            case LINE_CAP.ROUND:\r\n                cap = JOINT_TYPE.CAP_ROUND;\r\n                break;\r\n            default:\r\n                cap = JOINT_TYPE.CAP_BUTT;\r\n                break;\r\n        }\r\n\r\n        return cap;\r\n    }\r\n\r\n    public goodJointType() {\r\n        let joint: number;\r\n\r\n        switch (this.lineStyle.join)\r\n        {\r\n            case LINE_JOIN.BEVEL:\r\n                joint = JOINT_TYPE.JOINT_BEVEL;\r\n                break;\r\n            case LINE_JOIN.ROUND:\r\n                joint = JOINT_TYPE.JOINT_ROUND;\r\n                break;\r\n            default:\r\n                joint = JOINT_TYPE.JOINT_MITER + 3;\r\n                break;\r\n        }\r\n\r\n        return joint;\r\n    }\r\n\r\n    public jointType()\r\n    {\r\n        let joint: number;\r\n\r\n        switch (this.lineStyle.join)\r\n        {\r\n            case LINE_JOIN.BEVEL:\r\n                joint = JOINT_TYPE.JOINT_BEVEL;\r\n                break;\r\n            case LINE_JOIN.ROUND:\r\n                joint = JOINT_TYPE.JOINT_ROUND;\r\n                break;\r\n            default:\r\n                joint = JOINT_TYPE.JOINT_MITER;\r\n                break;\r\n        }\r\n\r\n        return joint;\r\n    }\r\n\r\n    public destroy(): void\r\n    {\r\n        this.shape = null;\r\n        this.holes.length = 0;\r\n        this.holes = null;\r\n        this.points.length = 0;\r\n        this.points = null;\r\n        this.lineStyle = null;\r\n        this.fillStyle = null;\r\n        this.triangles = null;\r\n    }\r\n}\r\n","// for type only\nimport { SHAPES } from '@pixi/math';\n\nimport type { Circle, Ellipse } from '@pixi/math';\nimport type { IShapeBuilder } from '../core/IShapeBuilder';\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\nimport { BuildData } from '../core/BuildData';\nimport { JOINT_TYPE } from '../core/const';\n\nexport class CircleBuilder implements IShapeBuilder\n{\n    path(graphicsData: SmoothGraphicsData, _target: BuildData)\n    {\n        // need to convert points to a nice regular data\n        const circleData = graphicsData.shape as Circle;\n        const points = graphicsData.points;\n        const x = circleData.x;\n        const y = circleData.y;\n        let width;\n        let height;\n        // TODO - bit hacky??\n\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            width = circleData.radius;\n            height = circleData.radius;\n        }\n        else\n        {\n            const ellipseData = graphicsData.shape as Ellipse;\n\n            width = ellipseData.width;\n            height = ellipseData.height;\n        }\n\n        if (width <= 0 || height <= 0)\n        {\n            return;\n        }\n\n        points.push(x, y);\n\n        let totalSegs = Math.floor(30 * Math.sqrt(circleData.radius))\n            || Math.floor(15 * Math.sqrt(width + height));\n\n        totalSegs /= 2.3;\n        if (totalSegs < 3)\n        {\n            totalSegs = 3;\n        }\n\n        const seg = (Math.PI * 2) / totalSegs;\n\n        for (let i = 0; i < totalSegs - 0.5; i++)\n        {\n            points.push(\n                x + (Math.sin(-seg * i) * width),\n                y + (Math.cos(-seg * i) * height)\n            );\n        }\n    }\n\n    fill(graphicsData: SmoothGraphicsData, target: BuildData)\n    {\n        const { verts, joints } = target;\n        const { points, triangles } = graphicsData;\n\n        let vertPos = 1;\n        const center = 0;\n\n        if (!graphicsData.fillAA)\n        {\n            for (let i = 0; i < points.length; i += 2)\n            {\n                verts.push(points[i], points[i + 1]);\n                joints.push(JOINT_TYPE.FILL);\n                if (i > 2)\n                {\n                    triangles.push(vertPos++, center, vertPos);\n                }\n            }\n            triangles.push(vertPos, center, 1);\n\n            return;\n        }\n\n        const cx = points[0]; const\n            cy = points[1];\n        const rad = (graphicsData.shape as Circle).radius;\n\n        for (let i = 2; i < points.length; i += 2)\n        {\n            // const prev = i;\n            const cur = i;\n            const next = i + 2 < points.length ? i + 2 : 2;\n\n            verts.push(cx);\n            verts.push(cy);\n            verts.push(points[cur]);\n            verts.push(points[cur + 1]);\n            verts.push(points[next]);\n            verts.push(points[next + 1]);\n\n            verts.push(0);\n            verts.push(0);\n            verts.push((points[cur] - cx) / rad);\n            verts.push((points[cur + 1] - cy) / rad);\n            verts.push((points[next] - cx) / rad);\n            verts.push((points[next + 1] - cy) / rad);\n\n            joints.push(JOINT_TYPE.FILL_EXPAND + 2);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n        }\n    }\n\n    line(graphicsData: SmoothGraphicsData, target: BuildData): void\n    {\n        const { verts, joints } = target;\n        const { points } = graphicsData;\n        const joint = graphicsData.goodJointType();\n        const len = points.length;\n\n        verts.push(points[len - 2], points[len - 1]);\n        joints.push(JOINT_TYPE.NONE);\n        for (let i = 2; i < len; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n            joints.push(joint);\n        }\n        verts.push(points[2], points[3]);\n        joints.push(JOINT_TYPE.NONE);\n        verts.push(points[4], points[5]);\n        joints.push(JOINT_TYPE.NONE);\n    }\n}\n","import type { Rectangle } from '@pixi/math';\r\nimport type { IShapeBuilder } from '../core/IShapeBuilder';\r\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\r\nimport { BuildData } from '../core/BuildData';\r\nimport { JOINT_TYPE } from '../core/const';\r\n\r\nexport class RectangleBuilder implements IShapeBuilder\r\n{\r\n    path(graphicsData: SmoothGraphicsData, _target: BuildData)\r\n    {\r\n        // --- //\r\n        // need to convert points to a nice regular data\r\n        //\r\n        const rectData = graphicsData.shape as Rectangle;\r\n        const x = rectData.x;\r\n        const y = rectData.y;\r\n        const width = rectData.width;\r\n        const height = rectData.height;\r\n        const points = graphicsData.points;\r\n\r\n        points.length = 0;\r\n\r\n        points.push(x, y,\r\n            x + width, y,\r\n            x + width, y + height,\r\n            x, y + height);\r\n    }\r\n\r\n    line(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points } = graphicsData;\r\n\r\n        const joint = graphicsData.goodJointType();\r\n        const len = points.length;\r\n\r\n        verts.push(points[len - 2], points[len - 1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        for (let i = 0; i < len; i += 2)\r\n        {\r\n            verts.push(points[i], points[i + 1]);\r\n            joints.push(joint);\r\n        }\r\n        verts.push(points[0], points[1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        verts.push(points[2], points[3]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n    }\r\n\r\n    fill(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points, triangles } = graphicsData;\r\n\r\n        triangles.length = 0;\r\n\r\n        verts.push(points[0], points[1],\r\n            points[2], points[3],\r\n            points[4], points[5],\r\n            points[6], points[7]);\r\n\r\n        joints.push(JOINT_TYPE.FILL, JOINT_TYPE.FILL, JOINT_TYPE.FILL, JOINT_TYPE.FILL);\r\n        triangles.push(0, 1, 2, 0, 2, 3);\r\n    }\r\n}\r\n","import type { IShapeBuilder } from '../core/IShapeBuilder';\r\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\r\nimport { BuildData } from '../core/BuildData';\r\nimport { RoundedRectangle } from '@pixi/math';\r\nimport { earcut } from '@pixi/utils';\r\nimport { JOINT_TYPE } from '../core/const';\r\n\r\nfunction getPt(n1: number, n2: number, perc: number): number\r\n{\r\n    const diff = n2 - n1;\r\n\r\n    return n1 + (diff * perc);\r\n}\r\n\r\nfunction quadraticBezierCurve(\r\n    fromX: number, fromY: number,\r\n    cpX: number, cpY: number,\r\n    toX: number, toY: number,\r\n    out: Array<number> = []): Array<number>\r\n{\r\n    const n = 20;\r\n    const points = out;\r\n\r\n    let xa = 0;\r\n    let ya = 0;\r\n    let xb = 0;\r\n    let yb = 0;\r\n    let x = 0;\r\n    let y = 0;\r\n\r\n    for (let i = 0, j = 0; i <= n; ++i)\r\n    {\r\n        j = i / n;\r\n\r\n        // The Green Line\r\n        xa = getPt(fromX, cpX, j);\r\n        ya = getPt(fromY, cpY, j);\r\n        xb = getPt(cpX, toX, j);\r\n        yb = getPt(cpY, toY, j);\r\n\r\n        // The Black Dot\r\n        x = getPt(xa, xb, j);\r\n        y = getPt(ya, yb, j);\r\n\r\n        points.push(x, y);\r\n    }\r\n\r\n    return points;\r\n}\r\n\r\nexport class RoundedRectangleBuilder implements IShapeBuilder\r\n{\r\n    path(graphicsData: SmoothGraphicsData, _target: BuildData)\r\n    {\r\n        const rrectData = graphicsData.shape as RoundedRectangle;\r\n        const { points } = graphicsData;\r\n        const x = rrectData.x;\r\n        const y = rrectData.y;\r\n        const width = rrectData.width;\r\n        const height = rrectData.height;\r\n\r\n        // Don't allow negative radius or greater than half the smallest width\r\n        const radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));\r\n\r\n        points.length = 0;\r\n\r\n        // No radius, do a simple rectangle\r\n        if (!radius)\r\n        {\r\n            points.push(x, y,\r\n                x + width, y,\r\n                x + width, y + height,\r\n                x, y + height);\r\n        }\r\n        else\r\n        {\r\n            quadraticBezierCurve(x, y + radius,\r\n                x, y,\r\n                x + radius, y,\r\n                points);\r\n            quadraticBezierCurve(x + width - radius,\r\n                y, x + width, y,\r\n                x + width, y + radius,\r\n                points);\r\n            quadraticBezierCurve(x + width, y + height - radius,\r\n                x + width, y + height,\r\n                x + width - radius, y + height,\r\n                points);\r\n            quadraticBezierCurve(x + radius, y + height,\r\n                x, y + height,\r\n                x, y + height - radius,\r\n                points);\r\n        }\r\n    }\r\n\r\n    line(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points } = graphicsData;\r\n\r\n\r\n        const joint = points.length === 8 // we dont need joints for arcs\r\n            ? graphicsData.goodJointType() : JOINT_TYPE.JOINT_MITER + 3;\r\n        const len = points.length;\r\n\r\n        verts.push(points[len - 2], points[len - 1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        for (let i = 0; i < len; i += 2)\r\n        {\r\n            verts.push(points[i], points[i + 1]);\r\n            joints.push(joint);\r\n        }\r\n        verts.push(points[0], points[1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        verts.push(points[2], points[3]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n    }\r\n\r\n    fill(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points } = graphicsData;\r\n\r\n        graphicsData.triangles = earcut(points, null, 2);\r\n\r\n        for (let i = 0, j = points.length; i < j; i++)\r\n        {\r\n            verts.push(points[i], points[++i]);\r\n            joints.push(JOINT_TYPE.FILL);\r\n        }\r\n    }\r\n}\r\n","import type { IShapeBuilder } from '../core/IShapeBuilder';\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\nimport { BuildData } from '../core/BuildData';\nimport { JOINT_TYPE } from '../core/const';\nimport { Point, Polygon } from '@pixi/math';\nimport { earcut } from '@pixi/utils';\n\nconst tempArr: Array<number> = [];\n\nexport class PolyBuilder implements IShapeBuilder\n{\n    path(graphicsData: SmoothGraphicsData, buildData: BuildData)\n    {\n        const shape = graphicsData.shape as Polygon;\n        const points = graphicsData.points = shape.points.slice();\n        const eps = buildData.closePointEps;\n        const eps2 = eps * eps;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        const firstPoint = new Point(points[0], points[1]);\n        const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n        const closedShape = graphicsData.closeStroke = shape.closeStroke;\n\n        let len = points.length;\n        let newLen = 2;\n\n        // 1. remove equal points\n        for (let i = 2; i < len; i += 2)\n        {\n            const x1 = points[i - 2]; const y1 = points[i - 1]; const x2 = points[i]; const\n                y2 = points[i + 1];\n            let flag = true;\n\n            if (Math.abs(x1 - x2) < eps\n                && Math.abs(y1 - y2) < eps)\n            {\n                flag = false;\n            }\n\n            if (flag)\n            {\n                points[newLen] = points[i];\n                points[newLen + 1] = points[i + 1];\n                newLen += 2;\n            }\n        }\n        points.length = len = newLen;\n\n        newLen = 2;\n        // 2. remove middle points\n        for (let i = 2; i + 2 < len; i += 2)\n        {\n            let x1 = points[i - 2]; let y1 = points[i - 1]; const x2 = points[i]; const y2 = points[i + 1];\n            let x3 = points[i + 2]; let\n                y3 = points[i + 3];\n\n            x1 -= x2;\n            y1 -= y2;\n            x3 -= x2;\n            y3 -= y2;\n            let flag = true;\n\n            if (Math.abs(x3 * y1 - y3 * x1) < eps2)\n            {\n                if (x1 * x3 + y1 * y3 < -eps2)\n                {\n                    flag = false;\n                }\n            }\n\n            if (flag)\n            {\n                points[newLen] = points[i];\n                points[newLen + 1] = points[i + 1];\n                newLen += 2;\n            }\n        }\n        points[newLen] = points[len - 2];\n        points[newLen + 1] = points[len - 1];\n        newLen += 2;\n\n        points.length = len = newLen;\n\n        if (len <= 2)\n        {\n            // suddenly, nothing\n            return;\n        }\n\n        if (closedShape)\n        {\n            // first point should be last point in closed line!\n            const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n                && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n            if (closedPath)\n            {\n                points.pop();\n                points.pop();\n            }\n        }\n    }\n\n    line(graphicsData: SmoothGraphicsData, buildData: BuildData)\n    {\n        const { closeStroke, points } = graphicsData;\n        const eps = buildData.closePointEps;\n        // const eps2 = eps * eps;\n        const len = points.length;\n        // const style = graphicsData.lineStyle;\n\n        if (len <= 2)\n        {\n            return;\n        }\n        const { verts, joints } = buildData;\n\n        // TODO: alignment\n\n        const joint = graphicsData.jointType();\n        const cap = graphicsData.capType();\n        let prevCap = 0;\n\n        let prevX: number; let\n            prevY: number;\n\n        if (closeStroke)\n        {\n            prevX = points[len - 2];\n            prevY = points[len - 1];\n            joints.push(JOINT_TYPE.NONE);\n        }\n        else\n        {\n            prevX = points[2];\n            prevY = points[3];\n            if (cap === JOINT_TYPE.CAP_ROUND)\n            {\n                verts.push(points[0], points[1]);\n                joints.push(JOINT_TYPE.NONE);\n                joints.push(JOINT_TYPE.CAP_ROUND);\n                prevCap = 0;\n            }\n            else\n            {\n                prevCap = cap;\n                joints.push(JOINT_TYPE.NONE);\n            }\n        }\n        verts.push(prevX, prevY);\n\n        /* Line segments of interest where (x1,y1) forms the corner. */\n        for (let i = 0; i < len; i += 2)\n        {\n            const x1 = points[i]; const\n                y1 = points[i + 1];\n\n            let x2: number; let\n                y2: number;\n\n            if (i + 2 < len)\n            {\n                x2 = points[i + 2];\n                y2 = points[i + 3];\n            }\n            else\n            {\n                x2 = points[0];\n                y2 = points[1];\n            }\n\n            const dx = x2 - x1;\n            const dy = y2 - y1;\n            let nextX: number; let\n                nextY: number;\n\n            let endJoint = joint;\n\n            if (i + 2 >= len)\n            {\n                nextX = points[2];\n                nextY = points[3];\n                if (!closeStroke)\n                {\n                    endJoint = JOINT_TYPE.NONE;\n                }\n            }\n            else if (i + 4 >= len)\n            {\n                nextX = points[0];\n                nextY = points[1];\n                if (!closeStroke)\n                {\n                    if (cap === JOINT_TYPE.CAP_ROUND)\n                    {\n                        endJoint = JOINT_TYPE.JOINT_CAP_ROUND;\n                    }\n                    if (cap === JOINT_TYPE.CAP_BUTT)\n                    {\n                        endJoint = JOINT_TYPE.JOINT_CAP_BUTT;\n                    }\n                    if (cap === JOINT_TYPE.CAP_SQUARE)\n                    {\n                        endJoint = JOINT_TYPE.JOINT_CAP_SQUARE;\n                    }\n                }\n            }\n            else\n            {\n                nextX = points[i + 4];\n                nextY = points[i + 5];\n            }\n\n            const dx3 = x1 - prevX;\n            const dy3 = y1 - prevY;\n\n            if (joint >= JOINT_TYPE.JOINT_BEVEL && joint <= JOINT_TYPE.JOINT_MITER)\n            {\n                const dx2 = nextX - x2;\n                const dy2 = nextY - y2;\n\n                if (endJoint >= JOINT_TYPE.JOINT_BEVEL\n                    && endJoint <= JOINT_TYPE.JOINT_MITER + 3)\n                {\n                    const D = dx2 * dy - dy2 * dx;\n\n                    if (Math.abs(D) < eps)\n                    {\n                        switch (joint & ~3)\n                        {\n                            case JOINT_TYPE.JOINT_ROUND:\n                                endJoint = JOINT_TYPE.JOINT_CAP_ROUND;\n                                break;\n                            default:\n                                endJoint = JOINT_TYPE.JOINT_CAP_BUTT;\n                                break;\n                        }\n                    }\n                }\n\n                if (joint === JOINT_TYPE.JOINT_MITER)\n                {\n                    let jointAdd = 0;\n\n                    if (dx3 * dx + dy3 * dy > -eps)\n                    {\n                        jointAdd++;\n                    }\n                    if (endJoint === JOINT_TYPE.JOINT_MITER && dx2 * dx + dy2 * dy > -eps)\n                    {\n                        jointAdd += 2;\n                    }\n                    endJoint += jointAdd;\n                }\n            }\n            if (prevCap === 0)\n            {\n                if (Math.abs(dx3 * dy - dy3 * dx) < eps)\n                {\n                    prevCap = JOINT_TYPE.CAP_BUTT2;\n                }\n            }\n            endJoint += prevCap;\n            prevCap = 0;\n\n            verts.push(x1, y1);\n            joints.push(endJoint);\n\n            prevX = x1;\n            prevY = y1;\n        }\n\n        if (closeStroke)\n        {\n            verts.push(points[0], points[1]);\n            joints.push(JOINT_TYPE.NONE);\n            verts.push(points[2], points[3]);\n            joints.push(JOINT_TYPE.NONE);\n        }\n        else\n        {\n            verts.push(points[len - 4], points[len - 3]);\n            joints.push(JOINT_TYPE.NONE);\n        }\n    }\n\n    fill(graphicsData: SmoothGraphicsData, buildData: BuildData)\n    {\n        let points = graphicsData.points;\n        // TODO: simplify holes too!\n        const holes = graphicsData.holes;\n        const eps = buildData.closePointEps;\n\n        const { verts, joints } = buildData;\n\n        if (points.length < 6)\n        {\n            return;\n        }\n        const holeArray = [];\n        let len = points.length;\n        // Process holes..\n\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n\n            holeArray.push(points.length / 2);\n            points = points.concat(hole.points);\n        }\n\n        // TODO: reduce size later?\n        const pn = tempArr;\n\n        if (pn.length < points.length)\n        {\n            pn.length = points.length;\n        }\n        const start = 0;\n\n        for (let i = 0; i <= holeArray.length; i++)\n        {\n            let finish = len / 2;\n\n            if (i > 0)\n            {\n                if (i < holeArray.length)\n                {\n                    finish = holeArray[i];\n                }\n                else\n                {\n                    finish = (points.length >> 1);\n                }\n            }\n            pn[start * 2] = finish - 1;\n            pn[(finish - 1) * 2 + 1] = 0;\n            for (let j = start; j + 1 < finish; j++)\n            {\n                pn[j * 2 + 1] = j + 1;\n                pn[j * 2 + 2] = j;\n            }\n        }\n\n        // sort color\n        graphicsData.triangles = earcut(points, holeArray, 2);\n\n        if (!graphicsData.triangles)\n        {\n            return;\n        }\n\n        if (!graphicsData.fillAA)\n        {\n            for (let i = 0; i < points.length; i += 2)\n            {\n                verts.push(points[i], points[i + 1]);\n                joints.push(JOINT_TYPE.FILL);\n            }\n\n            return;\n        }\n\n        const { triangles } = graphicsData;\n\n        len = points.length;\n\n        for (let i = 0; i < triangles.length; i += 3)\n        {\n            // TODO: holes prev/next!!!\n            let flag = 0;\n\n            for (let j = 0; j < 3; j++)\n            {\n                const ind1 = triangles[i + j];\n                const ind2 = triangles[i + (j + 1) % 3];\n\n                if (pn[ind1 * 2] === ind2 || pn[ind1 * 2 + 1] === ind2)\n                {\n                    flag |= (1 << j);\n                }\n            }\n            joints.push(JOINT_TYPE.FILL_EXPAND + flag);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n        }\n\n        // bisect, re-using pn\n        for (let ind = 0; ind < len / 2; ind++)\n        {\n            const prev = pn[ind * 2];\n            const next = pn[ind * 2 + 1];\n            let nx1 = (points[next * 2 + 1] - points[ind * 2 + 1]); let\n                ny1 = -(points[next * 2] - points[ind * 2]);\n            let nx2 = (points[ind * 2 + 1] - points[prev * 2 + 1]); let\n                ny2 = -(points[ind * 2] - points[prev * 2]);\n            const D1 = Math.sqrt(nx1 * nx1 + ny1 * ny1);\n\n            nx1 /= D1;\n            ny1 /= D1;\n            const D2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n\n            nx2 /= D2;\n            ny2 /= D2;\n\n            let bx = (nx1 + nx2);\n            let by = (ny1 + ny2);\n            const D = bx * nx1 + by * ny1;\n\n            if (Math.abs(D) < eps)\n            {\n                bx = nx1;\n                by = ny1;\n            }\n            else\n            {\n                bx /= D;\n                by /= D;\n            }\n            pn[ind * 2] = bx;\n            pn[ind * 2 + 1] = by;\n        }\n\n        for (let i = 0; i < triangles.length; i += 3)\n        {\n            const prev = triangles[i];\n            const ind = triangles[i + 1];\n            const next = triangles[i + 2];\n            const nx1 = (points[next * 2 + 1] - points[ind * 2 + 1]); const\n                ny1 = -(points[next * 2] - points[ind * 2]);\n            const nx2 = (points[ind * 2 + 1] - points[prev * 2 + 1]); const\n                ny2 = -(points[ind * 2] - points[prev * 2]);\n\n            let j1 = 1;\n\n            if (nx1 * ny2 - nx2 * ny1 > 0.0)\n            {\n                j1 = 2;\n            }\n\n            for (let j = 0; j < 3; j++)\n            {\n                const ind = triangles[i + (j * j1) % 3];\n\n                verts.push(points[ind * 2], points[ind * 2 + 1]);\n            }\n            for (let j = 0; j < 3; j++)\n            {\n                const ind = triangles[i + (j * j1) % 3];\n\n                verts.push(pn[ind * 2], pn[ind * 2 + 1]);\n            }\n        }\n    }\n}\n","import { SHAPES } from '@pixi/math';\r\nimport { IShapeBuilder } from '../core/IShapeBuilder';\r\nimport { CircleBuilder } from './CircleBuilder';\r\nimport { RectangleBuilder } from './RectangleBuilder';\r\nimport { RoundedRectangleBuilder } from './RoundedRectangleBuilder';\r\nimport { PolyBuilder } from './PolyBuilder';\r\n\r\nexport const FILL_COMMANDS: Record<SHAPES, IShapeBuilder> = {\r\n    [SHAPES.POLY]: new PolyBuilder(),\r\n    [SHAPES.CIRC]: new CircleBuilder(),\r\n    [SHAPES.ELIP]: new CircleBuilder(),\r\n    [SHAPES.RECT]: new RectangleBuilder(),\r\n    [SHAPES.RREC]: new RoundedRectangleBuilder()\r\n};\r\n\r\nexport { CircleBuilder, RectangleBuilder, RoundedRectangleBuilder, PolyBuilder };\r\n","import { SmoothGraphicsData } from './core/SmoothGraphicsData';\n\nimport { FILL_COMMANDS } from './shapes';\n\nimport {\n    Buffer,\n    Geometry,\n} from '@pixi/core';\n\nimport { WRAP_MODES, TYPES } from '@pixi/constants';\nimport { SHAPES, Point, Matrix } from '@pixi/math';\nimport { premultiplyTint } from '@pixi/utils';\nimport { Bounds } from '@pixi/display';\n\nimport type { Circle, Ellipse, Polygon, Rectangle, RoundedRectangle, IPointData } from '@pixi/math';\nimport { BuildData } from './core/BuildData';\nimport { SegmentPacker } from './core/SegmentPacker';\nimport { LineStyle } from './core/LineStyle';\nimport { FillStyle } from './core/FillStyle';\nimport { BatchPart } from './core/BatchPart';\nimport { BatchDrawCall, IGraphicsBatchSettings, matrixEquals } from './core/BatchDrawCall';\n\n/*\n * Complex shape type\n * @todo Move to Math shapes\n */\nexport type IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\n\nexport const BATCH_POOL: Array<BatchPart> = [];\nexport const DRAW_CALL_POOL: Array<BatchDrawCall> = [];\n\nconst tmpPoint = new Point();\nconst tmpBounds = new Bounds();\n\nexport class SmoothGraphicsGeometry extends Geometry\n{\n    public static BATCHABLE_SIZE = 100;\n\n    public boundsPadding: number;\n\n    indicesUint16: Uint16Array | Uint32Array = null;\n    batchable: boolean;\n\n    buildData: BuildData;\n\n    get points()\n    {\n        return this.buildData.verts;\n    }\n\n    get closePointEps()\n    {\n        return this.buildData.closePointEps;\n    }\n\n    graphicsData: Array<SmoothGraphicsData>;\n    drawCalls: Array<BatchDrawCall>;\n    batchDirty: number;\n    batches: Array<BatchPart>;\n    packer: SegmentPacker;\n    packSize: number;\n    pack32index: boolean;\n    strideFloats: number;\n\n    protected dirty: number;\n    protected cacheDirty: number;\n    protected clearDirty: number;\n    protected shapeBuildIndex: number;\n    protected shapeBatchIndex: number;\n    protected _bounds: Bounds;\n    protected boundsDirty: number;\n\n    _buffer: Buffer;\n    _indexBuffer: Buffer;\n    _bufferFloats: Float32Array;\n    _bufferUint: Uint32Array;\n\n    initAttributes(_static: boolean)\n    {\n        this._buffer = new Buffer(null, _static, false);\n        this._bufferFloats = new Float32Array();\n        this._bufferUint = new Uint32Array();\n\n        this._indexBuffer = new Buffer(null, _static, true);\n        this.addAttribute('aPrev', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aPoint1', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aPoint2', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aNext', this._buffer, 2, false, TYPES.FLOAT)\n            .addAttribute('aTravel', this._buffer, 1, false, TYPES.FLOAT)\n            // number of vertex\n            .addAttribute('aVertexJoint', this._buffer, 1, false, TYPES.FLOAT)\n            // line width, alignment\n            .addAttribute('aStyleId', this._buffer, 1, false, TYPES.FLOAT)\n            // the usual\n            .addAttribute('aColor', this._buffer, 4, true, TYPES.UNSIGNED_BYTE)\n            .addIndex(this._indexBuffer);\n\n        this.strideFloats = 12;\n    }\n\n    constructor()\n    {\n        super();\n\n        this.initAttributes(false);\n\n        this.buildData = new BuildData();\n\n        this.graphicsData = [];\n\n        this.dirty = 0;\n\n        this.batchDirty = -1;\n\n        this.cacheDirty = -1;\n\n        this.clearDirty = 0;\n\n        this.drawCalls = [];\n\n        this.batches = [];\n\n        this.shapeBuildIndex = 0;\n\n        this.shapeBatchIndex = 0;\n\n        this._bounds = new Bounds();\n\n        this.boundsDirty = -1;\n\n        this.boundsPadding = 0;\n\n        this.batchable = false;\n\n        this.indicesUint16 = null;\n\n        this.packer = null;\n        this.packSize = 0;\n        this.pack32index = null;\n    }\n\n    public checkInstancing(instanced: boolean, allow32Indices: boolean)\n    {\n        if (this.packer)\n        {\n            return;\n        }\n        this.packer = new SegmentPacker();\n        this.pack32index = allow32Indices;\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * @member {PIXI.Bounds}\n     * @readonly\n     */\n    public get bounds(): Bounds\n    {\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * Call if you changed graphicsData manually.\n     * Empties all batch buffers.\n     */\n    protected invalidate(): void\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeBuildIndex = 0;\n        this.shapeBatchIndex = 0;\n        this.packSize = 0;\n\n        this.buildData.clear();\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    public clear(): SmoothGraphicsGeometry\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    public drawShape(\n        shape: IShape,\n        fillStyle: FillStyle = null,\n        lineStyle: LineStyle = null,\n        matrix: Matrix = null): SmoothGraphicsGeometry\n    {\n        const data = new SmoothGraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    public drawHole(shape: IShape, matrix: Matrix = null): SmoothGraphicsGeometry\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new SmoothGraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    public destroy(): void\n    {\n        super.destroy();\n\n        // destroy each of the SmoothGraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.buildData.destroy();\n        this.buildData = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     *\n     * @param {PIXI.IPointData} point - Point to check if it's contained.\n     * @return {Boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    updatePoints(): void\n    {\n        // do nothing\n    }\n\n    updateBufferSize(): void\n    {\n        this._buffer.update(new Float32Array());\n    }\n\n    updateBuild(): void\n    {\n        const { graphicsData, buildData } = this;\n        const len = graphicsData.length;\n\n        for (let i = this.shapeBuildIndex; i < len; i++)\n        {\n            const data = graphicsData[i];\n\n            data.strokeStart = 0;\n            data.strokeLen = 0;\n            data.fillStart = 0;\n            data.fillLen = 0;\n            const { fillStyle, lineStyle, holes } = data;\n\n            if (!fillStyle.visible && !lineStyle.visible)\n            {\n                continue;\n            }\n\n            const command = FILL_COMMANDS[data.type];\n\n            data.clearPath();\n\n            command.path(data, buildData);\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            data.clearBuild();\n            if (data.points.length <= 2)\n            {\n                continue;\n            }\n            if (fillStyle.visible)\n            {\n                if (holes.length)\n                {\n                    this.processHoles(holes);\n                }\n                data.fillAA = (data.fillStyle as any).smooth\n                    && !(data.lineStyle.visible\n                    && data.lineStyle.alpha >= 0.99\n                    && data.lineStyle.width >= 0.99);\n\n                data.fillStart = buildData.joints.length;\n                command.fill(data, buildData);\n                data.fillLen = buildData.joints.length - data.fillStart;\n            }\n            if (lineStyle.visible)\n            {\n                data.strokeStart = buildData.joints.length;\n                command.line(data, buildData);\n                data.strokeLen = buildData.joints.length - data.strokeStart;\n            }\n        }\n        this.shapeBuildIndex = len;\n    }\n\n    updateBatches(shaderSettings?: IGraphicsBatchSettings): void\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n        this.updateBuild();\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        const { buildData, graphicsData } = this;\n        const len = graphicsData.length;\n\n        this.cacheDirty = this.dirty;\n\n        let batchPart: BatchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeBatchIndex; i < len; i++)\n        {\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n            if (!fillStyle.visible && !lineStyle.visible)\n            {\n                continue;\n            }\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const attribOld = buildData.vertexSize;\n                const indexOld = buildData.indexSize;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n                if (j === 0)\n                {\n                    this.packer.updateBufferSize(data.fillStart, data.fillLen, data.triangles.length, buildData);\n                }\n                else\n                {\n                    this.packer.updateBufferSize(data.strokeStart, data.strokeLen, data.triangles.length, buildData);\n                }\n\n                const attribSize = buildData.vertexSize;\n\n                if (attribSize === attribOld) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(indexOld, attribOld);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, indexOld, attribOld);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                if (j === 0)\n                {\n                    batchPart.jointEnd = data.fillStart + data.fillLen;\n                }\n                else\n                {\n                    batchPart.jointEnd = data.strokeStart + data.strokeLen;\n                }\n            }\n        }\n        this.shapeBatchIndex = len;\n\n        if (batchPart)\n        {\n            batchPart.end(buildData.indexSize, buildData.vertexSize);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in SmoothGraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls(shaderSettings);\n            this.updatePack();\n        }\n    }\n\n    updatePack()\n    {\n        const { vertexSize, indexSize } = this.buildData;\n\n        if (this.packSize === vertexSize)\n        {\n            return;\n        }\n\n        const { strideFloats, packer, buildData, batches } = this;\n        const buffer = this._buffer;\n        const index = this._indexBuffer;\n        const floatsSize = vertexSize * strideFloats;\n\n        if (buffer.data.length !== floatsSize)\n        {\n            const arrBuf = new ArrayBuffer(floatsSize * 4);\n\n            this._bufferFloats = new Float32Array(arrBuf);\n            this._bufferUint = new Uint32Array(arrBuf);\n            buffer.data = this._bufferFloats;\n        }\n        if (index.data.length !== indexSize)\n        {\n            if (vertexSize > 0xffff && this.pack32index)\n            {\n                index.data = new Uint32Array(indexSize);\n            }\n            else\n            {\n                index.data = new Uint16Array(indexSize);\n            }\n        }\n\n        packer.beginPack(buildData, this._bufferFloats, this._bufferUint, index.data as Uint16Array);\n\n        let j = 0;\n\n        for (let i = 0; i < this.graphicsData.length; i++)\n        {\n            const data = this.graphicsData[i];\n\n            if (data.fillLen)\n            {\n                while (batches[j].jointEnd <= data.fillStart)\n                {\n                    j++;\n                }\n                packer.packInterleavedGeometry(data.fillStart, data.fillLen, data.triangles,\n                    batches[j].styleId, batches[j].rgba);\n            }\n            if (data.strokeLen)\n            {\n                while (batches[j].jointEnd <= data.strokeStart)\n                {\n                    j++;\n                }\n                packer.packInterleavedGeometry(data.strokeStart, data.strokeLen, data.triangles,\n                    batches[j].styleId, batches[j].rgba);\n            }\n        }\n\n        buffer.update();\n        index.update();\n        this.packSize = vertexSize;\n    }\n\n    /**\n     * Affinity check\n     *\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleA\n     * @param {PIXI.FillStyle | PIXI.LineStyle} styleB\n     */\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (styleA.packLineWidth() !== styleB.packLineWidth())\n        {\n            return false;\n        }\n\n        // TODO: propagate width for FillStyle\n        if ((styleA as LineStyle).alignment !== (styleB as LineStyle).alignment)\n        {\n            return false;\n        }\n\n        const mat1 = styleA.matrix || Matrix.IDENTITY;\n        const mat2 = styleB.matrix || Matrix.IDENTITY;\n\n        return matrixEquals(mat1, mat2);\n    }\n\n    /**\n     * Test geometry for batching process.\n     *\n     * @protected\n     */\n    protected validateBatching(): boolean\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Offset the indices so that it works with the batcher.\n     *\n     * @protected\n     */\n    protected packBatches(): void\n    {\n        this.batchDirty++;\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    protected isBatchable(): boolean\n    {\n        return false;\n\n        // prevent heavy mesh batching\n        // if (this.points.length > 0xffff * 2) {\n        //     return false;\n        // }\n        //\n        // const batches = this.batches;\n        //\n        // for (let i = 0; i < batches.length; i++) {\n        //     if ((batches[i].style as LineStyle).native) {\n        //         return false;\n        //     }\n        // }\n        //\n        // return (this.points.length < SmoothGraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /**\n     * Converts intermediate batches data to drawCalls.\n     *\n     * @protected\n     */\n    protected buildDrawCalls(shaderSettings?: IGraphicsBatchSettings)\n    {\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        let currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall();\n\n        currentGroup.begin(shaderSettings, null);\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchData = this.batches[i];\n            const style = batchData.style as LineStyle;\n\n            if (batchData.attribSize === 0)\n            {\n                // I don't know how why do we have size=0 sometimes\n                continue;\n            }\n\n            let styleId = -1;\n            const mat = style.getTextureMatrix();\n\n            if (currentGroup.check(style.shader))\n            {\n                styleId = currentGroup.add(style.texture, mat, style.packLineWidth(), style.alignment || 0);\n            }\n            if (styleId < 0)\n            {\n                currentGroup = DRAW_CALL_POOL.pop() || new BatchDrawCall();\n                this.drawCalls.push(currentGroup);\n                currentGroup.begin(shaderSettings, style.shader);\n                currentGroup.start = index;\n                styleId = currentGroup.add(style.texture, mat, style.packLineWidth(), style.alignment || 0);\n            }\n            currentGroup.size += batchData.size;\n            index += batchData.size;\n\n            const { color, alpha } = style;\n            const rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n\n            batchData.rgba = premultiplyTint(rgb, alpha);\n            batchData.styleId = styleId;\n        }\n    }\n\n    protected processHoles(holes: Array<SmoothGraphicsData>): void\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            command.path(hole, this.buildData);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /**\n     * Update the local bounds of the object. Expensive to use performance-wise.\n     *\n     * @protected\n     */\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n        const sequenceBounds = tmpBounds;\n        let curMatrix = Matrix.IDENTITY;\n\n        this._bounds.clear();\n        sequenceBounds.clear();\n\n        for (let i = 0; i < this.graphicsData.length; i++)\n        {\n            const data = this.graphicsData[i];\n            const shape = data.shape;\n            const type = data.type;\n            const lineStyle = data.lineStyle;\n            const nextMatrix = data.matrix || Matrix.IDENTITY;\n            let lineWidth = 0.0;\n\n            if (lineStyle && lineStyle.visible)\n            {\n                const alignment = lineStyle.alignment;\n\n                lineWidth = lineStyle.width;\n\n                if (type === SHAPES.POLY)\n                {\n                    lineWidth = lineWidth * (0.5 + Math.abs(0.5 - alignment));\n                }\n                else\n                {\n                    lineWidth = lineWidth * Math.max(0, alignment);\n                }\n            }\n\n            if (curMatrix !== nextMatrix)\n            {\n                if (!sequenceBounds.isEmpty())\n                {\n                    bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n                    sequenceBounds.clear();\n                }\n                curMatrix = nextMatrix;\n            }\n\n            if (type === SHAPES.RECT || type === SHAPES.RREC)\n            {\n                const rect = shape as Rectangle | RoundedRectangle;\n\n                sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height,\n                    lineWidth, lineWidth);\n            }\n            else if (type === SHAPES.CIRC)\n            {\n                const circle = shape as Circle;\n\n                sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y,\n                    circle.radius + lineWidth, circle.radius + lineWidth);\n            }\n            else if (type === SHAPES.ELIP)\n            {\n                const ellipse = shape as Ellipse;\n\n                sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y,\n                    ellipse.width + lineWidth, ellipse.height + lineWidth);\n            }\n            else\n            {\n                const poly = shape as Polygon;\n                // adding directly to the bounds\n\n                bounds.addVerticesMatrix(curMatrix, (poly.points as any), 0, poly.points.length, lineWidth, lineWidth);\n            }\n        }\n\n        if (!sequenceBounds.isEmpty())\n        {\n            bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n        }\n\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     *\n     * @protected\n     * @param {number[]} points - Points to transform\n     * @param {PIXI.Matrix} matrix - Transform matrix\n     */\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n}\n","import { Program, Shader } from '@pixi/core';\nimport { IGraphicsBatchSettings } from './core/BatchDrawCall';\n\nconst smoothVert = `precision highp float;\nconst float FILL = 1.0;\nconst float BEVEL = 4.0;\nconst float MITER = 8.0;\nconst float ROUND = 12.0;\nconst float JOINT_CAP_BUTT = 16.0;\nconst float JOINT_CAP_SQUARE = 18.0;\nconst float JOINT_CAP_ROUND = 20.0;\n\nconst float FILL_EXPAND = 24.0;\n\nconst float CAP_BUTT = 1.0;\nconst float CAP_SQUARE = 2.0;\nconst float CAP_ROUND = 3.0;\nconst float CAP_BUTT2 = 4.0;\n\nconst float MITER_LIMIT = 10.0;\n\n// === geom ===\nattribute vec2 aPrev;\nattribute vec2 aPoint1;\nattribute vec2 aPoint2;\nattribute vec2 aNext;\nattribute float aVertexJoint;\nattribute float aTravel;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec4 vSignedCoord;\nvarying vec4 vDistance;\nvarying float vType;\n\nuniform float resolution;\nuniform float expand;\n\n// === style ===\nattribute float aStyleId;\nattribute vec4 aColor;\n\nvarying float vTextureId;\nvarying vec4 vColor;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\n\nuniform vec2 styleLine[%MAX_STYLES%];\nuniform vec3 styleMatrix[2 * %MAX_STYLES%];\nuniform float styleTextureId[%MAX_STYLES%];\nuniform vec2 samplerSize[%MAX_TEXTURES%];\n\nvec2 doBisect(vec2 norm, float len, vec2 norm2, float len2,\n    float dy, float inner) {\n    vec2 bisect = (norm + norm2) / 2.0;\n    bisect /= dot(norm, bisect);\n    vec2 shift = dy * bisect;\n    if (inner > 0.5) {\n        if (len < len2) {\n            if (abs(dy * (bisect.x * norm.y - bisect.y * norm.x)) > len) {\n                return dy * norm;\n            }\n        } else {\n            if (abs(dy * (bisect.x * norm2.y - bisect.y * norm2.x)) > len2) {\n                return dy * norm;\n            }\n        }\n    }\n    return dy * bisect;\n}\n\nvoid main(void){\n    vec2 pointA = (translationMatrix * vec3(aPoint1, 1.0)).xy;\n    vec2 pointB = (translationMatrix * vec3(aPoint2, 1.0)).xy;\n\n    vec2 xBasis = pointB - pointA;\n    float len = length(xBasis);\n    vec2 forward = xBasis / len;\n    vec2 norm = vec2(forward.y, -forward.x);\n\n    float type = floor(aVertexJoint / 16.0);\n    float vertexNum = aVertexJoint - type * 16.0;\n    float dx = 0.0, dy = 1.0;\n\n\n    vec2 avgDiag = (translationMatrix * vec3(1.0, 1.0, 0.0)).xy;\n    float avgScale = sqrt(dot(avgDiag, avgDiag) * 0.5);\n\n    float capType = floor(type / 32.0);\n    type -= capType * 32.0;\n\n    int styleId = int(aStyleId + 0.5);\n    float lineWidth = styleLine[styleId].x;\n    if (lineWidth < 0.0) {\n        lineWidth = -lineWidth;\n    } else {\n        lineWidth = lineWidth * avgScale;\n    }\n    lineWidth *= 0.5;\n    float lineAlignment = 2.0 * styleLine[styleId].y - 1.0;\n    vTextureId = styleTextureId[styleId];\n    vTextureCoord = vec2(0.0);\n\n    vec2 pos;\n\n    if (capType == CAP_ROUND) {\n        vertexNum += 4.0;\n        type = JOINT_CAP_ROUND;\n        capType = 0.0;\n    }\n\n    if (type == FILL) {\n        pos = pointA;\n        vDistance = vec4(0.0, -0.5, -0.5, 1.0);\n        vType = 0.0;\n\n        vec2 vTexturePixel;\n        vTexturePixel.x = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2]);\n        vTexturePixel.y = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2 + 1]);\n        vTextureCoord = vTexturePixel / samplerSize[int(vTextureId)];\n    } else if (type >= FILL_EXPAND && type < FILL_EXPAND + 7.5) {\n        // expand vertices\n        float flags = type - FILL_EXPAND;\n        float flag3 = floor(flags / 4.0);\n        float flag2 = floor((flags - flag3 * 4.0) / 2.0);\n        float flag1 = flags - flag3 * 4.0 - flag2 * 2.0;\n\n        vec2 prev = (translationMatrix * vec3(aPrev, 1.0)).xy;\n\n        if (vertexNum < 0.5) {\n            pos = prev;\n        } else if (vertexNum < 1.5) {\n            pos = pointA;\n        } else {\n            pos = pointB;\n        }\n        float len2 = length(aNext);\n        vec2 bisect = (translationMatrix * vec3(aNext, 0.0)).xy;\n        if (len2 > 0.01) {\n            bisect = normalize(bisect) * len2;\n        }\n\n        vec2 n1 = normalize(vec2(pointA.y - prev.y, -(pointA.x - prev.x)));\n        vec2 n2 = normalize(vec2(pointB.y - pointA.y, -(pointB.x - pointA.x)));\n        vec2 n3 = normalize(vec2(prev.y - pointB.y, -(prev.x - pointB.x)));\n\n        if (n1.x * n2.y - n1.y * n2.x < 0.0) {\n            n1 = -n1;\n            n2 = -n2;\n            n3 = -n3;\n        }\n\n        vDistance.w = 1.0;\n        pos += bisect * expand;\n\n        vDistance = vec4(16.0, 16.0, 16.0, -1.0);\n        if (flag1 > 0.5) {\n            vDistance.x = -dot(pos - prev, n1);\n        }\n        if (flag2 > 0.5) {\n            vDistance.y = -dot(pos - pointA, n2);\n        }\n        if (flag3 > 0.5) {\n            vDistance.z = -dot(pos - pointB, n3);\n        }\n        vDistance.xyz *= resolution;\n        vType = 2.0;\n    } else if (type >= BEVEL) {\n        float dy = lineWidth + expand;\n        float inner = 0.0;\n        if (vertexNum >= 1.5) {\n            dy = -dy;\n            inner = 1.0;\n        }\n\n        vec2 base, next, xBasis2, bisect;\n        float flag = 0.0;\n        float sign2 = 1.0;\n        if (vertexNum < 0.5 || vertexNum > 2.5 && vertexNum < 3.5) {\n            next = (translationMatrix * vec3(aPrev, 1.0)).xy;\n            base = pointA;\n            flag = type - floor(type / 2.0) * 2.0;\n            sign2 = -1.0;\n        } else {\n            next = (translationMatrix * vec3(aNext, 1.0)).xy;\n            base = pointB;\n            if (type >= MITER && type < MITER + 3.5) {\n                flag = step(MITER + 1.5, type);\n                // check miter limit here?\n            }\n        }\n        xBasis2 = next - base;\n        float len2 = length(xBasis2);\n        vec2 norm2 = vec2(xBasis2.y, -xBasis2.x) / len2;\n        float D = norm.x * norm2.y - norm.y * norm2.x;\n        if (D < 0.0) {\n            inner = 1.0 - inner;\n        }\n\n        norm2 *= sign2;\n\n        if (abs(lineAlignment) > 0.01) {\n            float shift = lineWidth * lineAlignment;\n            pointA += norm * shift;\n            pointB += norm * shift;\n            if (abs(D) < 0.01) {\n                base += norm * shift;\n            } else {\n                base += doBisect(norm, len, norm2, len2, shift, 0.0);\n            }\n        }\n\n        float collinear = step(0.0, dot(norm, norm2));\n\n        vType = 0.0;\n        float dy2 = -1000.0;\n        float dy3 = -1000.0;\n\n        if (abs(D) < 0.01 && collinear < 0.5) {\n            if (type >= ROUND && type < ROUND + 1.5) {\n                type = JOINT_CAP_ROUND;\n            }\n            //TODO: BUTT here too\n        }\n\n        if (vertexNum < 3.5) {\n            if (abs(D) < 0.01) {\n                pos = dy * norm;\n            } else {\n                if (flag < 0.5 && inner < 0.5) {\n                    pos = dy * norm;\n                } else {\n                    pos = doBisect(norm, len, norm2, len2, dy, inner);\n                }\n            }\n            if (capType >= CAP_BUTT && capType < CAP_ROUND) {\n                float extra = step(CAP_SQUARE, capType) * lineWidth;\n                vec2 back = -forward;\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\n                    pos += back * (expand + extra);\n                    dy2 = expand;\n                } else {\n                    dy2 = dot(pos + base - pointA, back) - extra;\n                }\n            }\n            if (type >= JOINT_CAP_BUTT && type < JOINT_CAP_SQUARE + 0.5) {\n                float extra = step(JOINT_CAP_SQUARE, type) * lineWidth;\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\n                    dy3 = dot(pos + base - pointB, forward) - extra;\n                } else {\n                    pos += forward * (expand + extra);\n                    dy3 = expand;\n                    if (capType >= CAP_BUTT) {\n                        dy2 -= expand + extra;\n                    }\n                }\n            }\n        } else if (type >= JOINT_CAP_ROUND && type < JOINT_CAP_ROUND + 1.5) {\n            if (inner > 0.5) {\n                dy = -dy;\n                inner = 0.0;\n            }\n            vec2 d2 = abs(dy) * vec2(-norm.y, norm.x);\n            if (vertexNum < 4.5) {\n                dy = -dy;\n                pos = dy * norm;\n            } else if (vertexNum < 5.5) {\n                pos = dy * norm;\n            } else if (vertexNum < 6.5) {\n                pos = dy * norm + d2;\n            } else {\n                dy = -dy;\n                pos = dy * norm + d2;\n            }\n            dy = -0.5;\n            dy2 = pos.x;\n            dy3 = pos.y;\n            vType = 3.0;\n        } else if (abs(D) < 0.01) {\n            pos = dy * norm;\n        } else {\n            if (type >= ROUND && type < ROUND + 1.5) {\n                if (inner > 0.5) {\n                    dy = -dy;\n                    inner = 0.0;\n                }\n                if (vertexNum < 4.5) {\n                    pos = doBisect(norm, len, norm2, len2, -dy, 1.0);\n                } else if (vertexNum < 5.5) {\n                    pos = dy * norm;\n                } else if (vertexNum > 7.5) {\n                    pos = dy * norm2;\n                } else {\n                    pos = doBisect(norm, len, norm2, len2, dy, 0.0);\n                    float d2 = abs(dy);\n                    if (length(pos) > abs(dy) * 1.5) {\n                        if (vertexNum < 6.5) {\n                            pos.x = dy * norm.x - d2 * norm.y;\n                            pos.y = dy * norm.y + d2 * norm.x;\n                        } else {\n                            pos.x = dy * norm2.x + d2 * norm2.y;\n                            pos.y = dy * norm2.y - d2 * norm2.x;\n                        }\n                    }\n                }\n                vec2 norm3 = normalize(norm - norm2);\n                dy = pos.x * norm3.y - pos.y * norm3.x - 3.0;\n                dy2 = pos.x;\n                dy3 = pos.y;\n                vType = 3.0;\n            } else {\n                if (type >= MITER && type < MITER + 3.5) {\n                    if (inner > 0.5) {\n                        dy = -dy;\n                        inner = 0.0;\n                    }\n                    float sign = step(0.0, dy) * 2.0 - 1.0;\n                    pos = doBisect(norm, len, norm2, len2, dy, 0.0);\n                    if (length(pos) > abs(dy) * MITER_LIMIT) {\n                        type = BEVEL;\n                    } else {\n                        if (vertexNum < 4.5) {\n                            dy = -dy;\n                            pos = doBisect(norm, len, norm2, len2, dy, 1.0);\n                        } else if (vertexNum < 5.5) {\n                            pos = dy * norm;\n                        } else if (vertexNum > 6.5) {\n                            pos = dy * norm2;\n                            // dy = ...\n                        }\n                    }\n                    vType = 1.0;\n                    dy = -sign * dot(pos, norm);\n                    dy2 = -sign * dot(pos, norm2);\n                }\n                if (type >= BEVEL && type < BEVEL + 1.5) {\n                    if (inner < 0.5) {\n                        dy = -dy;\n                        inner = 1.0;\n                    }\n                    vec2 norm3 = normalize((norm + norm2) / 2.0);\n                    if (vertexNum < 4.5) {\n                        pos = doBisect(norm, len, norm2, len2, dy, 1.0);\n                        dy2 = -abs(dot(pos + dy * norm, norm3));\n                    } else {\n                        dy2 = 0.0;\n                        dy = -dy;\n                        if (vertexNum < 5.5) {\n                            pos = dy * norm;\n                        } else {\n                            pos = dy * norm2;\n                        }\n                    }\n                }\n            }\n        }\n\n        pos += base;\n        vDistance = vec4(dy, dy2, dy3, lineWidth) * resolution;\n        vTravel = aTravel * avgScale + dot(pos - pointA, vec2(-norm.y, norm.x));\n    }\n\n    gl_Position = vec4((projectionMatrix * vec3(pos, 1.0)).xy, 0.0, 1.0);\n\n    vColor = aColor * tint;\n}`;\n\nconst smoothFrag = `\nvarying vec4 vColor;\nvarying vec4 vDistance;\nvarying float vType;\nvarying float vTextureId;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\n\nvoid main(void){\n    float alpha = 1.0;\n    float lineWidth = vDistance.w;\n    if (vType < 0.5) {\n        float left = max(vDistance.x - 0.5, -vDistance.w);\n        float right = min(vDistance.x + 0.5, vDistance.w);\n        float near = vDistance.y - 0.5;\n        float far = min(vDistance.y + 0.5, 0.0);\n        float top = vDistance.z - 0.5;\n        float bottom = min(vDistance.z + 0.5, 0.0);\n        alpha = max(right - left, 0.0) * max(bottom - top, 0.0) * max(far - near, 0.0);\n    } else if (vType < 1.5) {\n        float a1 = clamp(vDistance.x + 0.5 - lineWidth, 0.0, 1.0);\n        float a2 = clamp(vDistance.x + 0.5 + lineWidth, 0.0, 1.0);\n        float b1 = clamp(vDistance.y + 0.5 - lineWidth, 0.0, 1.0);\n        float b2 = clamp(vDistance.y + 0.5 + lineWidth, 0.0, 1.0);\n        alpha = a2 * b2 - a1 * b1;\n    } else if (vType < 2.5) {\n        alpha *= max(min(vDistance.x + 0.5, 1.0), 0.0);\n        alpha *= max(min(vDistance.y + 0.5, 1.0), 0.0);\n        alpha *= max(min(vDistance.z + 0.5, 1.0), 0.0);\n    } else {\n        float dist2 = sqrt(dot(vDistance.yz, vDistance.yz));\n        float rad = vDistance.w;\n        float left = max(dist2 - 0.5, -rad);\n        float right = min(dist2 + 0.5, rad);\n        // TODO: something has to be done about artifact at vDistance.x far side\n        alpha = 1.0 - step(vDistance.x, 0.0) * (1.0 - max(right - left, 0.0));\n    }\n\n    vec4 texColor;\n    float textureId = floor(vTextureId+0.5);\n    %FOR_LOOP%\n\n    gl_FragColor = vColor * texColor * alpha;\n}\n`;\n\nexport class SmoothGraphicsProgram extends Program\n{\n    settings: IGraphicsBatchSettings;\n\n    constructor(settings: IGraphicsBatchSettings,\n        vert = smoothVert,\n        frag = smoothFrag,\n        _uniforms = {})\n    {\n        const { maxStyles, maxTextures } = settings;\n\n        vert = vert.replace(/%MAX_TEXTURES%/gi, `${maxTextures}`)\n            .replace(/%MAX_STYLES%/gi, `${maxStyles}`);\n        frag = frag.replace(/%MAX_TEXTURES%/gi, `${maxTextures}`)\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            .replace(/%FOR_LOOP%/gi, SmoothGraphicsShader.generateSampleSrc(maxTextures));\n\n        super(vert, frag);\n        this.settings = settings;\n    }\n}\n\nexport class SmoothGraphicsShader extends Shader\n{\n    settings: IGraphicsBatchSettings;\n\n    constructor(settings: IGraphicsBatchSettings, prog = new SmoothGraphicsProgram(settings), uniforms = {})\n    {\n        const { maxStyles, maxTextures } = settings;\n        const sampleValues = new Int32Array(maxTextures);\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            sampleValues[i] = i;\n        }\n        super(prog, (Object as any).assign(uniforms, {\n            styleMatrix: new Float32Array(6 * maxStyles),\n            styleTextureId: new Float32Array(maxStyles),\n            styleLine: new Float32Array(2 * maxStyles),\n            samplerSize: new Float32Array(2 * maxTextures),\n            uSamplers: sampleValues,\n            tint: new Float32Array([1, 1, 1, 1]),\n            resolution: 1,\n            expand: 1,\n        }));\n        this.settings = settings;\n    }\n\n    static generateSampleSrc(maxTextures: number): string\n    {\n        let src = '';\n\n        src += '\\n';\n        src += '\\n';\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i > 0)\n            {\n                src += '\\nelse ';\n            }\n\n            if (i < maxTextures - 1)\n            {\n                src += `if(textureId < ${i}.5)`;\n            }\n\n            src += '\\n{';\n            src += `\\n\\ttexColor = texture2D(uSamplers[${i}], vTextureCoord);`;\n            src += '\\n}';\n        }\n\n        src += '\\n';\n        src += '\\n';\n\n        return src;\n    }\n}\n","import { LINE_SCALE_MODE } from \"./core/LineStyle\";\n\nexport interface ISettings {\n    LINE_SCALE_MODE: string;\n    SHADER_MAX_STYLES: number;\n    SHADER_MAX_TEXTURES: number;\n}\n\nexport const settings: ISettings = {\n    LINE_SCALE_MODE: LINE_SCALE_MODE.NORMAL,\n    SHADER_MAX_STYLES: 24,\n    SHADER_MAX_TEXTURES: 4,\n};\n","import {\n    Circle,\n    Ellipse,\n    PI_2,\n    Point,\n    Polygon,\n    Rectangle,\n    RoundedRectangle,\n    Matrix,\n    SHAPES,\n} from '@pixi/math';\n\nimport { Texture, State, Renderer, Shader } from '@pixi/core';\nimport { graphicsUtils, LINE_JOIN, LINE_CAP, Graphics } from '@pixi/graphics';\nimport { hex2rgb } from '@pixi/utils';\nimport { SmoothGraphicsGeometry } from './SmoothGraphicsGeometry';\nimport { BLEND_MODES, DRAW_MODES } from '@pixi/constants';\nimport { Container } from '@pixi/display';\n\nimport type { IShape, IPointData } from '@pixi/math';\nimport type { IDestroyOptions } from '@pixi/display';\nimport { IGraphicsBatchSettings } from './core/BatchDrawCall';\nimport { FillStyle } from './core/FillStyle';\nimport {LINE_SCALE_MODE, LineStyle} from './core/LineStyle';\nimport { SmoothGraphicsShader } from './SmoothShader';\nimport { settings } from \"./settings\";\n\nconst { BezierUtils, QuadraticUtils, ArcUtils } = graphicsUtils;\n\nconst temp = new Float32Array(3);\n// a default shaders map used by graphics..\nconst DEFAULT_SHADERS: { [key: string]: Shader } = {};\n\nexport interface IFillStyleOptions {\n    color?: number;\n    alpha?: number;\n    texture?: Texture;\n    matrix?: Matrix;\n    smooth?: boolean;\n    shader?: Shader;\n}\n\nexport interface ILineStyleOptions extends IFillStyleOptions {\n    width?: number;\n    alignment?: number;\n    scaleMode: LINE_SCALE_MODE;\n    cap?: LINE_CAP;\n    join?: LINE_JOIN;\n    miterLimit?: number;\n}\n\nexport class SmoothGraphics extends Container\n{\n    static _TEMP_POINT = new Point();\n\n    public shader: Shader;\n    public shaderSettings: IGraphicsBatchSettings;\n    public pluginName: string;\n    public currentPath: Polygon;\n\n    protected batches: Array<any>;\n    protected batchTint: number;\n    protected batchDirty: number;\n    protected vertexData: Float32Array;\n\n    protected _fillStyle: FillStyle;\n    protected _lineStyle: LineStyle;\n    protected _matrix: Matrix;\n    protected _holeMode: boolean;\n    protected _transformID: number;\n    protected _tint: number;\n\n    private state: State;\n    private _geometry: SmoothGraphicsGeometry;\n\n    public get geometry(): SmoothGraphicsGeometry\n    {\n        return this._geometry;\n    }\n\n    constructor(geometry: SmoothGraphicsGeometry = null)\n    {\n        super();\n\n        this._geometry = geometry || new SmoothGraphicsGeometry();\n        this._geometry.refCount++;\n\n        this.shader = null;\n\n        this.shaderSettings = {\n            maxStyles: settings.SHADER_MAX_STYLES,\n            maxTextures: settings.SHADER_MAX_TEXTURES,\n        };\n\n        this.state = State.for2d();\n\n        this._fillStyle = new FillStyle();\n\n        this._lineStyle = new LineStyle();\n\n        this._matrix = null;\n\n        this._holeMode = false;\n\n        this.currentPath = null;\n\n        this.batches = [];\n\n        this.batchTint = -1;\n\n        this.batchDirty = -1;\n\n        this.vertexData = null;\n\n        this.pluginName = 'smooth';\n\n        this._transformID = -1;\n\n        // Set default\n        this.tint = 0xFFFFFF;\n        this.blendMode = BLEND_MODES.NORMAL;\n    }\n\n    public clone(): SmoothGraphics\n    {\n        this.finishPoly();\n\n        return new SmoothGraphics(this._geometry);\n    }\n\n    public set blendMode(value: BLEND_MODES)\n    {\n        this.state.blendMode = value;\n    }\n\n    public get blendMode(): BLEND_MODES\n    {\n        return this.state.blendMode;\n    }\n\n    public get tint(): number\n    {\n        return this._tint;\n    }\n\n    public set tint(value: number)\n    {\n        this._tint = value;\n    }\n\n    public get fill(): FillStyle\n    {\n        return this._fillStyle;\n    }\n\n    public get line(): LineStyle\n    {\n        return this._lineStyle;\n    }\n\n    public lineStyle(width: number, color?: number, alpha?: number, alignment?: number, scaleMode?: LINE_SCALE_MODE): this;\n\n    public lineStyle(options?: ILineStyleOptions): this;\n\n    public lineStyle(options: ILineStyleOptions | number = null,\n        color = 0x0, alpha = 1, alignment = 0.5, scaleMode = settings.LINE_SCALE_MODE): this\n    {\n        // Support non-object params: (width, color, alpha, alignment, native)\n        if (typeof options === 'number')\n        {\n            if (typeof scaleMode === 'boolean')\n            {\n                scaleMode = scaleMode ? LINE_SCALE_MODE.NONE : LINE_SCALE_MODE.NORMAL;\n            }\n            options = { width: options, color, alpha, alignment, scaleMode } as ILineStyleOptions;\n        }\n        else\n        {\n            const native: boolean = (options as any).native;\n\n            if (native !== undefined)\n            {\n                options.scaleMode = native ? LINE_SCALE_MODE.NONE : LINE_SCALE_MODE.NORMAL;\n            }\n        }\n\n        return this.lineTextureStyle(options);\n    }\n\n    public lineTextureStyle(options: ILineStyleOptions): this\n    {\n        // Apply defaults\n        options = Object.assign({\n            width: 0,\n            texture: Texture.WHITE,\n            color: (options && options.texture) ? 0xFFFFFF : 0x0,\n            alpha: 1,\n            matrix: null,\n            alignment: 0.5,\n            native: false,\n            cap: LINE_CAP.BUTT,\n            join: LINE_JOIN.MITER,\n            miterLimit: 10,\n            shader: null,\n            scaleMode: settings.LINE_SCALE_MODE,\n        }, options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.width > 0 && options.alpha > 0;\n\n        if (!visible)\n        {\n            this._lineStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._lineStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    protected startPoly(): void\n    {\n        if (this.currentPath)\n        {\n            const points = this.currentPath.points;\n            const len = this.currentPath.points.length;\n\n            if (len > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = new Polygon();\n                this.currentPath.closeStroke = false;\n                this.currentPath.points.push(points[len - 2], points[len - 1]);\n            }\n        }\n        else\n        {\n            this.currentPath = new Polygon();\n            this.currentPath.closeStroke = false;\n        }\n    }\n\n    finishPoly(): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = null;\n            }\n            else\n            {\n                this.currentPath.points.length = 0;\n            }\n        }\n    }\n\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly();\n        this.currentPath.points[0] = x;\n        this.currentPath.points[1] = y;\n\n        return this;\n    }\n\n    public lineTo(x: number, y: number): this\n    {\n        if (!this.currentPath)\n        {\n            this.moveTo(0, 0);\n        }\n\n        // remove duplicates..\n        const points = this.currentPath.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    protected _initCurve(x = 0, y = 0): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length === 0)\n            {\n                this.currentPath.points = [x, y];\n            }\n        }\n        else\n        {\n            this.moveTo(x, y);\n        }\n    }\n\n    public quadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        const points = this.currentPath.points;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n\n        return this;\n    }\n\n    public bezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n\n        return this;\n    }\n\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._initCurve(x1, y1);\n\n        const points = this.currentPath.points;\n\n        const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n\n        if (result)\n        {\n            const { cx, cy, radius, startAngle, endAngle, anticlockwise } = result;\n\n            this.arc(cx, cy, radius, startAngle, endAngle, anticlockwise);\n        }\n\n        return this;\n    }\n\n    public arc(cx: number, cy: number, radius: number, startAngle: number, endAngle: number, anticlockwise = false): this\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += PI_2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += PI_2;\n        }\n\n        const sweep = endAngle - startAngle;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n        const eps = this._geometry.closePointEps;\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.points : null;\n\n        if (points)\n        {\n            // TODO: make a better fix.\n\n            // We check how far our start is from the last existing point\n            const xDiff = Math.abs(points[points.length - 2] - startX);\n            const yDiff = Math.abs(points[points.length - 1] - startY);\n\n            if (xDiff < eps && yDiff < eps)\n            {\n                // If the point is very close, we don't add it, since this would lead to artifacts\n                // during tessellation due to floating point imprecision.\n            }\n            else\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.points;\n        }\n\n        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n\n        return this;\n    }\n\n    public beginFill(color = 0, alpha = 1, smooth = false): this\n    {\n        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha, smooth });\n    }\n\n    beginTextureFill(options?: IFillStyleOptions): this\n    {\n        // Apply defaults\n        options = Object.assign({\n            texture: Texture.WHITE,\n            color: 0xFFFFFF,\n            alpha: 1,\n            matrix: null,\n            smooth: false,\n        }, options) as IFillStyleOptions;\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.alpha > 0;\n\n        if (!visible)\n        {\n            this._fillStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._fillStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    public endFill(): this\n    {\n        this.finishPoly();\n\n        this._fillStyle.reset();\n\n        return this;\n    }\n\n    public drawRect(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Rectangle(x, y, width, height));\n    }\n\n    public drawRoundedRect(x: number, y: number, width: number, height: number, radius: number): this\n    {\n        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n    }\n\n    public drawCircle(x: number, y: number, radius: number): this\n    {\n        return this.drawShape(new Circle(x, y, radius));\n    }\n\n    public drawEllipse(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Ellipse(x, y, width, height));\n    }\n\n    public drawPolygon(...path: Array<number> | Array<Point>): this\n    public drawPolygon(path: Array<number> | Array<Point> | Polygon): this\n\n    public drawPolygon(...path: any[]): this\n    {\n        let points: Array<number> | Array<Point>;\n        let closeStroke = true;// !!this._fillStyle;\n\n        const poly = path[0] as Polygon;\n\n        // check if data has points..\n        if (poly.points)\n        {\n            closeStroke = poly.closeStroke;\n            points = poly.points;\n        }\n        else if (Array.isArray(path[0]))\n        {\n            points = path[0];\n        }\n        else\n        {\n            points = path;\n        }\n\n        const shape = new Polygon(points);\n\n        shape.closeStroke = closeStroke;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    public drawShape(shape: IShape): this\n    {\n        if (!this._holeMode)\n        {\n            this._geometry.drawShape(\n                shape,\n                this._fillStyle.clone(),\n                this._lineStyle.clone(),\n                this._matrix\n            );\n        }\n        else\n        {\n            this._geometry.drawHole(shape, this._matrix);\n        }\n\n        return this;\n    }\n\n    public clear(): this\n    {\n        this._geometry.clear();\n        this._lineStyle.reset();\n        this._fillStyle.reset();\n\n        this._boundsID++;\n        this._matrix = null;\n        this._holeMode = false;\n        this.currentPath = null;\n\n        return this;\n    }\n\n    public isFastRect(): boolean\n    {\n        const data = this._geometry.graphicsData;\n\n        return data.length === 1\n            && data[0].shape.type === SHAPES.RECT\n            && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n    }\n\n    protected _renderCanvas(renderer: any): void\n    {\n        (Graphics.prototype as any)._renderCanvas.call(this, renderer);\n    }\n\n    protected _render(renderer: Renderer): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n        const hasuint32 = renderer.context.supports.uint32Indices;\n        // batch part..\n        // batch it!\n\n        geometry.checkInstancing(renderer.geometry.hasInstance, hasuint32);\n\n        geometry.updateBatches(this.shaderSettings);\n\n        if (geometry.batchable)\n        {\n            if (this.batchDirty !== geometry.batchDirty)\n            {\n                this._populateBatches();\n            }\n\n            this._renderBatched(renderer);\n        }\n        else\n        {\n            // no batching...\n            renderer.batch.flush();\n\n            this._renderDirect(renderer);\n        }\n    }\n\n    protected _populateBatches(): void\n    {\n        const geometry = this._geometry;\n        const blendMode = this.blendMode;\n        const len = geometry.batches.length;\n\n        this.batchTint = -1;\n        this._transformID = -1;\n        this.batchDirty = geometry.batchDirty;\n        this.batches.length = len;\n\n        this.vertexData = new Float32Array(geometry.points);\n\n        for (let i = 0; i < len; i++)\n        {\n            const gI = geometry.batches[i];\n            const color = gI.style.color;\n            const vertexData = new Float32Array(this.vertexData.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            // const uvs = new Float32Array(geometry.uvsFloat32.buffer,\n            //     gI.attribStart * 4 * 2,\n            //     gI.attribSize * 2);\n\n            // const indices = new Uint16Array(geometry.indicesUint16.buffer,\n            //     gI.start * 2,\n            //     gI.size);\n\n            const batch = {\n                vertexData,\n                blendMode,\n                // indices,\n                // uvs,\n                _batchRGB: hex2rgb(color) as Array<number>,\n                _tintRGB: color,\n                _texture: gI.style.texture,\n                alpha: gI.style.alpha,\n                worldAlpha: 1\n            };\n\n            this.batches[i] = batch;\n        }\n    }\n\n    protected _renderBatched(renderer: Renderer): void\n    {\n        if (!this.batches.length)\n        {\n            return;\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n\n        this.calculateVertices();\n        this.calculateTints();\n\n        for (let i = 0, l = this.batches.length; i < l; i++)\n        {\n            const batch = this.batches[i];\n\n            batch.worldAlpha = this.worldAlpha * batch.alpha;\n\n            renderer.plugins[this.pluginName].render(batch);\n        }\n    }\n\n    protected _renderDirect(renderer: Renderer): void\n    {\n        const directShader = this._resolveDirectShader(renderer);\n        let shader: Shader = directShader;\n\n        const geometry = this._geometry;\n        const tint = this.tint;\n        const worldAlpha = this.worldAlpha;\n        const uniforms = shader.uniforms;\n        const drawCalls = geometry.drawCalls;\n\n        // lets set the transfomr\n        uniforms.translationMatrix = this.transform.worldTransform;\n\n        // and then lets set the tint..\n        uniforms.tint[0] = (((tint >> 16) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[1] = (((tint >> 8) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[2] = ((tint & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[3] = worldAlpha;\n\n        uniforms.resolution = renderer.renderTexture.current\n            ? renderer.renderTexture.current.resolution : renderer.resolution;\n\n        const projTrans = renderer.projection.transform;\n\n        if (projTrans)\n        {\n            // only uniform scale is supported!\n            const scale = Math.sqrt(projTrans.a * projTrans.a + projTrans.b * projTrans.b);\n\n            uniforms.resolution *= scale;\n        }\n\n        uniforms.expand = (renderer.options.antialias ? 2 : 1) / uniforms.resolution;\n\n        // the first draw call, we can set the uniforms of the shader directly here.\n\n        // this means that we can tack advantage of the sync function of pixi!\n        // bind and sync uniforms..\n        // there is a way to optimise this..\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(geometry, shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        shader = null;\n        // then render the rest of them...\n        for (let i = 0, l = drawCalls.length; i < l; i++)\n        {\n            // TODO: refactor it to another class, that fills uniforms of this shader\n            const drawCall = geometry.drawCalls[i];\n\n            const shaderChange = shader !== drawCall.shader;\n\n            if (shaderChange)\n            {\n                shader = drawCall.shader;\n                if (shader)\n                {\n                    shader.uniforms.translationMatrix = this.transform.worldTransform;\n                    if (shader.uniforms.tint)\n                    {\n                        shader.uniforms.tint[0] = uniforms.tint[0];\n                        shader.uniforms.tint[1] = uniforms.tint[1];\n                        shader.uniforms.tint[2] = uniforms.tint[2];\n                        shader.uniforms.tint[3] = uniforms.tint[3];\n                    }\n                }\n            }\n\n            const { texArray, styleArray, size, start } = drawCall;\n            const groupTextureCount = texArray.count;\n            const shaderHere = shader || directShader;\n\n            const texs = shaderHere.uniforms.styleTextureId;\n            const mats = shaderHere.uniforms.styleMatrix;\n            const lines = shaderHere.uniforms.styleLine;\n\n            for (let i = 0; i < styleArray.count; i++)\n            {\n                texs[i] = styleArray.textureIds[i];\n                lines[i * 2] = styleArray.lines[i * 2];\n                lines[(i * 2) + 1] = styleArray.lines[(i * 2) + 1];\n                const m = styleArray.matrices[i];\n\n                mats[i * 6] = m.a;\n                mats[(i * 6) + 1] = m.c;\n                mats[(i * 6) + 2] = m.tx;\n                mats[(i * 6) + 3] = m.b;\n                mats[(i * 6) + 4] = m.d;\n                mats[(i * 6) + 5] = m.ty;\n            }\n            const sizes = shaderHere.uniforms.samplerSize;\n\n            for (let i = 0; i < groupTextureCount; i++)\n            {\n                sizes[i * 2] = texArray.elements[i].width;\n                sizes[(i * 2) + 1] = texArray.elements[i].height;\n            }\n\n            renderer.shader.bind(shaderHere);\n            if (shaderChange)\n            {\n                renderer.geometry.bind(geometry);\n            }\n\n            // TODO: bind styles!\n            for (let j = 0; j < groupTextureCount; j++)\n            {\n                renderer.texture.bind(texArray.elements[j], j);\n            }\n\n            // bind the geometry...\n            renderer.geometry.draw(DRAW_MODES.TRIANGLES, size, start);\n        }\n    }\n\n    protected _resolveDirectShader(_renderer: Renderer): Shader\n    {\n        let shader = this.shader;\n\n        const pluginName = this.pluginName;\n\n        if (!shader)\n        {\n            if (!DEFAULT_SHADERS[pluginName])\n            {\n                DEFAULT_SHADERS[pluginName] = new SmoothGraphicsShader(this.shaderSettings);\n            }\n            shader = DEFAULT_SHADERS[pluginName];\n        }\n\n        return shader;\n    }\n\n    protected _calculateBounds(): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n\n        // skipping when graphics is empty, like a container\n        if (!geometry.graphicsData.length)\n        {\n            return;\n        }\n\n        const { minX, minY, maxX, maxY } = geometry.bounds;\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    public containsPoint(point: IPointData): boolean\n    {\n        this.worldTransform.applyInverse(point, SmoothGraphics._TEMP_POINT);\n\n        return this._geometry.containsPoint(SmoothGraphics._TEMP_POINT);\n    }\n\n    protected calculateTints(): void\n    {\n        if (this.batchTint !== this.tint)\n        {\n            this.batchTint = this.tint;\n\n            const tintRGB = hex2rgb(this.tint, temp);\n\n            for (let i = 0; i < this.batches.length; i++)\n            {\n                const batch = this.batches[i];\n\n                const batchTint = batch._batchRGB;\n\n                const r = (tintRGB[0] * batchTint[0]) * 255;\n                const g = (tintRGB[1] * batchTint[1]) * 255;\n                const b = (tintRGB[2] * batchTint[2]) * 255;\n\n                // TODO Ivan, can this be done in one go?\n                const color = (r << 16) + (g << 8) + (b | 0);\n\n                batch._tintRGB = (color >> 16)\n                    + (color & 0xff00)\n                    + ((color & 0xff) << 16);\n            }\n        }\n    }\n\n    protected calculateVertices(): void\n    {\n        const wtID = this.transform._worldID;\n\n        if (this._transformID === wtID)\n        {\n            return;\n        }\n\n        this._transformID = wtID;\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const data = this._geometry.points;// batch.vertexDataOriginal;\n        const vertexData = this.vertexData;\n\n        let count = 0;\n\n        for (let i = 0; i < data.length; i += 2)\n        {\n            const x = data[i];\n            const y = data[i + 1];\n\n            vertexData[count++] = (a * x) + (c * y) + tx;\n            vertexData[count++] = (d * y) + (b * x) + ty;\n        }\n    }\n\n    public closePath(): this\n    {\n        const currentPath = this.currentPath;\n\n        if (currentPath)\n        {\n            // we don't need to add extra point in the end because buildLine will take care of that\n            currentPath.closeStroke = true;\n        }\n\n        return this;\n    }\n\n    public setMatrix(matrix: Matrix): this\n    {\n        this._matrix = matrix;\n\n        return this;\n    }\n\n    public beginHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = true;\n\n        return this;\n    }\n\n    public endHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = false;\n\n        return this;\n    }\n\n    public destroy(options?: IDestroyOptions | boolean): void\n    {\n        this._geometry.refCount--;\n        if (this._geometry.refCount === 0)\n        {\n            this._geometry.dispose();\n        }\n\n        this._matrix = null;\n        this.currentPath = null;\n        this._lineStyle.destroy();\n        this._lineStyle = null;\n        this._fillStyle.destroy();\n        this._fillStyle = null;\n        this._geometry = null;\n        this.shader = null;\n        this.vertexData = null;\n        this.batches.length = 0;\n        this.batches = null;\n\n        super.destroy(options);\n    }\n\n    drawStar(x: number, y: number,\n        points: number, radius: number, innerRadius: number, rotation = 0): SmoothGraphics\n    {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation) as Polygon);\n    }\n}\n\nexport class Star extends Polygon\n{\n    constructor(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation = 0)\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = PI_2 / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        super(polygon);\n    }\n}\n","import { SmoothGraphicsProgram, SmoothGraphicsShader } from './SmoothShader';\n\nconst dashFrag = `\nvarying vec4 vColor;\nvarying vec4 vDistance;\nvarying float vType;\nvarying float vTextureId;\nvarying vec2 vTextureCoord;\nvarying float vTravel;\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\nuniform float dash;\nuniform float gap;\n\nvoid main(void){\n    float alpha = 1.0;\n    float lineWidth = vDistance.w;\n    if (vType < 0.5) {\n        float left = max(vDistance.x - 0.5, -vDistance.w);\n        float right = min(vDistance.x + 0.5, vDistance.w);\n        float near = vDistance.y - 0.5;\n        float far = min(vDistance.y + 0.5, 0.0);\n        float top = vDistance.z - 0.5;\n        float bottom = min(vDistance.z + 0.5, 0.0);\n        alpha = max(right - left, 0.0) * max(bottom - top, 0.0) * max(far - near, 0.0);\n    } else if (vType < 1.5) {\n        float a1 = clamp(vDistance.x + 0.5 - lineWidth, 0.0, 1.0);\n        float a2 = clamp(vDistance.x + 0.5 + lineWidth, 0.0, 1.0);\n        float b1 = clamp(vDistance.y + 0.5 - lineWidth, 0.0, 1.0);\n        float b2 = clamp(vDistance.y + 0.5 + lineWidth, 0.0, 1.0);\n        alpha = a2 * b2 - a1 * b1;\n    } else if (vType < 2.5) {\n        alpha *= max(min(vDistance.x + 0.5, 1.0), 0.0);\n        alpha *= max(min(vDistance.y + 0.5, 1.0), 0.0);\n        alpha *= max(min(vDistance.z + 0.5, 1.0), 0.0);\n    } else {\n        float dist2 = sqrt(dot(vDistance.yz, vDistance.yz));\n        float rad = vDistance.w;\n        float left = max(dist2 - 0.5, -rad);\n        float right = min(dist2 + 0.5, rad);\n        // TODO: something has to be done about artifact at vDistance.x far side\n        alpha = 1.0 - step(vDistance.x, 0.0) * (1.0 - max(right - left, 0.0));\n    }\n\n    if (dash + gap > 1.0)\n    {\n        float travel = mod(vTravel + gap * 0.5, dash + gap) - (gap * 0.5);\n        float left = max(travel - 0.5, -0.5);\n        float right = min(travel + 0.5, gap + 0.5);\n        alpha *= max(0.0, right - left);\n    }\n\n    vec4 texColor;\n    float textureId = floor(vTextureId+0.5);\n    %FOR_LOOP%\n\n    gl_FragColor = vColor * texColor * alpha;\n}\n`;\n\nexport interface IDashParams {\n    dash: number;\n    gap: number;\n}\n\nexport class DashLineShader extends SmoothGraphicsShader\n{\n    constructor(dashParams?: IDashParams)\n    {\n        const settings = { maxStyles: 16, maxTextures: 1 };\n\n        super(settings, new SmoothGraphicsProgram(settings, undefined, dashFrag),\n            dashParams || {\n                dash: 5.0,\n                gap: 8.0\n            });\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9QA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AAQA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5HA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrcA;AACA;AACA;AACA;AACA;AACA;;ACSA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC52BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpeA;AACA;AACA;AACA;;ACeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACh9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;"}