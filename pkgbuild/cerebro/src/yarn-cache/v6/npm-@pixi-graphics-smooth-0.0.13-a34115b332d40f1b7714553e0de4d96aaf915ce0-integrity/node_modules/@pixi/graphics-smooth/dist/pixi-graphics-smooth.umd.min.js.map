{"version":3,"file":"pixi-graphics-smooth.umd.min.js","sources":["../src/core/SegmentPacker.ts","../src/shapes/RoundedRectangleBuilder.ts","../src/shapes/PolyBuilder.ts"],"sourcesContent":["import { BuildData } from './BuildData';\nimport { JOINT_TYPE } from './const';\n\nexport class SegmentPacker\n{\n    static vertsByJoint: Array<number> = [];\n\n    strideFloats = 12;\n\n    updateBufferSize(jointStart: number, jointLen: number, triangles: number, target: BuildData)\n    {\n        const { joints } = target;\n        let foundTriangle = false;\n\n        let vertexSize = 0;\n        let indexSize = 0;\n\n        for (let i = jointStart; i < jointStart + jointLen; i++)\n        {\n            const prevCap = joints[i] & ~31;\n            const joint = joints[i] & 31;\n\n            if (joint === JOINT_TYPE.FILL)\n            {\n                foundTriangle = true;\n                vertexSize++;\n                continue;\n            }\n\n            if (joint >= JOINT_TYPE.FILL_EXPAND)\n            {\n                vertexSize += 3;\n                indexSize += 3;\n                continue;\n            }\n\n            const vs = SegmentPacker.vertsByJoint[joint] + SegmentPacker.vertsByJoint[prevCap];\n\n            if (vs >= 4)\n            {\n                vertexSize += vs;\n                indexSize += 6 + (3 * Math.max(vs - 6, 0));\n            }\n        }\n        if (foundTriangle)\n        {\n            indexSize += triangles;\n        }\n\n        target.vertexSize += vertexSize;\n        target.indexSize += indexSize;\n    }\n\n    bufferPos = 0;\n    indexPos = 0;\n    bufFloat: Float32Array;\n    bufUint: Uint32Array;\n    indices: Uint16Array;\n    buildData: BuildData;\n\n    beginPack(buildData: BuildData, bufFloat: Float32Array, bufUint: Uint32Array, indices: Uint16Array, bufferPos = 0, indexPos = 0)\n    {\n        this.buildData = buildData;\n        this.bufFloat = bufFloat;\n        this.bufUint = bufUint;\n        this.indices = indices;\n        this.bufferPos = bufferPos;\n        this.indexPos = indexPos;\n    }\n\n    endPack()\n    {\n        this.buildData = null;\n        this.bufFloat = null;\n        this.bufUint = null;\n        this.indices = null;\n    }\n\n    packInterleavedGeometry(jointStart: number, jointLen: number, triangles: number[],\n        lineStyle: number, color: number)\n    {\n        const { bufFloat, bufUint, indices, buildData, strideFloats } = this;\n        const { joints, verts } = buildData;\n\n        let bufPos = this.bufferPos;\n        let indPos = this.indexPos;\n        let index = this.bufferPos / this.strideFloats;\n\n        // eslint-disable-next-line max-len\n        let x1: number; let y1: number; let x2: number; let y2: number; let prevX: number; let prevY: number; let nextX: number; let\n            nextY: number;\n        // let type: number;\n        let hasTriangle = false;\n\n        let travel = 0;\n\n        for (let j = jointStart; j < jointStart + jointLen; j++)\n        {\n            const fullJoint = joints[j];\n            const prevCap = joints[j] & ~31;\n            const joint = joints[j] & 31;\n\n            if (joint === JOINT_TYPE.FILL)\n            {\n                // just one vertex\n                hasTriangle = true;\n                x1 = verts[(j * 2)];\n                y1 = verts[(j * 2) + 1];\n                bufFloat[bufPos] = x1;\n                bufFloat[bufPos + 1] = y1;\n                bufFloat[bufPos + 2] = x1;\n                bufFloat[bufPos + 3] = y1;\n                bufFloat[bufPos + 4] = x1;\n                bufFloat[bufPos + 5] = y1;\n                bufFloat[bufPos + 6] = x1;\n                bufFloat[bufPos + 7] = y1;\n                bufFloat[bufPos + 8] = travel;\n                bufFloat[bufPos + 9] = 16 * joint;\n                bufFloat[bufPos + 10] = lineStyle;\n                bufUint[bufPos + 11] = color;\n                bufPos += strideFloats;\n                continue;\n            }\n\n            if (joint >= JOINT_TYPE.FILL_EXPAND)\n            {\n                prevX = verts[j * 2];\n                prevY = verts[(j * 2) + 1];\n                x1 = verts[(j * 2) + 2];\n                y1 = verts[(j * 2) + 3];\n                x2 = verts[(j * 2) + 4];\n                y2 = verts[(j * 2) + 5];\n\n                const bis = j + 3;\n\n                for (let i = 0; i < 3; i++)\n                {\n                    bufFloat[bufPos] = prevX;\n                    bufFloat[bufPos + 1] = prevY;\n                    bufFloat[bufPos + 2] = x1;\n                    bufFloat[bufPos + 3] = y1;\n                    bufFloat[bufPos + 4] = x2;\n                    bufFloat[bufPos + 5] = y2;\n                    bufFloat[bufPos + 6] = verts[(bis + i) * 2];\n                    bufFloat[bufPos + 7] = verts[((bis + i) * 2) + 1];\n\n                    bufFloat[bufPos + 8] = travel;\n                    bufFloat[bufPos + 9] = (16 * fullJoint) + i;\n                    bufFloat[bufPos + 10] = lineStyle;\n                    bufUint[bufPos + 11] = color;\n                    bufPos += strideFloats;\n                }\n\n                indices[indPos] = index;\n                indices[indPos + 1] = index + 1;\n                indices[indPos + 2] = index + 2;\n                indPos += 3;\n                index += 3;\n                continue;\n            }\n\n            const vs = SegmentPacker.vertsByJoint[joint] + SegmentPacker.vertsByJoint[prevCap];\n\n            if (vs === 0)\n            {\n                continue;\n            }\n            x1 = verts[j * 2];\n            y1 = verts[(j * 2) + 1];\n            x2 = verts[(j * 2) + 2];\n            y2 = verts[(j * 2) + 3];\n            // TODO: caps here\n            prevX = verts[(j * 2) - 2];\n            prevY = verts[(j * 2) - 1];\n\n            const dist = Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));\n\n            if (SegmentPacker.vertsByJoint[joint] === 0)\n            {\n                travel -= dist;\n            }\n\n            if ((joint & ~2) !== JOINT_TYPE.JOINT_CAP_BUTT)\n            {\n                nextX = verts[(j * 2) + 4];\n                nextY = verts[(j * 2) + 5];\n            }\n            else\n            {\n                nextX = x1;\n                nextY = y1;\n            }\n            // type = joint;\n\n            for (let i = 0; i < vs; i++)\n            {\n                bufFloat[bufPos] = prevX;\n                bufFloat[bufPos + 1] = prevY;\n                bufFloat[bufPos + 2] = x1;\n                bufFloat[bufPos + 3] = y1;\n                bufFloat[bufPos + 4] = x2;\n                bufFloat[bufPos + 5] = y2;\n                bufFloat[bufPos + 6] = nextX;\n                bufFloat[bufPos + 7] = nextY;\n                bufFloat[bufPos + 8] = travel;\n                bufFloat[bufPos + 9] = (16 * fullJoint) + i;\n                bufFloat[bufPos + 10] = lineStyle;\n                bufUint[bufPos + 11] = color;\n                bufPos += strideFloats;\n            }\n\n            travel += dist;\n\n            indices[indPos] = index;\n            indices[indPos + 1] = index + 1;\n            indices[indPos + 2] = index + 2;\n            indices[indPos + 3] = index;\n            indices[indPos + 4] = index + 2;\n            indices[indPos + 5] = index + 3;\n            indPos += 6;\n            for (let j = 5; j + 1 < vs; j++)\n            {\n                indices[indPos] = index + 4;\n                indices[indPos + 1] = index + j;\n                indices[indPos + 2] = index + j + 1;\n                indPos += 3;\n            }\n            index += vs;\n        }\n\n        if (hasTriangle)\n        {\n            for (let i = 0; i < triangles.length; i++)\n            {\n                indices[indPos + i] = triangles[i] + index;\n            }\n            indPos += triangles.length;\n        }\n\n        this.bufferPos = bufPos;\n        this.indexPos = indPos;\n    }\n}\n\nconst verts = SegmentPacker.vertsByJoint;\n\nfor (let i = 0; i < 256; i++)\n{ verts.push(0); }\n// simple fill\nverts[JOINT_TYPE.FILL] = 1;\n\nfor (let i = 0; i < 8; i++)\n{\n    verts[JOINT_TYPE.FILL_EXPAND + i] = 3;\n}\n\n// no caps for now\nverts[JOINT_TYPE.JOINT_BEVEL] = 4 + 3;\nverts[JOINT_TYPE.JOINT_BEVEL + 1] = 4 + 3;\nverts[JOINT_TYPE.JOINT_BEVEL + 2] = 4 + 3;\nverts[JOINT_TYPE.JOINT_BEVEL + 3] = 4 + 3;\nverts[JOINT_TYPE.JOINT_ROUND] = 4 + 5;\nverts[JOINT_TYPE.JOINT_ROUND + 1] = 4 + 5;\nverts[JOINT_TYPE.JOINT_ROUND + 2] = 4 + 5;\nverts[JOINT_TYPE.JOINT_ROUND + 3] = 4 + 5;\nverts[JOINT_TYPE.JOINT_MITER] = 4 + 4;\nverts[JOINT_TYPE.JOINT_MITER + 1] = 4 + 4;\nverts[JOINT_TYPE.JOINT_MITER + 2] = 4;\nverts[JOINT_TYPE.JOINT_MITER + 3] = 4;\nverts[JOINT_TYPE.JOINT_CAP_BUTT] = 4;\nverts[JOINT_TYPE.JOINT_CAP_BUTT + 1] = 4;\nverts[JOINT_TYPE.JOINT_CAP_SQUARE] = 4;\nverts[JOINT_TYPE.JOINT_CAP_SQUARE + 1] = 4;\nverts[JOINT_TYPE.JOINT_CAP_ROUND] = 4 + 4;\nverts[JOINT_TYPE.JOINT_CAP_ROUND + 1] = 4 + 4;\n\nverts[JOINT_TYPE.CAP_ROUND] = 4;\n","import type { IShapeBuilder } from '../core/IShapeBuilder';\r\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\r\nimport { BuildData } from '../core/BuildData';\r\nimport { RoundedRectangle } from '@pixi/math';\r\nimport { earcut } from '@pixi/utils';\r\nimport { JOINT_TYPE } from '../core/const';\r\n\r\nfunction getPt(n1: number, n2: number, perc: number): number\r\n{\r\n    const diff = n2 - n1;\r\n\r\n    return n1 + (diff * perc);\r\n}\r\n\r\nfunction quadraticBezierCurve(\r\n    fromX: number, fromY: number,\r\n    cpX: number, cpY: number,\r\n    toX: number, toY: number,\r\n    out: Array<number> = []): Array<number>\r\n{\r\n    const n = 20;\r\n    const points = out;\r\n\r\n    let xa = 0;\r\n    let ya = 0;\r\n    let xb = 0;\r\n    let yb = 0;\r\n    let x = 0;\r\n    let y = 0;\r\n\r\n    for (let i = 0, j = 0; i <= n; ++i)\r\n    {\r\n        j = i / n;\r\n\r\n        // The Green Line\r\n        xa = getPt(fromX, cpX, j);\r\n        ya = getPt(fromY, cpY, j);\r\n        xb = getPt(cpX, toX, j);\r\n        yb = getPt(cpY, toY, j);\r\n\r\n        // The Black Dot\r\n        x = getPt(xa, xb, j);\r\n        y = getPt(ya, yb, j);\r\n\r\n        points.push(x, y);\r\n    }\r\n\r\n    return points;\r\n}\r\n\r\nexport class RoundedRectangleBuilder implements IShapeBuilder\r\n{\r\n    path(graphicsData: SmoothGraphicsData, _target: BuildData)\r\n    {\r\n        const rrectData = graphicsData.shape as RoundedRectangle;\r\n        const { points } = graphicsData;\r\n        const x = rrectData.x;\r\n        const y = rrectData.y;\r\n        const width = rrectData.width;\r\n        const height = rrectData.height;\r\n\r\n        // Don't allow negative radius or greater than half the smallest width\r\n        const radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));\r\n\r\n        points.length = 0;\r\n\r\n        // No radius, do a simple rectangle\r\n        if (!radius)\r\n        {\r\n            points.push(x, y,\r\n                x + width, y,\r\n                x + width, y + height,\r\n                x, y + height);\r\n        }\r\n        else\r\n        {\r\n            quadraticBezierCurve(x, y + radius,\r\n                x, y,\r\n                x + radius, y,\r\n                points);\r\n            quadraticBezierCurve(x + width - radius,\r\n                y, x + width, y,\r\n                x + width, y + radius,\r\n                points);\r\n            quadraticBezierCurve(x + width, y + height - radius,\r\n                x + width, y + height,\r\n                x + width - radius, y + height,\r\n                points);\r\n            quadraticBezierCurve(x + radius, y + height,\r\n                x, y + height,\r\n                x, y + height - radius,\r\n                points);\r\n        }\r\n    }\r\n\r\n    line(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points } = graphicsData;\r\n\r\n\r\n        const joint = points.length === 8 // we dont need joints for arcs\r\n            ? graphicsData.goodJointType() : JOINT_TYPE.JOINT_MITER + 3;\r\n        const len = points.length;\r\n\r\n        verts.push(points[len - 2], points[len - 1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        for (let i = 0; i < len; i += 2)\r\n        {\r\n            verts.push(points[i], points[i + 1]);\r\n            joints.push(joint);\r\n        }\r\n        verts.push(points[0], points[1]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n        verts.push(points[2], points[3]);\r\n        joints.push(JOINT_TYPE.NONE);\r\n    }\r\n\r\n    fill(graphicsData: SmoothGraphicsData, target: BuildData): void\r\n    {\r\n        const { verts, joints } = target;\r\n        const { points } = graphicsData;\r\n\r\n        graphicsData.triangles = earcut(points, null, 2);\r\n\r\n        for (let i = 0, j = points.length; i < j; i++)\r\n        {\r\n            verts.push(points[i], points[++i]);\r\n            joints.push(JOINT_TYPE.FILL);\r\n        }\r\n    }\r\n}\r\n","import type { IShapeBuilder } from '../core/IShapeBuilder';\nimport { SmoothGraphicsData } from '../core/SmoothGraphicsData';\nimport { BuildData } from '../core/BuildData';\nimport { JOINT_TYPE } from '../core/const';\nimport { Point, Polygon } from '@pixi/math';\nimport { earcut } from '@pixi/utils';\n\nconst tempArr: Array<number> = [];\n\nexport class PolyBuilder implements IShapeBuilder\n{\n    path(graphicsData: SmoothGraphicsData, buildData: BuildData)\n    {\n        const shape = graphicsData.shape as Polygon;\n        const points = graphicsData.points = shape.points.slice();\n        const eps = buildData.closePointEps;\n        const eps2 = eps * eps;\n\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        const firstPoint = new Point(points[0], points[1]);\n        const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n        const closedShape = graphicsData.closeStroke = shape.closeStroke;\n\n        let len = points.length;\n        let newLen = 2;\n\n        // 1. remove equal points\n        for (let i = 2; i < len; i += 2)\n        {\n            const x1 = points[i - 2]; const y1 = points[i - 1]; const x2 = points[i]; const\n                y2 = points[i + 1];\n            let flag = true;\n\n            if (Math.abs(x1 - x2) < eps\n                && Math.abs(y1 - y2) < eps)\n            {\n                flag = false;\n            }\n\n            if (flag)\n            {\n                points[newLen] = points[i];\n                points[newLen + 1] = points[i + 1];\n                newLen += 2;\n            }\n        }\n        points.length = len = newLen;\n\n        newLen = 2;\n        // 2. remove middle points\n        for (let i = 2; i + 2 < len; i += 2)\n        {\n            let x1 = points[i - 2]; let y1 = points[i - 1]; const x2 = points[i]; const y2 = points[i + 1];\n            let x3 = points[i + 2]; let\n                y3 = points[i + 3];\n\n            x1 -= x2;\n            y1 -= y2;\n            x3 -= x2;\n            y3 -= y2;\n            let flag = true;\n\n            if (Math.abs(x3 * y1 - y3 * x1) < eps2)\n            {\n                if (x1 * x3 + y1 * y3 < -eps2)\n                {\n                    flag = false;\n                }\n            }\n\n            if (flag)\n            {\n                points[newLen] = points[i];\n                points[newLen + 1] = points[i + 1];\n                newLen += 2;\n            }\n        }\n        points[newLen] = points[len - 2];\n        points[newLen + 1] = points[len - 1];\n        newLen += 2;\n\n        points.length = len = newLen;\n\n        if (len <= 2)\n        {\n            // suddenly, nothing\n            return;\n        }\n\n        if (closedShape)\n        {\n            // first point should be last point in closed line!\n            const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n                && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n            if (closedPath)\n            {\n                points.pop();\n                points.pop();\n            }\n        }\n    }\n\n    line(graphicsData: SmoothGraphicsData, buildData: BuildData)\n    {\n        const { closeStroke, points } = graphicsData;\n        const eps = buildData.closePointEps;\n        // const eps2 = eps * eps;\n        const len = points.length;\n        // const style = graphicsData.lineStyle;\n\n        if (len <= 2)\n        {\n            return;\n        }\n        const { verts, joints } = buildData;\n\n        // TODO: alignment\n\n        const joint = graphicsData.jointType();\n        const cap = graphicsData.capType();\n        let prevCap = 0;\n\n        let prevX: number; let\n            prevY: number;\n\n        if (closeStroke)\n        {\n            prevX = points[len - 2];\n            prevY = points[len - 1];\n            joints.push(JOINT_TYPE.NONE);\n        }\n        else\n        {\n            prevX = points[2];\n            prevY = points[3];\n            if (cap === JOINT_TYPE.CAP_ROUND)\n            {\n                verts.push(points[0], points[1]);\n                joints.push(JOINT_TYPE.NONE);\n                joints.push(JOINT_TYPE.CAP_ROUND);\n                prevCap = 0;\n            }\n            else\n            {\n                prevCap = cap;\n                joints.push(JOINT_TYPE.NONE);\n            }\n        }\n        verts.push(prevX, prevY);\n\n        /* Line segments of interest where (x1,y1) forms the corner. */\n        for (let i = 0; i < len; i += 2)\n        {\n            const x1 = points[i]; const\n                y1 = points[i + 1];\n\n            let x2: number; let\n                y2: number;\n\n            if (i + 2 < len)\n            {\n                x2 = points[i + 2];\n                y2 = points[i + 3];\n            }\n            else\n            {\n                x2 = points[0];\n                y2 = points[1];\n            }\n\n            const dx = x2 - x1;\n            const dy = y2 - y1;\n            let nextX: number; let\n                nextY: number;\n\n            let endJoint = joint;\n\n            if (i + 2 >= len)\n            {\n                nextX = points[2];\n                nextY = points[3];\n                if (!closeStroke)\n                {\n                    endJoint = JOINT_TYPE.NONE;\n                }\n            }\n            else if (i + 4 >= len)\n            {\n                nextX = points[0];\n                nextY = points[1];\n                if (!closeStroke)\n                {\n                    if (cap === JOINT_TYPE.CAP_ROUND)\n                    {\n                        endJoint = JOINT_TYPE.JOINT_CAP_ROUND;\n                    }\n                    if (cap === JOINT_TYPE.CAP_BUTT)\n                    {\n                        endJoint = JOINT_TYPE.JOINT_CAP_BUTT;\n                    }\n                    if (cap === JOINT_TYPE.CAP_SQUARE)\n                    {\n                        endJoint = JOINT_TYPE.JOINT_CAP_SQUARE;\n                    }\n                }\n            }\n            else\n            {\n                nextX = points[i + 4];\n                nextY = points[i + 5];\n            }\n\n            const dx3 = x1 - prevX;\n            const dy3 = y1 - prevY;\n\n            if (joint >= JOINT_TYPE.JOINT_BEVEL && joint <= JOINT_TYPE.JOINT_MITER)\n            {\n                const dx2 = nextX - x2;\n                const dy2 = nextY - y2;\n\n                if (endJoint >= JOINT_TYPE.JOINT_BEVEL\n                    && endJoint <= JOINT_TYPE.JOINT_MITER + 3)\n                {\n                    const D = dx2 * dy - dy2 * dx;\n\n                    if (Math.abs(D) < eps)\n                    {\n                        switch (joint & ~3)\n                        {\n                            case JOINT_TYPE.JOINT_ROUND:\n                                endJoint = JOINT_TYPE.JOINT_CAP_ROUND;\n                                break;\n                            default:\n                                endJoint = JOINT_TYPE.JOINT_CAP_BUTT;\n                                break;\n                        }\n                    }\n                }\n\n                if (joint === JOINT_TYPE.JOINT_MITER)\n                {\n                    let jointAdd = 0;\n\n                    if (dx3 * dx + dy3 * dy > -eps)\n                    {\n                        jointAdd++;\n                    }\n                    if (endJoint === JOINT_TYPE.JOINT_MITER && dx2 * dx + dy2 * dy > -eps)\n                    {\n                        jointAdd += 2;\n                    }\n                    endJoint += jointAdd;\n                }\n            }\n            if (prevCap === 0)\n            {\n                if (Math.abs(dx3 * dy - dy3 * dx) < eps)\n                {\n                    prevCap = JOINT_TYPE.CAP_BUTT2;\n                }\n            }\n            endJoint += prevCap;\n            prevCap = 0;\n\n            verts.push(x1, y1);\n            joints.push(endJoint);\n\n            prevX = x1;\n            prevY = y1;\n        }\n\n        if (closeStroke)\n        {\n            verts.push(points[0], points[1]);\n            joints.push(JOINT_TYPE.NONE);\n            verts.push(points[2], points[3]);\n            joints.push(JOINT_TYPE.NONE);\n        }\n        else\n        {\n            verts.push(points[len - 4], points[len - 3]);\n            joints.push(JOINT_TYPE.NONE);\n        }\n    }\n\n    fill(graphicsData: SmoothGraphicsData, buildData: BuildData)\n    {\n        let points = graphicsData.points;\n        // TODO: simplify holes too!\n        const holes = graphicsData.holes;\n        const eps = buildData.closePointEps;\n\n        const { verts, joints } = buildData;\n\n        if (points.length < 6)\n        {\n            return;\n        }\n        const holeArray = [];\n        let len = points.length;\n        // Process holes..\n\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n\n            holeArray.push(points.length / 2);\n            points = points.concat(hole.points);\n        }\n\n        // TODO: reduce size later?\n        const pn = tempArr;\n\n        if (pn.length < points.length)\n        {\n            pn.length = points.length;\n        }\n        const start = 0;\n\n        for (let i = 0; i <= holeArray.length; i++)\n        {\n            let finish = len / 2;\n\n            if (i > 0)\n            {\n                if (i < holeArray.length)\n                {\n                    finish = holeArray[i];\n                }\n                else\n                {\n                    finish = (points.length >> 1);\n                }\n            }\n            pn[start * 2] = finish - 1;\n            pn[(finish - 1) * 2 + 1] = 0;\n            for (let j = start; j + 1 < finish; j++)\n            {\n                pn[j * 2 + 1] = j + 1;\n                pn[j * 2 + 2] = j;\n            }\n        }\n\n        // sort color\n        graphicsData.triangles = earcut(points, holeArray, 2);\n\n        if (!graphicsData.triangles)\n        {\n            return;\n        }\n\n        if (!graphicsData.fillAA)\n        {\n            for (let i = 0; i < points.length; i += 2)\n            {\n                verts.push(points[i], points[i + 1]);\n                joints.push(JOINT_TYPE.FILL);\n            }\n\n            return;\n        }\n\n        const { triangles } = graphicsData;\n\n        len = points.length;\n\n        for (let i = 0; i < triangles.length; i += 3)\n        {\n            // TODO: holes prev/next!!!\n            let flag = 0;\n\n            for (let j = 0; j < 3; j++)\n            {\n                const ind1 = triangles[i + j];\n                const ind2 = triangles[i + (j + 1) % 3];\n\n                if (pn[ind1 * 2] === ind2 || pn[ind1 * 2 + 1] === ind2)\n                {\n                    flag |= (1 << j);\n                }\n            }\n            joints.push(JOINT_TYPE.FILL_EXPAND + flag);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n            joints.push(JOINT_TYPE.NONE);\n        }\n\n        // bisect, re-using pn\n        for (let ind = 0; ind < len / 2; ind++)\n        {\n            const prev = pn[ind * 2];\n            const next = pn[ind * 2 + 1];\n            let nx1 = (points[next * 2 + 1] - points[ind * 2 + 1]); let\n                ny1 = -(points[next * 2] - points[ind * 2]);\n            let nx2 = (points[ind * 2 + 1] - points[prev * 2 + 1]); let\n                ny2 = -(points[ind * 2] - points[prev * 2]);\n            const D1 = Math.sqrt(nx1 * nx1 + ny1 * ny1);\n\n            nx1 /= D1;\n            ny1 /= D1;\n            const D2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n\n            nx2 /= D2;\n            ny2 /= D2;\n\n            let bx = (nx1 + nx2);\n            let by = (ny1 + ny2);\n            const D = bx * nx1 + by * ny1;\n\n            if (Math.abs(D) < eps)\n            {\n                bx = nx1;\n                by = ny1;\n            }\n            else\n            {\n                bx /= D;\n                by /= D;\n            }\n            pn[ind * 2] = bx;\n            pn[ind * 2 + 1] = by;\n        }\n\n        for (let i = 0; i < triangles.length; i += 3)\n        {\n            const prev = triangles[i];\n            const ind = triangles[i + 1];\n            const next = triangles[i + 2];\n            const nx1 = (points[next * 2 + 1] - points[ind * 2 + 1]); const\n                ny1 = -(points[next * 2] - points[ind * 2]);\n            const nx2 = (points[ind * 2 + 1] - points[prev * 2 + 1]); const\n                ny2 = -(points[ind * 2] - points[prev * 2]);\n\n            let j1 = 1;\n\n            if (nx1 * ny2 - nx2 * ny1 > 0.0)\n            {\n                j1 = 2;\n            }\n\n            for (let j = 0; j < 3; j++)\n            {\n                const ind = triangles[i + (j * j1) % 3];\n\n                verts.push(points[ind * 2], points[ind * 2 + 1]);\n            }\n            for (let j = 0; j < 3; j++)\n            {\n                const ind = triangles[i + (j * j1) % 3];\n\n                verts.push(pn[ind * 2], pn[ind * 2 + 1]);\n            }\n        }\n    }\n}\n"],"names":["verts"],"mappings":";w6NAoPA,uBAEA,gCAGAA,uBAEA,oDAMAA,8BACAA,gCACAA,gCACAA,gCACAA,8BACAA,gCACAA,gCACAA,gCACAA,8BACAA,gCACAA,gCACAA,gCACAA,iCACAA,mCACAA,mCACAA,qCACAA,kCACAA,oCAEAA,6jGC7QA,mCAOA,w6BCPA"}