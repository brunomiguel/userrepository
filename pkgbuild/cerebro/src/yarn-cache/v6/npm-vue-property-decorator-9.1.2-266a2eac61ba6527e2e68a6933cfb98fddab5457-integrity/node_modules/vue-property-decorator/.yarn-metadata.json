{
  "manifest": {
    "name": "vue-property-decorator",
    "version": "9.1.2",
    "description": "property decorators for Vue Component",
    "main": "lib/index.umd.js",
    "module": "lib/index.js",
    "keywords": [
      "vue",
      "typescript",
      "decorator"
    ],
    "author": {
      "name": "kaorun343"
    },
    "license": "MIT",
    "scripts": {
      "build": "tsc -p ./src/tsconfig.json && rollup -c",
      "test": "jest"
    },
    "files": [
      "lib"
    ],
    "devDependencies": {
      "@types/jest": "^26.0.15",
      "@types/node": "^14.14.9",
      "jest": "^26.6.3",
      "reflect-metadata": "^0.1.13",
      "rollup": "^2.33.3",
      "ts-jest": "^26.4.4",
      "typescript": "^4.1.2",
      "vue": "^2.6.10",
      "vue-class-component": "^7.2.3"
    },
    "typings": "./lib/index.d.ts",
    "dependencies": {},
    "peerDependencies": {
      "vue": "*",
      "vue-class-component": "*"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/kaorun343/vue-property-decorator.git"
    },
    "bugs": {
      "url": "https://github.com/kaorun343/vue-property-decorator/issues"
    },
    "homepage": "https://github.com/kaorun343/vue-property-decorator#readme",
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-vue-property-decorator-9.1.2-266a2eac61ba6527e2e68a6933cfb98fddab5457-integrity/node_modules/vue-property-decorator/package.json",
    "readmeFilename": "README.md",
    "readme": "# Vue Property Decorator\n\n[![npm](https://img.shields.io/npm/v/vue-property-decorator.svg)](https://www.npmjs.com/package/vue-property-decorator)\n[![Build Status](https://travis-ci.org/kaorun343/vue-property-decorator.svg?branch=master)](https://travis-ci.org/kaorun343/vue-property-decorator)\n\nThis library fully depends on [vue-class-component](https://github.com/vuejs/vue-class-component), so please read its README before using this library.\n\n## License\n\nMIT License\n\n## Install\n\n```bash\nnpm i -S vue-property-decorator\n```\n\n## Usage\n\nThere are several decorators and 1 function (Mixin):\n\n- [`@Prop`](#Prop)\n- [`@PropSync`](#PropSync)\n- [`@Model`](#Model)\n- [`@ModelSync`](#ModelSync)\n- [`@Watch`](#Watch)\n- [`@Provide`](#Provide)\n- [`@Inject`](#Provide)\n- [`@ProvideReactive`](#ProvideReactive)\n- [`@InjectReactive`](#ProvideReactive)\n- [`@Emit`](#Emit)\n- [`@Ref`](#Ref)\n- [`@VModel`](#VModel)\n- `@Component` (**provided by** [vue-class-component](https://github.com/vuejs/vue-class-component))\n- `Mixins` (the helper function named `mixins` **provided by** [vue-class-component](https://github.com/vuejs/vue-class-component))\n\n## See also\n\n[vuex-class](https://github.com/ktsn/vuex-class/)\n\n### <a id=\"Prop\"></a> `@Prop(options: (PropOptions | Constructor[] | Constructor) = {})` decorator\n\n```ts\nimport { Vue, Component, Prop } from 'vue-property-decorator'\n\n@Component\nexport default class YourComponent extends Vue {\n  @Prop(Number) readonly propA: number | undefined\n  @Prop({ default: 'default value' }) readonly propB!: string\n  @Prop([String, Boolean]) readonly propC: string | boolean | undefined\n}\n```\n\nis equivalent to\n\n```js\nexport default {\n  props: {\n    propA: {\n      type: Number,\n    },\n    propB: {\n      default: 'default value',\n    },\n    propC: {\n      type: [String, Boolean],\n    },\n  },\n}\n```\n\n**Note that:**\n\n## If you'd like to set `type` property of each prop value from its type definition, you can use [reflect-metadata](https://github.com/rbuckton/reflect-metadata).\n\n1. Set `emitDecoratorMetadata` to `true`.\n2. Import `reflect-metadata` **before** importing `vue-property-decorator` (importing `reflect-metadata` is needed just once.)\n\n```ts\nimport 'reflect-metadata'\nimport { Vue, Component, Prop } from 'vue-property-decorator'\n\n@Component\nexport default class MyComponent extends Vue {\n  @Prop() age!: number\n}\n```\n\n## Each prop's default value need to be defined as same as the example code shown in above.\n\nIt's **not** supported to define each `default` property like `@Prop() prop = 'default value'` .\n\n### <a id=\"PropSync\"></a> `@PropSync(propName: string, options: (PropOptions | Constructor[] | Constructor) = {})` decorator\n\n```ts\nimport { Vue, Component, PropSync } from 'vue-property-decorator'\n\n@Component\nexport default class YourComponent extends Vue {\n  @PropSync('name', { type: String }) syncedName!: string\n}\n```\n\nis equivalent to\n\n```js\nexport default {\n  props: {\n    name: {\n      type: String,\n    },\n  },\n  computed: {\n    syncedName: {\n      get() {\n        return this.name\n      },\n      set(value) {\n        this.$emit('update:name', value)\n      },\n    },\n  },\n}\n```\n\n[`@PropSync`](#PropSync) works like [`@Prop`](#Prop) besides the fact that it takes the propName as an argument of the decorator, and also creates a computed getter and setter behind the scenes. This way you can interface with the property as if it was a regular data property whilst making it as easy as appending the `.sync` modifier in the parent component.\n\n### <a id=\"Model\"></a> `@Model(event?: string, options: (PropOptions | Constructor[] | Constructor) = {})` decorator\n\n```ts\nimport { Vue, Component, Model } from 'vue-property-decorator'\n\n@Component\nexport default class YourComponent extends Vue {\n  @Model('change', { type: Boolean }) readonly checked!: boolean\n}\n```\n\nis equivalent to\n\n```js\nexport default {\n  model: {\n    prop: 'checked',\n    event: 'change',\n  },\n  props: {\n    checked: {\n      type: Boolean,\n    },\n  },\n}\n```\n\n`@Model` property can also set `type` property from its type definition via `reflect-metadata` .\n\n### <a id=\"ModelSync\"></a> `@ModelSync(propName: string, event?: string, options: (PropOptions | Constructor[] | Constructor) = {})` decorator\n\n```ts\nimport { Vue, Component, ModelSync } from 'vue-property-decorator'\n\n@Component\nexport default class YourComponent extends Vue {\n  @ModelSync('checked', 'change', { type: Boolean })\n  readonly checkedValue!: boolean\n}\n```\n\nis equivalent to\n\n```js\nexport default {\n  model: {\n    prop: 'checked',\n    event: 'change',\n  },\n  props: {\n    checked: {\n      type: Boolean,\n    },\n  },\n  computed: {\n    checkedValue: {\n      get() {\n        return this.checked\n      },\n      set(value) {\n        this.$emit('change', value)\n      },\n    },\n  },\n}\n```\n\n`@ModelSync` property can also set `type` property from its type definition via `reflect-metadata` .\n\n### <a id=\"Watch\"></a> `@Watch(path: string, options: WatchOptions = {})` decorator\n\n```ts\nimport { Vue, Component, Watch } from 'vue-property-decorator'\n\n@Component\nexport default class YourComponent extends Vue {\n  @Watch('child')\n  onChildChanged(val: string, oldVal: string) {}\n\n  @Watch('person', { immediate: true, deep: true })\n  onPersonChanged1(val: Person, oldVal: Person) {}\n\n  @Watch('person')\n  onPersonChanged2(val: Person, oldVal: Person) {}\n}\n```\n\nis equivalent to\n\n```js\nexport default {\n  watch: {\n    child: [\n      {\n        handler: 'onChildChanged',\n        immediate: false,\n        deep: false,\n      },\n    ],\n    person: [\n      {\n        handler: 'onPersonChanged1',\n        immediate: true,\n        deep: true,\n      },\n      {\n        handler: 'onPersonChanged2',\n        immediate: false,\n        deep: false,\n      },\n    ],\n  },\n  methods: {\n    onChildChanged(val, oldVal) {},\n    onPersonChanged1(val, oldVal) {},\n    onPersonChanged2(val, oldVal) {},\n  },\n}\n```\n\n### <a id=\"Provide\"></a> `@Provide(key?: string | symbol)` / `@Inject(options?: { from?: InjectKey, default?: any } | InjectKey)` decorator\n\n```ts\nimport { Component, Inject, Provide, Vue } from 'vue-property-decorator'\n\nconst symbol = Symbol('baz')\n\n@Component\nexport class MyComponent extends Vue {\n  @Inject() readonly foo!: string\n  @Inject('bar') readonly bar!: string\n  @Inject({ from: 'optional', default: 'default' }) readonly optional!: string\n  @Inject(symbol) readonly baz!: string\n\n  @Provide() foo = 'foo'\n  @Provide('bar') baz = 'bar'\n}\n```\n\nis equivalent to\n\n```js\nconst symbol = Symbol('baz')\n\nexport const MyComponent = Vue.extend({\n  inject: {\n    foo: 'foo',\n    bar: 'bar',\n    optional: { from: 'optional', default: 'default' },\n    baz: symbol,\n  },\n  data() {\n    return {\n      foo: 'foo',\n      baz: 'bar',\n    }\n  },\n  provide() {\n    return {\n      foo: this.foo,\n      bar: this.baz,\n    }\n  },\n})\n```\n\n### <a id=\"ProvideReactive\"></a> `@ProvideReactive(key?: string | symbol)` / `@InjectReactive(options?: { from?: InjectKey, default?: any } | InjectKey)` decorator\n\nThese decorators are reactive version of `@Provide` and `@Inject`. If a provided value is modified by parent component, then the child component can catch this modification.\n\n```ts\nconst key = Symbol()\n@Component\nclass ParentComponent extends Vue {\n  @ProvideReactive() one = 'value'\n  @ProvideReactive(key) two = 'value'\n}\n\n@Component\nclass ChildComponent extends Vue {\n  @InjectReactive() one!: string\n  @InjectReactive(key) two!: string\n}\n```\n\n### <a id=\"Emit\"></a> `@Emit(event?: string)` decorator\n\nThe functions decorated by `@Emit` `$emit` their return value followed by their original arguments. If the return value is a promise, it is resolved before being emitted.\n\nIf the name of the event is not supplied via the `event` argument, the function name is used instead. In that case, the camelCase name will be converted to kebab-case.\n\n```ts\nimport { Vue, Component, Emit } from 'vue-property-decorator'\n\n@Component\nexport default class YourComponent extends Vue {\n  count = 0\n\n  @Emit()\n  addToCount(n: number) {\n    this.count += n\n  }\n\n  @Emit('reset')\n  resetCount() {\n    this.count = 0\n  }\n\n  @Emit()\n  returnValue() {\n    return 10\n  }\n\n  @Emit()\n  onInputChange(e) {\n    return e.target.value\n  }\n\n  @Emit()\n  promise() {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(20)\n      }, 0)\n    })\n  }\n}\n```\n\nis equivalent to\n\n```js\nexport default {\n  data() {\n    return {\n      count: 0,\n    }\n  },\n  methods: {\n    addToCount(n) {\n      this.count += n\n      this.$emit('add-to-count', n)\n    },\n    resetCount() {\n      this.count = 0\n      this.$emit('reset')\n    },\n    returnValue() {\n      this.$emit('return-value', 10)\n    },\n    onInputChange(e) {\n      this.$emit('on-input-change', e.target.value, e)\n    },\n    promise() {\n      const promise = new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(20)\n        }, 0)\n      })\n\n      promise.then((value) => {\n        this.$emit('promise', value)\n      })\n    },\n  },\n}\n```\n\n### <a id=\"Ref\"></a> `@Ref(refKey?: string)` decorator\n\n```ts\nimport { Vue, Component, Ref } from 'vue-property-decorator'\n\nimport AnotherComponent from '@/path/to/another-component.vue'\n\n@Component\nexport default class YourComponent extends Vue {\n  @Ref() readonly anotherComponent!: AnotherComponent\n  @Ref('aButton') readonly button!: HTMLButtonElement\n}\n```\n\nis equivalent to\n\n```js\nexport default {\n  computed() {\n    anotherComponent: {\n      cache: false,\n      get() {\n        return this.$refs.anotherComponent as AnotherComponent\n      }\n    },\n    button: {\n      cache: false,\n      get() {\n        return this.$refs.aButton as HTMLButtonElement\n      }\n    }\n  }\n}\n```\n\n### <a id=\"VModel\"></a> `@VModel(propsArgs?: PropOptions)` decorator\n\n```ts\nimport { Vue, Component, VModel } from 'vue-property-decorator'\n\n@Component\nexport default class YourComponent extends Vue {\n  @VModel({ type: String }) name!: string\n}\n```\n\nis equivalent to\n\n```js\nexport default {\n  props: {\n    value: {\n      type: String,\n    },\n  },\n  computed: {\n    name: {\n      get() {\n        return this.value\n      },\n      set(value) {\n        this.$emit('input', value)\n      },\n    },\n  },\n}\n```\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2018 kaorun343\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/vue-property-decorator/-/vue-property-decorator-9.1.2.tgz#266a2eac61ba6527e2e68a6933cfb98fddab5457",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/vue-property-decorator/-/vue-property-decorator-9.1.2.tgz",
    "hash": "266a2eac61ba6527e2e68a6933cfb98fddab5457",
    "integrity": "sha512-xYA8MkZynPBGd/w5QFJ2d/NM0z/YeegMqYTphy7NJQXbZcuU6FC6AOdUAcy4SXP+YnkerC6AfH+ldg7PDk9ESQ==",
    "registry": "npm",
    "packageName": "vue-property-decorator",
    "cacheIntegrity": "sha512-xYA8MkZynPBGd/w5QFJ2d/NM0z/YeegMqYTphy7NJQXbZcuU6FC6AOdUAcy4SXP+YnkerC6AfH+ldg7PDk9ESQ== sha1-JmourGG6ZSfi5oppM8+5j92rVFc="
  },
  "registry": "npm",
  "hash": "266a2eac61ba6527e2e68a6933cfb98fddab5457"
}