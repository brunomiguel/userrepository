{
  "manifest": {
    "name": "find-my-way",
    "version": "7.3.1",
    "description": "Crazy fast http radix based router",
    "main": "index.js",
    "types": "index.d.ts",
    "scripts": {
      "bench": "node bench.js",
      "bench:cmp": "node bench-cmp.js",
      "bench:cmp:ci": "node bench-cmp.js --ci",
      "test:lint": "standard",
      "test:typescript": "tsd",
      "test": "standard && tap -J test/*.test.js && npm run test:typescript",
      "test:report": "tap -J test/*.test.js --cov --coverage-report=html --coverage-report=cobertura | tee out.tap",
      "test:reporter": "tap-mocha-reporter xunit < out.tap > test/junit-testresults.xml"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/delvedor/find-my-way.git"
    },
    "keywords": [
      "http",
      "router",
      "radix",
      "fast",
      "speed"
    ],
    "engines": {
      "node": ">=14"
    },
    "author": {
      "name": "Tomas Della Vedova - @delvedor",
      "url": "http://delved.org"
    },
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/delvedor/find-my-way/issues"
    },
    "homepage": "https://github.com/delvedor/find-my-way#readme",
    "devDependencies": {
      "@types/node": "^14.0.27",
      "benchmark": "^2.1.4",
      "chalk": "^4.1.2",
      "inquirer": "^8.2.4",
      "pre-commit": "^1.2.2",
      "simple-git": "^3.7.1",
      "standard": "^14.3.4",
      "tap": "^16.0.1",
      "tap-mocha-reporter": "^5.0.1",
      "tsd": "^0.13.1"
    },
    "dependencies": {
      "fast-deep-equal": "^3.1.3",
      "fast-querystring": "^1.0.0",
      "safe-regex2": "^2.0.0"
    },
    "tsd": {
      "directory": "test/types"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-find-my-way-7.3.1-fd8a0b468a18c283e05be59f93a627f37e306cfa-integrity/node_modules/find-my-way/package.json",
    "readmeFilename": "README.md",
    "readme": "# find-my-way\n\n[![js-standard-style](https://img.shields.io/badge/code%20style-standard-brightgreen.svg?style=flat)](http://standardjs.com/)  ![Node CI](https://github.com/delvedor/find-my-way/workflows/Node%20CI/badge.svg) [![NPM downloads](https://img.shields.io/npm/dm/find-my-way.svg?style=flat)](https://www.npmjs.com/package/find-my-way)\n\nA crazy fast HTTP router, internally uses an highly performant [Radix Tree](https://en.wikipedia.org/wiki/Radix_tree) (aka compact [Prefix Tree](https://en.wikipedia.org/wiki/Trie)), supports route params, wildcards, and it's framework independent.\n\nIf you want to see a benchmark comparison with the most commonly used routers, see [here](https://github.com/delvedor/router-benchmark).<br>\nDo you need a real-world example that uses this router? Check out [Fastify](https://github.com/fastify/fastify) or [Restify](https://github.com/restify/node-restify).\n\n- [Install](#install)\n- [Usage](#usage)\n- [API](#api)\n  - [FindMyWay([options])](#find-my-way)\n  - [on(method, path, [opts], handler, [store])](#onmethod-path-opts-handler-store)\n    - [Versioned routes](#versioned-routes)\n      - [default](#default)\n      - [custom](#custom)\n    - [on(methods[], path, [opts], handler, [store])](#onmethods-path-opts-handler-store)\n    - [Supported path formats](#supported-path-formats)\n    - [Match order](#match-order)\n    - [Supported methods](#supported-methods)\n  - [off(method, path)](#offmethod-path)\n    - [off(methods[], path)](#offmethods-path)\n    - [off(methods, path, [constraints])](#offmethods-path-constraints)\n  - [lookup(request, response, [context], [done])](#lookuprequest-response-context)\n  - [find(method, path, [constraints])](#findmethod-path-constraints)\n  - [prettyPrint([{ commonPrefix: false, includeMeta: true || [] }])](#prettyprint-commonprefix-false-includemeta-true---)\n  - [reset()](#reset)\n  - [routes](#routes)\n  - [Caveats](#caveats)\n  - [Shorthand methods](#shorthand-methods)\n- [Constraints](#constraints)\n  - [Custom Constraint Strategies](#custom-constraint-strategies)\n- [Acknowledgements](#acknowledgements)\n- [License](#license)\n\n<a name=\"install\"></a>\n## Install\n```\nnpm i find-my-way --save\n```\n\n<a name=\"usage\"></a>\n## Usage\n```js\nconst http = require('http')\nconst router = require('find-my-way')()\n\nrouter.on('GET', '/', (req, res, params) => {\n  res.end('{\"message\":\"hello world\"}')\n})\n\nconst server = http.createServer((req, res) => {\n  router.lookup(req, res)\n})\n\nserver.listen(3000, err => {\n  if (err) throw err\n  console.log('Server listening on: http://localhost:3000')\n})\n```\n\n<a name=\"api\"></a>\n## API\n<a name=\"constructor\"></a>\n#### FindMyWay([options])\nInstance a new router.<br>\nYou can pass a default route with the option `defaultRoute`.\n```js\nconst router = require('find-my-way')({\n  defaultRoute: (req, res) => {\n    res.statusCode = 404\n    res.end()\n  }\n})\n```\n\nIn case of a badly formatted url *(eg: `/hello/%world`)*, by default `find-my-way` will invoke the `defaultRoute`, unless you specify the `onBadUrl` option:\n```js\nconst router = require('find-my-way')({\n  onBadUrl: (path, req, res) => {\n    res.statusCode = 400\n    res.end(`Bad path: ${path}`)\n  }\n})\n```\n\nTrailing slashes can be ignored by supplying the `ignoreTrailingSlash` option:\n```js\nconst router = require('find-my-way')({\n  ignoreTrailingSlash: true\n})\nfunction handler (req, res, params) {\n  res.end('foo')\n}\n// maps \"/foo/\" and \"/foo\" to `handler`\nrouter.on('GET', '/foo/', handler)\n```\n\nDuplicate slashes can be ignored by supplying the `ignoreDuplicateSlashes` option:\n```js\nconst router = require('find-my-way')({\n  ignoreDuplicateSlashes: true\n})\nfunction handler (req, res, params) {\n  res.end('foo')\n}\n// maps \"/foo\", \"//foo\", \"///foo\", etc to `handler`\nrouter.on('GET', '////foo', handler)\n```\n\nNote that when `ignoreTrailingSlash` and `ignoreDuplicateSlashes` are both set to true, duplicate slashes will first be removed and then trailing slashes will, meaning `//a//b//c//` will be converted to `/a/b/c`.\n\nYou can set a custom length for parameters in parametric *(standard, regex and multi)* routes by using `maxParamLength` option, the default value is 100 characters.<br/>\n*If the maximum length limit is reached, the default route will be invoked.*\n```js\nconst router = require('find-my-way')({\n  maxParamLength: 500\n})\n```\n\nIf you are using a regex based route, `find-my-way` will throw an error if detects potentially catastrophic exponential-time regular expressions *(internally uses [`safe-regex2`](https://github.com/fastify/safe-regex2))*.<br/>\nIf you want to disable this behavior, pass the option `allowUnsafeRegex`.\n```js\nconst router = require('find-my-way')({\n  allowUnsafeRegex: true\n})\n```\n\nAccording to [RFC3986](https://tools.ietf.org/html/rfc3986#section-6.2.2.1), find-my-way is case sensitive by default.\nYou can disable this by setting the `caseSensitive` option to `false`:\nin that case, all paths will be matched as lowercase, but the route parameters or wildcards will maintain their original letter casing. You can turn off case sensitivity with:\n\n```js\nconst router = require('find-my-way')({\n  caseSensitive: false\n})\n```\n\nThe default query string parser that find-my-way uses is [fast-querystring](https://www.npmjs.com/package/fast-querystring) module. You can change this default setting by passing the option querystringParser and use a custom one, such as [qs](https://www.npmjs.com/package/qs).\n\n```js\nconst qs = require('qs')\nconst router = require('find-my-way')({\n  querystringParser: str => qs.parse(str)\n})\n\nrouter.on('GET', '/', (req, res, params, store, searchParams) => {\n  assert.equal(searchParams, { foo: 'bar', baz: 'faz' })\n})\n\nrouter.lookup({ method: 'GET', url: '/?foo=bar&baz=faz' }, null)\n```\n\nYou can assign a `buildPrettyMeta` function to sanitize a route's `store` object to use with the `prettyPrint` functions. This function should accept a single object and return an object.\n\n```js\n\nconst privateKey = new Symbol('private key')\nconst store = { token: '12345', [privateKey]: 'private value' }\n\nconst router = require('find-my-way')({\n  buildPrettyMeta: route => {\n    const cleanMeta = Object.assign({}, route.store)\n\n    // remove private properties\n    Object.keys(cleanMeta).forEach(k => {\n      if (typeof k === 'symbol') delete cleanMeta[k]\n    })\n\n    return cleanMeta // this will show up in the pretty print output!\n  }\n})\n\nstore[privateKey] = 'private value'\nrouter.on('GET', '/hello_world', (req, res) => {}, store)\n\nrouter.prettyPrint()\n\n//└── / (-)\n//    └── hello_world (GET)\n//        • (token) \"12345\"\n\n```\n\n\n<a name=\"on\"></a>\n#### on(method, path, [opts], handler, [store])\nRegister a new route.\n```js\nrouter.on('GET', '/example', (req, res, params, store, searchParams) => {\n  // your code\n})\n```\nLast argument, `store` is used to pass an object that you can access later inside the handler function. If needed, `store` can be updated.\n```js\nrouter.on('GET', '/example', (req, res, params, store) => {\n  assert.equal(store, { message: 'hello world' })\n}, { message: 'hello world' })\n```\n\n##### Versioned routes\n\nIf needed, you can provide a `version` route constraint, which will allow you to declare multiple versions of the same route that are used selectively when requests ask for different version using the `Accept-Version` header. This is useful if you want to support several different behaviours for a given route and different clients select among them.\n\nIf you never configure a versioned route, the `'Accept-Version'` header will be ignored. Remember to set a [Vary](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary) header in your responses with the value you are using for defining the versioning (e.g.: 'Accept-Version'), to prevent cache poisoning attacks. You can also configure this as part your Proxy/CDN.\n\n###### default\n<a name=\"semver\"></a>\nThe default versioning strategy follows the [semver](https://semver.org/) specification. When using `lookup`, `find-my-way` will automatically detect the `Accept-Version` header and route the request accordingly. Internally `find-my-way` uses the [`semver-store`](https://github.com/delvedor/semver-store) to get the correct version of the route; *advanced ranges* and *pre-releases* currently are not supported.\n\n*Be aware that using this feature will cause a degradation of the overall performances of the router.*\n\n```js\nrouter.on('GET', '/example', { constraints: { version: '1.2.0' }}, (req, res, params) => {\n  res.end('Hello from 1.2.0!')\n})\n\nrouter.on('GET', '/example', { constraints: { version: '2.4.0' }}, (req, res, params) => {\n  res.end('Hello from 2.4.0!')\n})\n\n// The 'Accept-Version' header could be '1.2.0' as well as '*', '2.x' or '2.4.x'\n```\n\nIf you declare multiple versions with the same *major* or *minor* `find-my-way` will always choose the highest compatible with the `Accept-Version` header value.\n\n###### custom\nIt's also possible to define a [custom versioning strategy](#custom-versioning) during the `find-my-way` initialization. In this case the logic of matching the request to the specific handler depends on the versioning strategy you use.\n\n##### on(methods[], path, [opts], handler, [store])\nRegister a new route for each method specified in the `methods` array.\nIt comes handy when you need to declare multiple routes with the same handler but different methods.\n```js\nrouter.on(['GET', 'POST'], '/example', (req, res, params) => {\n  // your code\n})\n```\n\n<a name=\"supported-path-formats\"></a>\n##### Supported path formats\nTo register a **parametric** path, use the *colon* before the parameter name. For **wildcard** use the *star*.\n*Remember that static routes are always inserted before parametric and wildcard.*\n\n```js\n// parametric\nrouter.on('GET', '/example/:userId', (req, res, params) => {}))\nrouter.on('GET', '/example/:userId/:secretToken', (req, res, params) => {}))\n\n// wildcard\nrouter.on('GET', '/example/*', (req, res, params) => {}))\n```\n\nRegular expression routes are supported as well, but pay attention, RegExp are very expensive in term of performance!<br>\nIf you want to declare a regular expression route, you must put the regular expression inside round parenthesis after the parameter name.\n```js\n// parametric with regexp\nrouter.on('GET', '/example/:file(^\\\\d+).png', () => {}))\n```\n\nIt's possible to define more than one parameter within the same couple of slash (\"/\"). Such as:\n```js\nrouter.on('GET', '/example/near/:lat-:lng/radius/:r', (req, res, params) => {}))\n```\n*Remember in this case to use the dash (\"-\") as parameters separator.*\n\nFinally it's possible to have multiple parameters with RegExp.\n```js\nrouter.on('GET', '/example/at/:hour(^\\\\d{2})h:minute(^\\\\d{2})m', (req, res, params) => {}))\n```\nIn this case as parameter separator it's possible to use whatever character is not matched by the regular expression.\n\nThe last parameter can be made optional if you add a question mark (\"?\") at the end of the parameters name.\n```js\nrouter.on('GET', '/example/posts/:id?', (req, res, params) => {}))\n```\nIn this case you can request `/example/posts` as well as `/example/posts/1`. The optional param will be undefined if not specified.\n\nHaving a route with multiple parameters may affect negatively the performance, so prefer single parameter approach whenever possible, especially on routes which are on the hot path of your application.\n\n**Note** that you must encode the parameters containing [reserved characters](https://www.rfc-editor.org/rfc/rfc3986#section-2.2).\n\n<a name=\"match-order\"></a>\n##### Match order\n\nThe routing algorithm matches one chunk at a time (where the chunk is a string between two slashes),\nthis means that it cannot know if a route is static or dynamic until it finishes to match the URL.\n\nThe chunks are matched in the following order:\n\n1. static\n1. parametric\n1. wildcards\n1. parametric(regex)\n1. multi parametric(regex)\n\nSo if you declare the following routes\n\n- `/:userId/foo/bar`\n- `/33/:a(^.*$)/:b`\n\nand the URL of the incoming request is /33/foo/bar,\nthe second route will be matched because the first chunk (33) matches the static chunk.\nIf the URL would have been /32/foo/bar, the first route would have been matched.\nOnce a url has been matched, `find-my-way` will figure out which handler registered for that path matches the request if there are any constraints.\n`find-my-way` will check the most constrained handlers first, which means the handlers with the most keys in the `constraints` object.\n\n> If you just want a path containing a colon without declaring a parameter, use a double colon.\n> For example, `/name::customVerb` will be interpreted as `/name:customVerb`\n\n<a name=\"supported-methods\"></a>\n##### Supported methods\nThe router is able to route all HTTP methods defined by [`http` core module](https://nodejs.org/api/http.html#http_http_methods).\n\n<a name=\"off\"></a>\n#### off(methods[], path, [constraints])\n\nUsed to deregister routes.\n\n<a name=\"off-without-constraints\"></a>\n##### off(methods, path)\n\nIf no constraint argument is passed, all routes with identical path and method are deregistered, regardless of whether \na route has constraints or not.\n\n```js\nrouter.on('GET', '/example', { constraints: { host: 'fastify.io' } })\nrouter.on('GET', '/example', { constraints: { version: '1.x' } })\nrouter.on('GET', '/example')\n\n// Deregisters all 3 routes registered above\nrouter.off('GET', '/example')\n```\n\n##### off(methods, path, constraints)\n\nIf a constraint object is specified, only those routes are deleted that have the same constraints as well as the \nidentical path and method. If an empty object is passed, only unconstrained routes will be deleted.\n```js\nrouter.on('GET', '/example', { constraints: { host: 'fastify.io' } })\nrouter.on('GET', '/example', { constraints: { version: '1.x' } })\nrouter.on('GET', '/example')\n\n// Deregisters only the third route without constraints\nrouter.off('GET', '/example', {})\n\n// Deregisters only the first route\nrouter.off('GET', '/example', { host: 'fastify.io' })\n```\n\n##### off(methods[], path)\n\nDeregister a route for each method specified in the methods array. It comes handy when you need to deregister multiple \nroutes with the same path but different methods. As explained above, the constraints will be ignored here.\n\n```js\nrouter.on('GET', '/example', { constraints: { host: 'fastify.io' } })\nrouter.on('POST', '/example', { constraints: { version: '1.x' } })\nrouter.on('PUT', '/example')\n\n// Deregisters all 3 routes registered above\nrouter.off(['POST', 'GET', 'PUT'], '/example')\n```\n\n##### off(methods[], path, constraints)\n\n```js\nrouter.on('GET', '/example', { constraints: { host: 'fastify.io' } }) // first route\nrouter.on('POST', '/example', { constraints: { host: 'fastify.io' } }) // second route\nrouter.on('POST', '/example', { constraints: { host: 'google.de' } }) // third route\nrouter.on('GET', '/example') // fourth route \nrouter.on('POST', '/example') // fifth route \n\n// Deregisters only first and second route\nrouter.off(['POST', 'GET'], '/example', { host: 'fastify.io' })\n\n// Deregisters only fourth and fifth route\nrouter.off(['POST', 'GET'], '/example', {})\n```\n\n#### lookup(request, response, [context], [done])\nStart a new search, `request` and `response` are the server req/res objects.<br>\nIf a route is found it will automatically call the handler, otherwise the default route will be called.<br>\nThe url is sanitized internally, all the parameters and wildcards are decoded automatically.\n```js\nrouter.lookup(req, res)\n```\n\n`lookup` accepts an optional context which will be the value of `this` when executing a handler\n```js\nrouter.on('GET', '*', function(req, res) {\n  res.end(this.greeting);\n})\nrouter.lookup(req, res, { greeting: 'Hello, World!' })\n```\n\n`lookup` accepts an optional `done` callback for case when you use an async `deriveConstraint` function.\n```js\nrouter.on('GET', '*', function(req, res) {\n  res.end({ hello: 'world' });\n})\nrouter.lookup(req, res, (err) => {\n  if (err !== null) {\n    // handle error\n  }\n  console.log('Handler executed!!!'); \n})\n```\n\n<a name=\"find\"></a>\n#### find(method, path, [constraints])\nReturn (if present) the route registered in *method:path*.<br>\nThe path must be sanitized, all the parameters and wildcards are decoded automatically.<br/>\nAn object with routing constraints should usually be passed as `constraints`, containing keys like the `host` for the request, the `version` for the route to be matched, or other custom constraint values. If the router is using the default versioning strategy, the version value should be conform to the [semver](https://semver.org/) specification. If you want to use the existing constraint strategies to derive the constraint values from an incoming request, use `lookup` instead of `find`. If no value is passed for `constraints`, the router won't match any constrained routes. If using constrained routes, passing `undefined` for the constraints leads to undefined behavior and should be avoided.\n\n```js\nrouter.find('GET', '/example', { host: 'fastify.io' })\n// => { handler: Function, params: Object, store: Object}\n// => null\n\nrouter.find('GET', '/example', { host: 'fastify.io', version: '1.x' })\n// => { handler: Function, params: Object, store: Object}\n// => null\n```\n\n<a name=\"pretty-print\"></a>\n#### prettyPrint([{ commonPrefix: false, includeMeta: true || [] }])\nPrints the representation of the internal radix tree, useful for debugging.\n\n```js\nfindMyWay.on('GET', '/test', () => {})\nfindMyWay.on('GET', '/test/hello', () => {})\nfindMyWay.on('GET', '/testing', () => {})\nfindMyWay.on('GET', '/testing/:param', () => {})\nfindMyWay.on('PUT', '/update', () => {})\n\nconsole.log(findMyWay.prettyPrint())\n// └── /\n//     ├── test (GET)\n//     │   ├── /hello (GET)\n//     │   └── ing (GET)\n//     │       └── /:param (GET)\n//     └── update (PUT)\n```\n\n`prettyPrint` accepts an optional setting to use the internal routes array\nto render the tree.\n\n```js\nconsole.log(findMyWay.prettyPrint({ commonPrefix: false }))\n// └── / (-)\n//     ├── test (GET)\n//     │   └── /hello (GET)\n//     ├── testing (GET)\n//     │   └── /:param (GET)\n//     └── update (PUT)\n```\n\nTo include a display of the `store` data passed to individual routes, the\noption `includeMeta` may be passed. If set to `true` all items will be\ndisplayed, this can also be set to an array specifying which keys (if\npresent) should be displayed. This information can be further sanitized\nby specifying a `buildPrettyMeta` function which consumes and returns\nan object.\n\n```js\nfindMyWay.on('GET', '/test', () => {}, { onRequest: () => {}, authIDs => [1,2,3] })\nfindMyWay.on('GET', '/test/hello', () => {}, { token: 'df123-4567' })\nfindMyWay.on('GET', '/testing', () => {})\nfindMyWay.on('GET', '/testing/:param', () => {})\nfindMyWay.on('PUT', '/update', () => {})\n\nconsole.log(findMyWay.prettyPrint({ commonPrefix: false, includeMeta: ['onRequest'] }))\n// └── /\n//     ├── test (GET)\n//     │   • (onRequest) \"anonymous()\"\n//     │   ├── /hello (GET)\n//     │   └── ing (GET)\n//     │       └── /:param (GET)\n//     └── update (PUT)\n\nconsole.log(findMyWay.prettyPrint({ commonPrefix: true, includeMeta: true }))\n// └── / (-)\n//     ├── test (GET)\n//     │   • (onRequest) \"anonymous()\"\n//     │   • (authIDs) [1,2,3]\n//     │   └── /hello (GET)\n//     │       • (token) \"df123-4567\"\n//     ├── testing (GET)\n//     │   └── /:param (GET)\n//     └── update (PUT)\n```\n\n<a name=\"reset\"></a>\n#### reset()\nEmpty router.\n```js\nrouter.reset()\n```\n\n<a name=\"routes\"></a>\n#### routes\nReturn the all routes **registered** at moment, useful for debugging.\n\n```js\nconst findMyWay = require('find-my-way')()\n\nfindMyWay.on('GET', '/test', () => {})\nfindMyWay.on('GET', '/test/hello', () => {})\n\nconsole.log(findMyWay.routes)\n// Will print\n// [\n//   {\n//     method: 'GET',\n//     path: '/test',\n//     opts: {},\n//     handler: [Function],\n//     store: undefined\n//   },\n//   {\n//     method: 'GET',\n//     path: '/test/hello',\n//     opts: {},\n//     handler: [Function],\n//     store: undefined\n//   }\n// ]\n```\n\n#### Caveats\n* It's not possible to register two routes which differs only for their parameters, because internally they would be seen as the same route. In a such case you'll get an early error during the route registration phase. An example is worth thousand words:\n```js\nconst findMyWay = FindMyWay({\n  defaultRoute: (req, res) => {}\n})\n\nfindMyWay.on('GET', '/user/:userId(^\\\\d+)', (req, res, params) => {})\n\nfindMyWay.on('GET', '/user/:username(^[a-z]+)', (req, res, params) => {})\n// Method 'GET' already declared for route ':'\n```\n\n<a name=\"shorthand-methods\"></a>\n#### Shorthand methods\nIf you want an even nicer api, you can also use the shorthand methods to declare your routes.\n\nFor each HTTP supported method, there's the shorthand method. For example:\n```js\nrouter.get(path, handler [, store])\nrouter.delete(path, handler [, store])\nrouter.head(path, handler [, store])\nrouter.patch(path, handler [, store])\nrouter.post(path, handler [, store])\nrouter.put(path, handler [, store])\nrouter.options(path, handler [, store])\n// ...\n```\n\nIf you need a route that supports *all* methods you can use the `all` api.\n```js\nrouter.all(path, handler [, store])\n```\n\n<a name=\"lookup\"></a>\n\n## Constraints\n\n`find-my-way` supports restricting handlers to only match certain requests for the same path. This can be used to support different versions of the same route that conform to a [semver](#semver) based versioning strategy, or restricting some routes to only be available on hosts. `find-my-way` has the semver based versioning strategy and a regex based hostname constraint strategy built in.\n\nTo constrain a route to only match sometimes, pass `constraints` to the route options when registering the route:\n\n```js\nfindMyWay.on('GET', '/', { constraints: { version: '1.0.2' } }, (req, res) => {\n  // will only run when the request's Accept-Version header asks for a version semver compatible with 1.0.2, like 1.x, or 1.0.x.\n})\n\nfindMyWay.on('GET', '/', { constraints: { host: 'example.com' } }, (req, res) => {\n  // will only run when the request's Host header is `example.com`\n})\n```\n\nConstraints can be combined, and route handlers will only match if __all__ of the constraints for the handler match the request. `find-my-way` does a boolean AND with each route constraint, not an OR.\n\n`find-my-way` will try to match the most constrained handlers first before handler with fewer or no constraints.\n\n<a name=\"custom-constraint-strategies\"></a>\n### Custom Constraint Strategies\n\nCustom constraining strategies can be added and are matched against incoming requests while trying to maintain `find-my-way`'s high performance. To register a new type of constraint, you must add a new constraint strategy that knows how to match values to handlers, and that knows how to get the constraint value from a request. Register strategies when constructing a router or use the addConstraintStrategy method.\n\nAdd a custom constrain strategy when constructing a router:\n\n```js\nconst customResponseTypeStrategy = {\n  // strategy name for referencing in the route handler `constraints` options\n  name: 'accept',\n  // storage factory for storing routes in the find-my-way route tree\n  storage: function () {\n    let handlers = {}\n    return {\n      get: (type) => { return handlers[type] || null },\n      set: (type, store) => { handlers[type] = store }\n    }\n  },\n  // function to get the value of the constraint from each incoming request\n  deriveConstraint: (req, ctx) => {\n    return req.headers['accept']\n  },\n  // optional flag marking if handlers without constraints can match requests that have a value for this constraint\n  mustMatchWhenDerived: true\n}\n\nconst router = FindMyWay({ constraints: { accept: customResponseTypeStrategy } });\n```\n\nAdd a custom constraint strategy using the addConstraintStrategy method:\n```js\nconst asyncCustomResponseTypeStrategy = {\n  // strategy name for referencing in the route handler `constraints` options\n  name: 'accept',\n  // storage factory for storing routes in the find-my-way route tree\n  storage: function () {\n    let handlers = {}\n    return {\n      get: (type) => { return handlers[type] || null },\n      set: (type, store) => { handlers[type] = store }\n    }\n  },\n  // function to get the value of the constraint from each incoming request\n  deriveConstraint: (req, ctx, done) => {\n    done(null, req.headers['accept'])\n  },\n  // optional flag marking if handlers without constraints can match requests that have a value for this constraint\n  mustMatchWhenDerived: true\n}\n\nconst router = FindMyWay({ constraints: { accept: asyncCustomResponseTypeStrategy } });\n```\n\nAdd an async custom constrain strategy when constructing a router:\n```js\nconst customResponseTypeStrategy = {\n  // strategy name for referencing in the route handler `constraints` options\n  name: 'accept',\n  // storage factory for storing routes in the find-my-way route tree\n  storage: function () {\n    let handlers = {}\n    return {\n      get: (type) => { return handlers[type] || null },\n      set: (type, store) => { handlers[type] = store }\n    }\n  },\n  // function to get the value of the constraint from each incoming request\n  deriveConstraint: (req, ctx) => {\n    return req.headers['accept']\n  },\n  // optional flag marking if handlers without constraints can match requests that have a value for this constraint\n  mustMatchWhenDerived: true\n}\n\nconst router = FindMyWay();\nrouter.addConstraintStrategy(customResponseTypeStrategy);\n```\n\nOnce a custom constraint strategy is registered, routes can be added that are constrained using it:\n\n\n```js\nfindMyWay.on('GET', '/', { constraints: { accept: 'application/fancy+json' } }, (req, res) => {\n  // will only run when the request's Accept header asks for 'application/fancy+json'\n})\n\nfindMyWay.on('GET', '/', { constraints: { accept: 'application/fancy+xml' } }, (req, res) => {\n  // will only run when the request's Accept header asks for 'application/fancy+xml'\n})\n```\n\nConstraint strategies should be careful to make the `deriveConstraint` function performant as it is run for every request matched by the router. See the `lib/strategies` directory for examples of the built in constraint strategies.\n\n\n<a name=\"custom-versioning\"></a>\nBy default, `find-my-way` uses a built in strategies for the version constraint that uses semantic version based matching logic, which is detailed [below](#semver). It is possible to define an alternative strategy:\n\n```js\nconst customVersioning = {\n  // replace the built in version strategy\n  name: 'version',\n  // provide a storage factory to store handlers in a simple way\n  storage: function () {\n    let versions = {}\n    return {\n      get: (version) => { return versions[version] || null },\n      set: (version, store) => { versions[version] = store }\n    }\n  },\n  deriveConstraint: (req, ctx) => {\n    return req.headers['accept']\n  },\n  mustMatchWhenDerived: true // if the request is asking for a version, don't match un-version-constrained handlers\n}\n\nconst router = FindMyWay({ constraints: { version: customVersioning } });\n```\n\nThe custom strategy object should contain next properties:\n* `storage` - a factory function to store lists of handlers for each possible constraint value. The storage object can use domain-specific storage mechanisms to store handlers in a way that makes sense for the constraint at hand. See `lib/strategies` for examples, like the `version` constraint strategy that matches using semantic versions, or the `host` strategy that allows both exact and regex host constraints.\n* `deriveConstraint` - the function to determine the value of this constraint given a request\n\nThe signature of the functions and objects must match the one from the example above.\n\n*Please, be aware, if you use your own constraining strategy - you use it on your own risk. This can lead both to the performance degradation and bugs which are not related to `find-my-way` itself!*\n\n\n<a name=\"acknowledgements\"></a>\n## Acknowledgements\n\nIt is inspired by the [echo](https://github.com/labstack/echo) router, some parts have been extracted from [trekjs](https://github.com/trekjs) router.\n\n<a name=\"sponsor\"></a>\n#### Past sponsor\n\n- [LetzDoIt](http://www.letzdoitapp.com/)\n\n<a name=\"license\"></a>\n## License\n**[find-my-way - MIT](https://github.com/delvedor/find-my-way/blob/master/LICENSE)**<br>\n**[trekjs/router - MIT](https://github.com/trekjs/router/blob/master/LICENSE)**\n\nCopyright © 2017-2019 Tomas Della Vedova\n",
    "licenseText": "MIT License\n\nCopyright (c) 2017-2019 Tomas Della Vedova\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/find-my-way/-/find-my-way-7.3.1.tgz#fd8a0b468a18c283e05be59f93a627f37e306cfa",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/find-my-way/-/find-my-way-7.3.1.tgz",
    "hash": "fd8a0b468a18c283e05be59f93a627f37e306cfa",
    "integrity": "sha512-kGvM08SOkqvheLcuQ8GW9t/H901Qb9rZEbcNWbXopzy4jDRoaJpJoObPSKf4MnQLZ20ZTp7rL5MpF6rf+pqmyg==",
    "registry": "npm",
    "packageName": "find-my-way",
    "cacheIntegrity": "sha512-kGvM08SOkqvheLcuQ8GW9t/H901Qb9rZEbcNWbXopzy4jDRoaJpJoObPSKf4MnQLZ20ZTp7rL5MpF6rf+pqmyg== sha1-/YoLRooYwoPgW+Wfk6Yn834wbPo="
  },
  "registry": "npm",
  "hash": "fd8a0b468a18c283e05be59f93a627f37e306cfa"
}