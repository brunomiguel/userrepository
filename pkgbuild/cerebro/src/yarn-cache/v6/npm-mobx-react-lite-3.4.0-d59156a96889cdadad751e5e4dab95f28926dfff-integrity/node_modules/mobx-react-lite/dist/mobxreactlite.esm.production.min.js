import{makeObservable as e,configure as r,getDependencyTree as n,Reaction as t,observable as o,runInAction as i}from"mobx";import u,{useState as a,forwardRef as c,memo as f}from"react";import{unstable_batchedUpdates as l}from"react-dom";if(!a)throw new Error("mobx-react-lite requires React with Hooks support");if(!e)throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");function s(e){e()}function d(e){e||(e=s),r({reactionScheduler:e})}var p=function(){return!0};function m(e){return n(e)}var v="undefined"==typeof FinalizationRegistry?void 0:FinalizationRegistry;function y(e){return{reaction:e,mounted:!1,changedBeforeMount:!1,cleanAt:Date.now()+b}}var b=1e4;function w(e){var r=new Map,n=1,t=new e((function(e){var n=r.get(e);n&&(n.reaction.dispose(),r.delete(e))}));return{addReactionToTrack:function(e,o,i){var u=n++;return t.register(i,u,e),e.current=y(o),e.current.finalizationRegistryCleanupToken=u,r.set(u,e.current),e.current},recordReactionAsCommitted:function(e){t.unregister(e),e.current&&e.current.finalizationRegistryCleanupToken&&r.delete(e.current.finalizationRegistryCleanupToken)},forceCleanupTimerToRunNowForTests:function(){},resetCleanupScheduleForTests:function(){}}}function h(e,r){(null==r||r>e.length)&&(r=e.length);for(var n=0,t=new Array(r);n<r;n++)t[n]=e[n];return t}function T(){var e,r=new Set;function n(){void 0===e&&(e=setTimeout(t,1e4))}function t(){e=void 0;var t=Date.now();r.forEach((function(e){var n=e.current;n&&t>=n.cleanAt&&(n.reaction.dispose(),e.current=null,r.delete(e))})),r.size>0&&n()}return{addReactionToTrack:function(e,t,o){return e.current=y(t),r.add(e),n(),e.current},recordReactionAsCommitted:function(e){r.delete(e)},forceCleanupTimerToRunNowForTests:function(){e&&(clearTimeout(e),t())},resetCleanupScheduleForTests:function(){if(r.size>0){for(var n,t=function(e,r){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(n)return(n=n.call(e)).next.bind(n);if(Array.isArray(e)||(n=function(e,r){if(e){if("string"==typeof e)return h(e,void 0);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?h(e,void 0):void 0}}(e))){n&&(e=n);var t=0;return function(){return t>=e.length?{done:!0}:{done:!1,value:e[t++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(r);!(n=t()).done;){var o=n.value,i=o.current;i&&(i.reaction.dispose(),o.current=null)}r.clear()}e&&(clearTimeout(e),e=void 0)}}}var g=v?w(v):T(),R=g.addReactionToTrack,S=g.recordReactionAsCommitted,A=g.resetCleanupScheduleForTests,C=!1;function x(e){C=e}function $(){return C}function O(e){return"observer"+e}var k=function(){};function E(){return new k}function F(e,r){if(void 0===r&&(r="observed"),$())return e();var n=u.useState(E)[0],o=u.useState()[1],i=function(){return o([])},a=u.useRef(null);if(!a.current)var c=new t(O(r),(function(){f.mounted?i():f.changedBeforeMount=!0})),f=R(a,c,n);var l,s,d=a.current.reaction;if(u.useDebugValue(d,m),u.useEffect((function(){return S(a),a.current?(a.current.mounted=!0,a.current.changedBeforeMount&&(a.current.changedBeforeMount=!1,i())):(a.current={reaction:new t(O(r),(function(){i()})),mounted:!0,changedBeforeMount:!1,cleanAt:Infinity},i()),function(){a.current.reaction.dispose(),a.current=null}}),[]),d.track((function(){try{l=e()}catch(e){s=e}})),s)throw s;return l}var j="function"==typeof Symbol&&Symbol.for,z=j?Symbol.for("react.forward_ref"):"function"==typeof c&&c((function(e){return null})).$$typeof,B=j?Symbol.for("react.memo"):"function"==typeof f&&f((function(e){return null})).$$typeof;function M(e,r){var n;if(B&&e.$$typeof===B)throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.");if($())return e;var t=null!=(n=null==r?void 0:r.forwardRef)&&n,o=e,i=e.displayName||e.name;if(z&&e.$$typeof===z&&(t=!0,"function"!=typeof(o=e.render)))throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function");var u,a,l=function(e,r){return F((function(){return o(e,r)}),i)};return""!==i&&(l.displayName=i),e.contextTypes&&(l.contextTypes=e.contextTypes),t&&(l=c(l)),l=f(l),u=e,a=l,Object.keys(u).forEach((function(e){N[e]||Object.defineProperty(a,e,Object.getOwnPropertyDescriptor(u,e))})),l}var N={$$typeof:!0,render:!0,compare:!0,type:!0,displayName:!0};function D(e){var r=e.children||e.render;return"function"!=typeof r?null:F(r)}function I(e,r){return a((function(){return o(e(),r,{autoBind:!0})}))[0]}function q(e){var r=a((function(){return o(e,{},{deep:!1})}))[0];return i((function(){Object.assign(r,e)})),r}function P(e,r){var n=r&&q(r);return a((function(){return o(e(n),void 0,{autoBind:!0})}))[0]}function H(e,r){return void 0===r&&(r="observed"),F(e,r)}function U(e){x(e)}D.displayName="Observer",d(l);export{D as Observer,A as clearTimers,x as enableStaticRendering,p as isObserverBatched,$ as isUsingStaticRendering,M as observer,d as observerBatching,q as useAsObservableSource,I as useLocalObservable,P as useLocalStore,H as useObserver,U as useStaticRendering};
//# sourceMappingURL=mobxreactlite.esm.production.min.js.map
