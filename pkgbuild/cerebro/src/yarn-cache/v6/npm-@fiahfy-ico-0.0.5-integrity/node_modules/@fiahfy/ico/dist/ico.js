"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ico = void 0;
const ico_file_header_1 = require("./ico-file-header");
const ico_info_header_1 = require("./ico-info-header");
const ico_image_1 = require("./ico-image");
class Ico {
    constructor(fileHeader = new ico_file_header_1.IcoFileHeader(), infoHeaders = [], images = []) {
        this._fileHeader = fileHeader;
        this._infoHeaders = infoHeaders;
        this._images = images;
    }
    /**
     * Create ICO from the icon buffer.
     * @param buffer The ICO icon buffer.
     */
    static from(buffer) {
        const fileHeader = ico_file_header_1.IcoFileHeader.from(buffer);
        let pos = fileHeader.data.length;
        const infoHeaders = [];
        for (let i = 0; i < fileHeader.count; i++) {
            const infoHeader = ico_info_header_1.IcoInfoHeader.from(buffer.slice(pos));
            infoHeaders.push(infoHeader);
            pos += infoHeader.data.length;
        }
        const images = [];
        for (let i = 0; i < infoHeaders.length; i++) {
            const { imageOffset: pos } = infoHeaders[i];
            const image = ico_image_1.IcoImage.from(buffer.slice(pos));
            images.push(image);
        }
        return new Ico(fileHeader, infoHeaders, images);
    }
    get fileHeader() {
        return this._fileHeader;
    }
    get infoHeaders() {
        return this._infoHeaders;
    }
    get images() {
        return this._images;
    }
    set images(images) {
        this._images = images;
        this._fileHeader = new ico_file_header_1.IcoFileHeader(this._fileHeader.reserved, this._fileHeader.type, this._images.length);
        const infoHeaders = this._images.map((image) => {
            return new ico_info_header_1.IcoInfoHeader(image.header.width < 256 ? image.header.width : 0, image.header.height / 2 < 256 ? image.header.height / 2 : 0, 0, 0, image.header.planes, image.header.bitCount, image.data.length);
        });
        let imageOffset = this._fileHeader.data.length +
            infoHeaders.reduce((carry, infoHeader) => carry + infoHeader.data.length, 0);
        this._infoHeaders = infoHeaders.map((infoHeader) => {
            const header = new ico_info_header_1.IcoInfoHeader(infoHeader.width, infoHeader.height, infoHeader.colorCount, infoHeader.reserved, infoHeader.planes, infoHeader.bitCount, infoHeader.bytesInRes, imageOffset);
            imageOffset += header.bytesInRes;
            return header;
        });
    }
    get data() {
        const buffers = [
            this._fileHeader.data,
            ...this._infoHeaders.map((infoHeader) => infoHeader.data),
            ...this._images.map((image) => image.data),
        ];
        return Buffer.concat(buffers);
    }
    /**
     * Adds ICO image at the end.
     * @param image The ICO Image to append.
     */
    append(image) {
        this.images = [...this.images, image];
    }
    /**
     * Inserts ICO image at the specified position.
     * @param image The ICO Image to insert.
     * @param index The position at which to insert the ICO Image.
     */
    insert(image, index) {
        this.images = [
            ...this.images.slice(0, index),
            image,
            ...this.images.slice(index + 1),
        ];
    }
    /**
     * Removes ICO image at the specified position.
     * @param index The position of the ICO Image to remove.
     */
    remove(index) {
        this.images = [
            ...this.images.slice(0, index),
            ...this.images.slice(index + 1),
        ];
    }
}
exports.Ico = Ico;
Ico.supportedIconSizes = [16, 24, 32, 48, 64, 128, 256];
