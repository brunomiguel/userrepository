var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { preprocess, compile } from "svelte/compiler";
import { dirname, basename, relative } from "path";
import { promisify } from "util";
import { readFile, statSync } from "fs";
const convertMessage = ({ message, start, end, filename, frame }) => ({
  text: message,
  location: start && end && {
    file: filename,
    line: start.line,
    column: start.column,
    length: start.line === end.line ? end.column - start.column : 0,
    lineText: frame
  }
});
const shouldCache = (build) => build.initialOptions.incremental || build.initialOptions.watch;
const b64enc = Buffer ? (b) => Buffer.from(b).toString("base64") : (b) => btoa(encodeURIComponent(b));
function toUrl(data) {
  return "data:application/json;charset=utf-8;base64," + b64enc(data);
}
const SVELTE_FILTER = /\.svelte$/;
const FAKE_CSS_FILTER = /\.esbuild-svelte-fake-css$/;
function sveltePlugin(options) {
  const svelteFilter = (options == null ? void 0 : options.include) ?? SVELTE_FILTER;
  return {
    name: "esbuild-svelte",
    setup(build) {
      if (!options) {
        options = {};
      }
      if (options.cache == void 0 && shouldCache(build)) {
        options.cache = true;
      }
      if (options.fromEntryFile == void 0) {
        options.fromEntryFile = false;
      }
      if (options.filterWarnings == void 0) {
        options.filterWarnings = () => true;
      }
      const cssCode = /* @__PURE__ */ new Map();
      const fileCache = /* @__PURE__ */ new Map();
      build.onResolve({ filter: svelteFilter }, ({ path, kind }) => {
        if (kind === "entry-point" && (options == null ? void 0 : options.fromEntryFile)) {
          return { path, namespace: "esbuild-svelte-direct-import" };
        }
      });
      build.onLoad({ filter: svelteFilter, namespace: "esbuild-svelte-direct-import" }, async (args) => {
        return {
          errors: [
            {
              text: "esbuild-svelte does not support creating entry files yet"
            }
          ]
        };
      });
      build.onLoad({ filter: svelteFilter }, async (args) => {
        var _a;
        let cachedFile = null;
        let previousWatchFiles = [];
        if ((options == null ? void 0 : options.cache) === true && fileCache.has(args.path)) {
          cachedFile = fileCache.get(args.path) || {
            dependencies: /* @__PURE__ */ new Map(),
            data: null
          };
          let cacheValid = true;
          try {
            cachedFile.dependencies.forEach((time, path) => {
              if (statSync(path).mtime > time) {
                cacheValid = false;
              }
            });
          } catch {
            cacheValid = false;
          }
          if (cacheValid) {
            return cachedFile.data;
          } else {
            fileCache.delete(args.path);
          }
        }
        let originalSource = await promisify(readFile)(args.path, "utf8");
        let filename = relative(process.cwd(), args.path);
        const dependencyModifcationTimes = /* @__PURE__ */ new Map();
        dependencyModifcationTimes.set(args.path, statSync(args.path).mtime);
        let compilerOptions = __spreadValues({
          css: false
        }, options == null ? void 0 : options.compilerOptions);
        try {
          let source = originalSource;
          if (options == null ? void 0 : options.preprocess) {
            let preprocessResult = null;
            try {
              preprocessResult = await preprocess(originalSource, options.preprocess, {
                filename
              });
            } catch (e) {
              if (build.initialOptions.watch && cachedFile) {
                previousWatchFiles = Array.from(cachedFile.dependencies.keys());
              }
              throw e;
            }
            if (preprocessResult.map) {
              let fixedMap = preprocessResult.map;
              for (let index = 0; index < (fixedMap == null ? void 0 : fixedMap.sources.length); index++) {
                if (fixedMap.sources[index] == filename) {
                  fixedMap.sources[index] = basename(filename);
                }
              }
              compilerOptions.sourcemap = fixedMap;
            }
            source = preprocessResult.code;
            if ((options == null ? void 0 : options.cache) === true) {
              (_a = preprocessResult.dependencies) == null ? void 0 : _a.forEach((entry) => {
                dependencyModifcationTimes.set(entry, statSync(entry).mtime);
              });
            }
          }
          let { js, css, warnings } = compile(source, __spreadProps(__spreadValues({}, compilerOptions), { filename }));
          if (compilerOptions.sourcemap) {
            if (js.map.sourcesContent == void 0) {
              js.map.sourcesContent = [];
            }
            for (let index = 0; index < js.map.sources.length; index++) {
              const element = js.map.sources[index];
              if (element == basename(filename)) {
                js.map.sourcesContent[index] = originalSource;
                index = Infinity;
              }
            }
          }
          let contents = js.code + `
//# sourceMappingURL=` + toUrl(js.map.toString());
          if (!compilerOptions.css && css.code) {
            let cssPath = args.path.replace(".svelte", ".esbuild-svelte-fake-css").replace(/\\/g, "/");
            cssCode.set(cssPath, css.code + `/*# sourceMappingURL=${toUrl(css.map.toString())} */`);
            contents = contents + `
import "${cssPath}";`;
          }
          if (options == null ? void 0 : options.filterWarnings) {
            warnings = warnings.filter(options.filterWarnings);
          }
          const result = {
            contents,
            warnings: warnings.map(convertMessage)
          };
          if ((options == null ? void 0 : options.cache) === true) {
            fileCache.set(args.path, {
              data: result,
              dependencies: dependencyModifcationTimes
            });
          }
          if (build.initialOptions.watch) {
            result.watchFiles = Array.from(dependencyModifcationTimes.keys());
          }
          return result;
        } catch (e) {
          return { errors: [convertMessage(e)], watchFiles: previousWatchFiles };
        }
      });
      build.onResolve({ filter: FAKE_CSS_FILTER }, ({ path }) => {
        return { path, namespace: "fakecss" };
      });
      build.onLoad({ filter: FAKE_CSS_FILTER, namespace: "fakecss" }, ({ path }) => {
        const css = cssCode.get(path);
        return css ? { contents: css, loader: "css", resolveDir: dirname(path) } : null;
      });
      if (shouldCache(build) && (options == null ? void 0 : options.cache) == "overzealous" && typeof build.onEnd === "function") {
        build.initialOptions.metafile = true;
        build.onEnd((result) => {
          var _a, _b, _c;
          for (let fileName in (_a = result.metafile) == null ? void 0 : _a.inputs) {
            if (SVELTE_FILTER.test(fileName)) {
              let file = (_b = result.metafile) == null ? void 0 : _b.inputs[fileName];
              (_c = file == null ? void 0 : file.imports) == null ? void 0 : _c.forEach((i) => {
                if (SVELTE_FILTER.test(i.path)) {
                  let fileCacheEntry = fileCache.get(fileName);
                  if (fileCacheEntry != void 0) {
                    fileCacheEntry == null ? void 0 : fileCacheEntry.dependencies.set(i.path, statSync(i.path).mtime);
                    fileCache.set(fileName, fileCacheEntry);
                  }
                }
              });
            }
          }
        });
      }
    }
  };
}
export {
  sveltePlugin as default
};
