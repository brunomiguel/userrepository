{"version":3,"file":"graphology.umd.min.js","sources":["../src/utils.js","../node_modules/events/events.js","../node_modules/obliterator/iterator.js","../node_modules/obliterator/take.js","../src/errors.js","../src/data.js","../src/indices.js","../src/attributes.js","../node_modules/obliterator/chain.js","../src/iteration/edges.js","../src/iteration/neighbors.js","../src/iteration/adjacency.js","../src/serialization.js","../src/graph.js","../src/classes.js"],"sourcesContent":["/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i])\n      continue;\n\n    for (const k in arguments[i])\n      target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function')\n  assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData)\n    return edge;\n\n  if (type === 'mixed') {\n    edge = (\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target])\n    );\n  }\n  else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  }\n  else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a Graph implementation instance.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function'\n  );\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    value.constructor === Object\n  );\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o)\n    return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  }\n  else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints))\n    return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes))\n    return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalId() {\n  let i = 0;\n\n  return () => {\n    return i++;\n  };\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * Obliterator Iterator Class\n * ===========================\n *\n * Simple class representing the library's iterators.\n */\n\n/**\n * Iterator class.\n *\n * @constructor\n * @param {function} next - Next function.\n */\nfunction Iterator(next) {\n\n  // Hiding the given function\n  Object.defineProperty(this, '_next', {\n    writable: false,\n    enumerable: false,\n    value: next\n  });\n\n  // Is the iterator complete?\n  this.done = false;\n}\n\n/**\n * Next function.\n *\n * @return {object}\n */\n// NOTE: maybe this should dropped for performance?\nIterator.prototype.next = function() {\n  if (this.done)\n    return {done: true};\n\n  var step = this._next();\n\n  if (step.done)\n    this.done = true;\n\n  return step;\n};\n\n/**\n * If symbols are supported, we add `next` to `Symbol.iterator`.\n */\nif (typeof Symbol !== 'undefined')\n  Iterator.prototype[Symbol.iterator] = function() {\n    return this;\n  };\n\n/**\n * Returning an iterator of the given values.\n *\n * @param  {any...} values - Values.\n * @return {Iterator}\n */\nIterator.of = function() {\n  var args = arguments,\n      l = args.length,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    return {done: false, value: args[i++]};\n  });\n};\n\n/**\n * Returning an empty iterator.\n *\n * @return {Iterator}\n */\nIterator.empty = function() {\n  var iterator = new Iterator(null);\n  iterator.done = true;\n\n  return iterator;\n};\n\n/**\n * Returning whether the given value is an iterator.\n *\n * @param  {any} value - Value.\n * @return {boolean}\n */\nIterator.is = function(value) {\n  if (value instanceof Iterator)\n    return true;\n\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.next === 'function'\n  );\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Iterator;\n","/* eslint no-constant-condition: 0 */\n/**\n * Obliterator Take Function\n * ==========================\n *\n * Function taking n or every value of the given iterator and returns them\n * into an array.\n */\n\n/**\n * Take.\n *\n * @param  {Iterator} iterator - Target iterator.\n * @param  {number}   [n]      - Optional number of items to take.\n * @return {array}\n */\nmodule.exports = function take(iterator, n) {\n  var l = arguments.length > 1 ? n : Infinity,\n      array = l !== Infinity ? new Array(l) : [],\n      step,\n      i = 0;\n\n  while (true) {\n\n    if (i === l)\n      return array;\n\n    step = iterator.next();\n\n    if (step.done) {\n\n      if (i !== n)\n        return array.slice(0, i);\n\n      return array;\n    }\n\n    array[i++] = step.value;\n  }\n};\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message, data) {\n    super();\n    this.name = 'GraphError';\n    this.message = message || '';\n    this.data = data || {};\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, InvalidArgumentsGraphError.prototype.constructor);\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.directedSelfLoops = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n}\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n}\n\nDirectedNodeData.prototype.upgradeToMixed = function() {\n\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n}\n\nUndirectedNodeData.prototype.upgradeToMixed = function() {\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {boolean} generatedKey - Was its key generated?\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, generatedKey, source, target, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n\n  // Was its key generated?\n  this.generatedKey = generatedKey;\n}\n","/**\n * Graphology Indexes Functions\n * =============================\n *\n * Bunch of functions used to compute or clear indexes.\n */\n\n/**\n * Function updating the 'structure' index with the given edge's data.\n * Note that in the case of the multi graph, related edges are stored in a\n * set that is the same for A -> B & B <- A.\n *\n * @param {Graph}    graph      - Target Graph instance.\n * @param {EdgeData} edgeData   - Added edge's data.\n * @param {NodeData} sourceData - Source node's data.\n * @param {NodeData} targetData - Target node's data.\n */\nexport function updateStructureIndex(\n  graph,\n  undirected,\n  edgeData,\n  source,\n  target,\n  sourceData,\n  targetData\n) {\n  const multi = graph.multi;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (undirected)\n    outKey = inKey = 'undirected';\n\n  let adj, container;\n\n  if (multi) {\n\n    // Handling source\n    adj = sourceData[outKey];\n    container = adj[target];\n\n    if (typeof container === 'undefined') {\n      container = new Set();\n      adj[target] = container;\n    }\n\n    container.add(edgeData);\n\n    // If selfLoop, we break here\n    if (source === target && undirected)\n      return;\n\n    // Handling target (we won't add the edge because it was already taken\n    // care of with source above)\n    adj = targetData[inKey];\n    if (typeof adj[source] === 'undefined')\n      adj[source] = container;\n  }\n  else {\n\n    // Handling source\n    sourceData[outKey][target] = edgeData;\n\n    // If selfLoop, we break here\n    if (source === target && undirected)\n      return;\n\n    // Handling target\n    targetData[inKey][source] = edgeData;\n  }\n}\n\n/**\n * Function clearing the 'structure' index data related to the given edge.\n *\n * @param {Graph}    graph    - Target Graph instance.\n * @param {EdgeData} edgeData - Dropped edge's data.\n */\nexport function clearEdgeFromStructureIndex(graph, undirected, edgeData) {\n  const multi = graph.multi;\n\n  const {source: sourceData, target: targetData} = edgeData;\n\n  const source = sourceData.key,\n        target = targetData.key;\n\n  // NOTE: since the edge set is the same for source & target, we can only\n  // affect source\n  const outKey = undirected ? 'undirected' : 'out',\n        sourceIndex = sourceData[outKey];\n\n  const inKey = undirected ? 'undirected' : 'in';\n\n  if (target in sourceIndex) {\n\n    if (multi) {\n      const set = sourceIndex[target];\n\n      if (set.size === 1) {\n        delete sourceIndex[target];\n        delete targetData[inKey][source];\n      }\n      else {\n        set.delete(edgeData);\n      }\n    }\n    else\n      delete sourceIndex[target];\n  }\n\n  if (multi)\n    return;\n\n  const targetIndex = targetData[inKey];\n\n  delete targetIndex[source];\n}\n\n/**\n * Function clearing the whole 'structure' index.\n *\n * @param {Graph} graph - Target Graph instance.\n */\nexport function clearStructureIndex(graph) {\n  graph._nodes.forEach(data => {\n\n    // Clearing now useless properties\n    if (typeof data.in !== 'undefined') {\n      data.in = {};\n      data.out = {};\n    }\n\n    if (typeof data.undirected !== 'undefined') {\n      data.undirected = {};\n    }\n  });\n}\n\n/**\n * Function used to upgrade a simple `structure` index to a multi on.\n *\n * @param {Graph}  graph - Target Graph instance.\n */\nexport function upgradeStructureIndexToMulti(graph) {\n  graph._nodes.forEach((data, node) => {\n\n    // Directed\n    if (data.out) {\n\n      for (const neighbor in data.out) {\n        const edges = new Set();\n        edges.add(data.out[neighbor]);\n        data.out[neighbor] = edges;\n        graph._nodes.get(neighbor).in[node] = edges;\n      }\n    }\n\n    // Undirected\n    if (data.undirected) {\n      for (const neighbor in data.undirected) {\n        if (neighbor > node)\n          continue;\n\n        const edges = new Set();\n        edges.add(data.undirected[neighbor]);\n        data.undirected[neighbor] = edges;\n        graph._nodes.get(neighbor).undirected[node] = edges;\n      }\n    }\n  });\n}\n","/**\n * Graphology Attributes methods\n * ==============================\n *\n * Attributes-related methods being exactly the same for nodes & edges,\n * we abstract them here for factorization reasons.\n */\nimport {\n  assign,\n  isPlainObject,\n  getMatchingEdge\n} from './utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeGetter(Class, method, type) {\n\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachAttributesGetter(Class, method, type) {\n\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 1) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachAttributeChecker(Class, method, type) {\n\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeSetter(Class, method, type) {\n\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 3) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeUpdater(Class, method, type) {\n\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 3) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.${method}: updater should be a function.`);\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeRemover(Class, method, type) {\n\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributesReplacer(Class, method, type) {\n\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributesMerger(Class, method, type) {\n\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachAttributesMerger\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport function attachAttributesMethods(Graph) {\n  ATTRIBUTES_METHODS.forEach(function({name, attacher}) {\n\n    // For edges\n    attacher(\n      Graph,\n      name('Edge'),\n      'mixed'\n    );\n\n    // For directed edges\n    attacher(\n      Graph,\n      name('DirectedEdge'),\n      'directed'\n    );\n\n    // For undirected edges\n    attacher(\n      Graph,\n      name('UndirectedEdge'),\n      'undirected'\n    );\n  });\n}\n","/**\n * Obliterator Chain Function\n * ===========================\n *\n * Variadic function combining the given iterators.\n */\nvar Iterator = require('./iterator.js');\n\n/**\n * Chain.\n *\n * @param  {...Iterator} iterators - Target iterators.\n * @return {Iterator}\n */\nmodule.exports = function chain() {\n  var iterators = arguments,\n      current,\n      i = -1;\n\n  return new Iterator(function iterate() {\n    if (!current) {\n      i++;\n\n      if (i >= iterators.length)\n        return {done: true};\n\n      current = iterators[i];\n    }\n\n    var step = current.next();\n\n    if (step.done) {\n      current = null;\n      return iterate();\n    }\n\n    return step;\n  });\n};\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError\n} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function collecting edges from the given object.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @return {array}         - The found edges.\n */\nfunction collectSimple(edges, object) {\n  for (const k in object)\n    edges.push(object[k].key);\n}\n\nfunction collectMulti(edges, object) {\n  for (const k in object)\n    object[k].forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over edges from the given object using a callback.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    const edgeData = object[k];\n\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    );\n  }\n}\n\nfunction forEachMulti(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    object[k].forEach(edgeData => callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    ));\n  }\n}\n\n/**\n * Function iterating over edges from the given object using a callback until\n * the return value of the callback is truthy.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimpleUntil(object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\nfunction forEachMultiUntil(object, callback, avoid) {\n  let iterator, step, edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    iterator = object[k].values();\n\n    while ((step = iterator.next(), step.done !== true)) {\n      edgeData = step.value;\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected,\n        edgeData.generatedKey\n      );\n\n      if (shouldBreak)\n        return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let inner = null,\n      i = 0;\n\n  return new Iterator(function next() {\n    let edgeData;\n\n    if (inner) {\n      const step = inner.next();\n\n      if (step.done) {\n        inner = null;\n        i++;\n        return next();\n      }\n\n      edgeData = step.value;\n    }\n    else {\n      if (i >= l)\n        return {done: true};\n\n      const k = keys[i];\n\n      if (k === avoid) {\n        i++;\n        return next();\n      }\n\n      edgeData = object[k];\n\n      if (edgeData instanceof Set) {\n        inner = edgeData.values();\n        return next();\n      }\n\n      i++;\n    }\n\n    return {\n      done: false,\n      value: [\n        edgeData.key,\n        edgeData.attributes,\n        edgeData.source.key,\n        edgeData.target.key,\n        edgeData.source.attributes,\n        edgeData.target.attributes\n      ]\n    };\n  });\n}\n\n/**\n * Function collecting edges from the given object at given key.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @param  {mixed}  k      - Neighbor key.\n * @return {array}         - The found edges.\n */\nfunction collectForKeySimple(edges, object, k) {\n  const edgeData = object[k];\n\n  if (!edgeData)\n    return;\n\n  edges.push(edgeData.key);\n}\n\nfunction collectForKeyMulti(edges, object, k) {\n  const edgesData = object[k];\n\n  if (!edgesData)\n    return;\n\n  edgesData.forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData)\n    return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  callback(\n    edgeData.key,\n    edgeData.attributes,\n    sourceData.key,\n    targetData.key,\n    sourceData.attributes,\n    targetData.attributes,\n    edgeData.undirected,\n    edgeData.generatedKey\n  );\n}\n\nfunction forEachForKeyMulti(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData)\n    return;\n\n  edgesData.forEach(edgeData => callback(\n    edgeData.key,\n    edgeData.attributes,\n    edgeData.source.key,\n    edgeData.target.key,\n    edgeData.source.attributes,\n    edgeData.target.attributes,\n    edgeData.undirected,\n    edgeData.generatedKey\n  ));\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback until it returns a truthy value to stop iteration.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimpleUntil(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData)\n    return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  return callback(\n    edgeData.key,\n    edgeData.attributes,\n    sourceData.key,\n    targetData.key,\n    sourceData.attributes,\n    targetData.attributes,\n    edgeData.undirected,\n    edgeData.generatedKey\n  );\n}\n\nfunction forEachForKeyMultiUntil(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData)\n    return;\n\n  let shouldBreak = false;\n\n  const iterator = edgesData.values();\n  let step, edgeData;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    edgeData = step.value;\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  const v = object[k];\n\n  if (v instanceof Set) {\n    const iterator = v.values();\n\n    return new Iterator(function() {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const edgeData = step.value;\n\n      return {\n        done: false,\n        value: [\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.source.key,\n          edgeData.target.key,\n          edgeData.source.attributes,\n          edgeData.target.attributes\n        ]\n      };\n    });\n  }\n\n  return Iterator.of([\n    v.key,\n    v.attributes,\n    v.source.key,\n    v.target.key,\n    v.source.attributes,\n    v.target.attributes\n  ]);\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0)\n    return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    if (typeof Array.from === 'function')\n      return Array.from(graph._edges.keys());\n\n    return take(graph._edges.keys(), graph._edges.size);\n  }\n\n  const size = type === 'undirected' ?\n    graph.undirectedSize :\n    graph.directedSize;\n\n  const list = new Array(size),\n        mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask)\n      list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(graph, type, callback) {\n  if (graph.size === 0)\n    return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  const iterator = graph._edges.values();\n\n  while ((step = iterator.next(), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask)\n      continue;\n\n    const {key, attributes, source, target} = data;\n\n    callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected,\n      data.generatedKey\n    );\n  }\n}\n\n/**\n * Function iterating over a graph's edges using a callback until it returns\n * a truthy value to stop iteration.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdgeUntil(graph, type, callback) {\n  if (graph.size === 0)\n    return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while ((step = iterator.next(), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask)\n      continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected,\n      data.generatedKey\n    );\n\n    if (shouldBreak)\n      break;\n  }\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0)\n    return Iterator.empty();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    let step, data;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      data = step.value;\n\n      if (shouldFilter && data.undirected !== mask)\n        continue;\n\n      break;\n    }\n\n    const value = [\n      data.key,\n      data.attributes,\n      data.source.key,\n      data.target.key,\n      data.source.attributes,\n      data.target.attributes\n    ];\n\n    return {value, done: false};\n  });\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = [];\n\n  const fn = multi ? collectMulti : collectSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out')\n      fn(edges, nodeData.in);\n    if (direction !== 'in')\n      fn(edges, nodeData.out);\n\n    // Handling self loop edge case\n    if (!direction && nodeData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(nodeData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    fn(edges, nodeData.undirected);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out')\n      fn(nodeData.in, callback);\n    if (direction !== 'in')\n      fn(nodeData.out, callback, !direction ? nodeData.key : null);\n  }\n\n  if (type !== 'directed') {\n    fn(nodeData.undirected, callback);\n  }\n}\n\n/**\n * Function iterating over a node's edges using a callback until it returns\n * a truthy value to stop iteration.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNodeUntil(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMultiUntil : forEachSimpleUntil;\n\n  let shouldBreak = false;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      shouldBreak = fn(nodeData.in, callback);\n\n      if (shouldBreak)\n        return;\n    }\n    if (direction !== 'in') {\n      shouldBreak = fn(nodeData.out, callback, !direction ? nodeData.key : null);\n\n      if (shouldBreak)\n        return;\n    }\n  }\n\n  if (type !== 'directed') {\n    shouldBreak = fn(nodeData.undirected, callback);\n\n    if (shouldBreak)\n      return;\n  }\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.out, !direction ? nodeData.key : null));\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const fn = multi ? collectForKeyMulti : collectForKeySimple;\n\n  const edges = [];\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(edges, sourceData.in, target);\n\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n      fn(edges, sourceData.out, target);\n\n    // Handling self loop edge case\n    if (!direction && sourceData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(sourceData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(edges, sourceData.undirected, target);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over edges for the given path using a callback.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(type, multi, direction, sourceData, target, callback) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(sourceData.in, target, callback);\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n        fn(sourceData.out, target, callback);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(sourceData.undirected, target, callback);\n  }\n}\n\n/**\n * Function iterating over edges for the given path using a callback until\n * it returns a truthy value to stop iteration.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPathUntil(type, multi, direction, sourceData, target, callback) {\n  const fn = multi ? forEachForKeyMultiUntil : forEachForKeySimpleUntil;\n\n  let shouldBreak = false;\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      shouldBreak = fn(sourceData.in, target, callback);\n\n      if (shouldBreak)\n        return;\n    }\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in') {\n        shouldBreak = fn(sourceData.out, target, callback, !direction ? sourceData.key : null);\n\n        if (shouldBreak)\n          return;\n      }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      shouldBreak = fn(sourceData.undirected, target, callback);\n\n      if (shouldBreak)\n        return;\n    }\n  }\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.undirected, target));\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(source, target) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length)\n      return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(type, this.multi, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function(source, target, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${forEachName}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(type, this.multi, direction, sourceData, target, callback);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdgeUntil(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachUntilName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1) + 'Until';\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback and breaking as soon as the callback return a truthy value.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachUntilName] = function(source, target, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdgeUntil(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${forEachUntilName}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNodeUntil(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${forEachUntilName}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${forEachUntilName}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPathUntil(type, this.multi, direction, sourceData, target, callback);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${forEachUntilName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nexport function attachEdgeIteratorCreator(Class, description) {\n  const {\n    name: originalName,\n    type,\n    direction\n  } = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(source, target) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length)\n      return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachForEachEdgeUntil(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError\n} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function merging neighbors into the given set iterating over the given object.\n *\n * @param {BasicSet} neighbors - Neighbors set.\n * @param {object}   object    - Target object.\n */\nfunction merge(neighbors, object) {\n  if (typeof object === 'undefined')\n    return;\n\n  for (const neighbor in object)\n    neighbors.add(neighbor);\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return Object.keys(nodeData[direction]);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const neighbors = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      merge(neighbors, nodeData.in);\n    }\n    if (direction !== 'in') {\n      merge(neighbors, nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    merge(neighbors, nodeData.undirected);\n  }\n\n  return take(neighbors.values(), neighbors.size);\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n  }\n}\n\nfunction forEachInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      continue;\n\n    visited.add(neighborData.key);\n\n    callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n  }\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback until it returns a truthy value to stop iteration.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObjectUntil(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    const shouldBreak = callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\nfunction forEachInObjectOnceUntil(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      continue;\n\n    visited.add(neighborData.key);\n\n    const shouldBreak = callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\nfunction forEachNeighborForNode(type, direction, nodeData, callback) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      forEachInObjectOnce(visited, nodeData, nodeData.in, callback);\n    }\n    if (direction !== 'in') {\n      forEachInObjectOnce(visited, nodeData, nodeData.out, callback);\n    }\n  }\n\n  if (type !== 'directed') {\n    forEachInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n  }\n}\n\nfunction forEachNeighborForNodeUntil(type, direction, nodeData, callback) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObjectUntil(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObjectUntil(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  let shouldBreak = false;\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.in, callback);\n\n      if (shouldBreak)\n        return;\n    }\n    if (direction !== 'in') {\n      shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.out, callback);\n\n      if (shouldBreak)\n        return;\n    }\n  }\n\n  if (type !== 'directed') {\n    shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.undirected, callback);\n\n    if (shouldBreak)\n      return;\n  }\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createObjectIterator(nodeData, object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    if (i >= l)\n      return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      return next();\n\n    visited.add(neighborData.key);\n\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createObjectIterator(nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createObjectIterator(nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.in));\n    }\n    if (direction !== 'in') {\n      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.out));\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function returning whether the given node has target neighbor.\n *\n * @param  {Graph}        graph     - Target graph.\n * @param  {string}       type      - Type of neighbor.\n * @param  {string}       direction - Direction.\n * @param  {any}          node      - Target node.\n * @param  {any}          neighbor  - Target neighbor.\n * @return {boolean}\n */\nfunction nodeHasNeighbor(graph, type, direction, node, neighbor) {\n\n  const nodeData = graph._nodes.get(node);\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined') {\n      for (const k in nodeData.in)\n        if (k === neighbor)\n          return true;\n    }\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined') {\n      for (const k in nodeData.out)\n        if (k === neighbor)\n          return true;\n    }\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    for (const k in nodeData.undirected)\n        if (k === neighbor)\n          return true;\n  }\n\n  return false;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  /**\n   * Function returning an array or the count of certain neighbors.\n   *\n   * Arity 1: Return all of a node's relevant neighbors.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return whether the two nodes are indeed neighbors.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The neighbors or the number of neighbors.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(node) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (arguments.length === 2) {\n      const node1 = '' + arguments[0],\n            node2 = '' + arguments[1];\n\n      if (!this._nodes.has(node1))\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node1}\" node in the graph.`);\n\n      if (!this._nodes.has(node2))\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node2}\" node in the graph.`);\n\n      // Here, we want to assess whether the two given nodes are neighbors\n      return nodeHasNeighbor(\n        this,\n        type,\n        direction,\n        node1,\n        node2\n      );\n    }\n    else if (arguments.length === 1) {\n      node = '' + node;\n\n      const nodeData = this._nodes.get(node);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node}\" node in the graph.`);\n\n      // Here, we want to iterate over a node's relevant neighbors\n      const neighbors = createNeighborArrayForNode(\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n\n      return neighbors;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid number of arguments (expecting 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function(node, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${forEachName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighborForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighborUntil(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachUntilName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1) + 'Until';\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachUntilName] = function(node, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${forEachUntilName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighborForNodeUntil(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function(node) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachForEachNeighborUntil(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Adjacency Iteration\n * ================================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\nimport Iterator from 'obliterator/iterator';\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable - Can we break?\n * @param {Graph}    graph     - Target Graph instance.\n * @param {callback} function  - Iteration callback.\n */\nexport function forEachAdjacencySimple(breakable, graph, callback) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected,\n          edgeData.generatedKey\n        );\n\n        if (breakable && shouldBreak)\n          return;\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        if (targetData.key !== neighbor)\n          targetData = edgeData.source;\n\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected,\n          edgeData.generatedKey\n        );\n\n        if (breakable && shouldBreak)\n          return;\n      }\n    }\n  }\n}\n\n/**\n * Function iterating over a multi graph's adjacency using a callback.\n *\n * @param {boolean}  breakable - Can we break?\n * @param {Graph}    graph    - Target Graph instance.\n * @param {callback} function - Iteration callback.\n */\nexport function forEachAdjacencyMulti(breakable, graph, callback) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, container, containerStep, adj, edgeData, targetData, shouldBreak;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        container = adj[neighbor].values();\n\n        while ((containerStep = container.next(), containerStep.done !== true)) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected,\n            edgeData.generatedKey\n          );\n\n          if (breakable && shouldBreak)\n            return;\n        }\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        container = adj[neighbor].values();\n\n        while ((containerStep = container.next(), containerStep.done !== true)) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor)\n            targetData = edgeData.source;\n\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected,\n            edgeData.generatedKey\n          );\n\n          if (breakable && shouldBreak)\n            return;\n        }\n      }\n    }\n  }\n}\n\nexport function createAdjacencyIteratorSimple(graph) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let state = 'outer',\n      sourceData,\n      neighbors,\n      adj,\n      offset;\n\n  return new Iterator(function next() {\n    let step;\n\n    if (state === 'outer') {\n      step = iterator.next();\n\n      if (step.done === true)\n        return step;\n\n      sourceData = step.value;\n\n      state = 'directed';\n      return next();\n    }\n\n    if (state === 'directed') {\n      if (type === 'undirected') {\n        state = 'undirected';\n        return next();\n      }\n\n      adj = sourceData.out;\n      neighbors = Object.keys(sourceData.out);\n      offset = 0;\n      state = 'inner-directed';\n\n      return next();\n    }\n\n    if (state === 'undirected') {\n      if (type === 'directed') {\n        state = 'outer';\n        return next();\n      }\n\n      adj = sourceData.undirected;\n      neighbors = Object.keys(sourceData.undirected);\n      offset = 0;\n      state = 'inner-undirected';\n    }\n\n    // Inner\n    if (offset >= neighbors.length) {\n      if (state === 'inner-undirected')\n        state = 'outer';\n      else\n        state = 'undirected';\n\n      return next();\n    }\n\n    const neighbor = neighbors[offset++];\n    const edgeData = adj[neighbor];\n    let targetData = edgeData.target;\n\n    if (state === 'inner-undirected' && targetData.key === sourceData.key)\n      targetData = edgeData.source;\n\n    return {\n      done: false,\n      value: [\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.key,\n        edgeData.attributes\n      ]\n    };\n  });\n}\n\nexport function createAdjacencyIteratorMulti(graph) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let state = 'outer',\n      sourceData,\n      neighbors,\n      container = null,\n      adj,\n      offset;\n\n  return new Iterator(function next() {\n    let step;\n\n    if (state === 'outer') {\n      step = iterator.next();\n\n      if (step.done === true)\n        return step;\n\n      sourceData = step.value;\n\n      state = 'directed';\n      return next();\n    }\n\n    if (state === 'directed') {\n      if (type === 'undirected') {\n        state = 'undirected';\n        return next();\n      }\n\n      adj = sourceData.out;\n      neighbors = Object.keys(sourceData.out);\n      offset = 0;\n      state = 'inner-directed';\n\n      return next();\n    }\n\n    if (state === 'undirected') {\n      if (type === 'directed') {\n        state = 'outer';\n        return next();\n      }\n\n      adj = sourceData.undirected;\n      neighbors = Object.keys(sourceData.undirected);\n      offset = 0;\n      state = 'inner-undirected';\n    }\n\n    // Inner\n    if (!container && offset >= neighbors.length) {\n      if (state === 'inner-undirected')\n        state = 'outer';\n      else\n        state = 'undirected';\n\n      return next();\n    }\n\n    if (!container) {\n      const neighbor = neighbors[offset++];\n      container = adj[neighbor].values();\n      return next();\n    }\n\n    step = container.next();\n\n    if (step.done) {\n      container = null;\n      return next();\n    }\n\n    const edgeData = step.value;\n    let targetData = edgeData.target;\n\n    if (state === 'inner-undirected' && targetData.key === sourceData.key)\n      targetData = edgeData.source;\n\n    return {\n      done: false,\n      value: [\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.key,\n        edgeData.attributes\n      ]\n    };\n  });\n}\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used to validate import-export formats & to ouput\n * them from internal graph data.\n *\n * Serialized Node:\n * {key, ?attributes}\n *\n * Serialized Edge:\n * {key?, source, target, attributes?, undirected?}\n *\n * Serialized Graph:\n * {nodes[], edges?[]}\n */\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(key, data) {\n  const serialized = {\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  // We export the key unless if it was provided by the user\n  if (!data.generatedKey)\n    serialized.key = key;\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (data.undirected)\n    serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    return 'not-object';\n\n  if (!('key' in value))\n    return 'no-key';\n\n  if ('attributes' in value &&\n      (!isPlainObject(value.attributes) || value.attributes === null))\n    return 'invalid-attributes';\n\n  return null;\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    return 'not-object';\n\n  if (!('source' in value))\n    return 'no-source';\n\n  if (!('target' in value))\n    return 'no-target';\n\n  if ('attributes' in value &&\n      (!isPlainObject(value.attributes) || value.attributes === null))\n    return 'invalid-attributes';\n\n  if ('undirected' in value &&\n      (typeof value.undirected !== 'boolean'))\n    return 'invalid-undirected';\n\n  return null;\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport {\n  updateStructureIndex,\n  clearEdgeFromStructureIndex,\n  clearStructureIndex,\n  upgradeStructureIndexToMulti\n} from './indices';\n\nimport {attachAttributesMethods} from './attributes';\nimport {attachEdgeIterationMethods} from './iteration/edges';\nimport {attachNeighborIterationMethods} from './iteration/neighbors';\nimport {\n  forEachAdjacencySimple,\n  forEachAdjacencyMulti,\n  createAdjacencyIteratorSimple,\n  createAdjacencyIteratorMulti\n} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isGraph,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalId,\n  validateHints\n} from './utils';\n\n/**\n * Enums.\n */\nconst TYPES = new Set([\n  'directed',\n  'undirected',\n  'mixed'\n]);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`,\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  edgeKeyGenerator: null,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(`Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(`Graph.addNode: the \"${node}\" node already exist in the graph.`);\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(`Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);\n\n  const sourceData = graph._nodes.get(source),\n        targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(`Graph.${name}: source node \"${source}\" not found.`);\n\n  if (!targetData)\n    throw new NotFoundGraphError(`Graph.${name}: target node \"${target}\" not found.`);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey)\n    edge = graph._edgeKeyGenerator(eventData);\n\n  // Coercion of edge key\n  edge = '' + edge;\n\n  // Here, we have a key collision\n  if (graph._edges.has(edge))\n    throw new UsageGraphError(`Graph.${name}: the \"${edge}\" edge already exists in the graph.`);\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (\n      undirected ?\n        typeof sourceData.undirected[target] !== 'undefined' :\n        typeof sourceData.out[target] !== 'undefined'\n    )\n  ) {\n    throw new UsageGraphError(`Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    mustGenerateKey,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n    else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n  else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    }\n    else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected)\n    graph._undirectedSize++;\n  else\n    graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(`Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`);\n    }\n    else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`);\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(`Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);\n\n  let sourceData = graph._nodes.get(source),\n      targetData = graph._nodes.get(target),\n      edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are coherent\n      if (\n        (edgeData.source.key !== source || edgeData.target.key !== target) ||\n        (undirected && (edgeData.source.key !== target || edgeData.target.key !== source))\n      ) {\n        throw new UsageGraphError(`Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`);\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !alreadyExistingEdgeData &&\n    !graph.multi &&\n    sourceData\n  ) {\n    alreadyExistingEdgeData = undirected ?\n      sourceData.undirected[target] :\n      sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes)\n      return alreadyExistingEdgeData.key;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return alreadyExistingEdgeData.key;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater)\n    attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey)\n    edge = graph._edgeKeyGenerator(eventData);\n\n  // Coercion of edge key\n  edge = '' + edge;\n\n  // Here, we have a key collision\n  if (graph._edges.has(edge))\n    throw new UsageGraphError(`Graph.${name}: the \"${edge}\" edge already exists in the graph.`);\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n\n    if (source === target)\n      targetData = sourceData;\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(\n    undirected,\n    edge,\n    mustGenerateKey,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n    else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n  else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    }\n    else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected)\n    graph._undirectedSize++;\n  else\n    graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (options.edgeKeyGenerator && typeof options.edgeKeyGenerator !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'edgeKeyGenerator' option. Expecting a function but got \"${options.edgeKeyGenerator}\".`);\n\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`);\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`);\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`);\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass = options.type === 'mixed' ?\n      MixedNodeData :\n      (options.type === 'directed') ?\n        DirectedNodeData :\n        UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', options.edgeKeyGenerator || incrementalId());\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(this, 'selfLoopCount', () => this._directedSelfLoopCount + this._undirectedSelfLoopCount);\n    readOnlyProperty(this, 'directedSelfLoopCount', () => this._directedSelfLoopCount);\n    readOnlyProperty(this, 'undirectedSelfLoopCount', () => this._undirectedSelfLoopCount);\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n\n    // Early termination\n    if (this.type === 'undirected')\n      return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return (\n        !!edgeData &&\n        !edgeData.undirected\n      );\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.out[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n\n    // Early termination\n    if (this.type === 'directed')\n      return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return (\n        !!edgeData &&\n        edgeData.undirected\n      );\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.undirected[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      let edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];\n\n      if (!edges)\n        edges = typeof nodeData.undirected !== 'undefined' && nodeData.undirected[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n\n    if (this.type === 'undirected')\n      return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError('Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.');\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.directedEdge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.directedEdge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n\n    if (this.type === 'directed')\n      return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError('Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.');\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError('Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.');\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.edge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.edge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined\n    );\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} allowSelfLoops - Count self-loops?\n   * @return {number}            - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.inDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.inDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    return nodeData.inDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's out degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.outDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.outDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    return nodeData.outDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's directed degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.directedDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.directedDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    const inDegree = nodeData.inDegree + loops;\n    const outDegree = nodeData.outDegree + loops;\n\n    return inDegree + outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's undirected degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.undirectedDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'directed')\n      return 0;\n\n    const loops = selfLoops ? nodeData.undirectedSelfLoops : 0;\n\n    return nodeData.undirectedDegree + loops * 2;\n  }\n\n  /**\n   * Method returning the given node's degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.degree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.degree: could not find the \"${node}\" node in the graph.`);\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      if (selfLoops)\n        loops = nodeData.undirectedSelfLoops;\n\n      degree += nodeData.undirectedDegree + loops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      if (selfLoops)\n        loops = nodeData.directedSelfLoops;\n\n      degree += nodeData.inDegree + nodeData.outDegree + loops * 2;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.source: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.target: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(`Graph.extremities: could not find the \"${edge}\" edge in the graph.`);\n\n    return [\n      edgeData.source.key,\n      edgeData.target.key\n    ];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.opposite: could not find the \"${edge}\" edge in the graph.`);\n\n    const source = data.source.key,\n          target = data.target.key;\n\n    if (node !== source && node !== target)\n      throw new NotFoundGraphError(`Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`);\n\n    return node === source ? target : source;\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`);\n\n    return (\n      data.source.key === node ||\n      data.target.key === node\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.isDirected: could not find the \"${edge}\" edge in the graph.`);\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.source === data.target;\n  }\n\n  /**\n   * Method returning whether the given edge has a generated key.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  hasGeneratedKey(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasGeneratedKey: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.generatedKey;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return node;\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`);\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return node;\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.dropNode: could not find the \"${node}\" node in the graph.`);\n\n    // Removing attached edges\n    // TODO: we could do faster\n    this.forEachEdge(node, edge => {\n      this.dropEdge(edge);\n    });\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0],\n            target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(`Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`);\n    }\n    else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(`Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`);\n    }\n\n    // Dropping the edge from the register\n    this._edges.delete(edgeData.key);\n\n    // Updating related degrees\n    const {\n      source: sourceData,\n      target: targetData,\n      attributes\n    } = edgeData;\n\n    const undirected = edgeData.undirected;\n\n    if (sourceData === targetData) {\n      if (undirected) {\n        sourceData.undirectedSelfLoops--;\n        this._undirectedSelfLoopCount--;\n      }\n      else {\n        sourceData.directedSelfLoops--;\n        this._directedSelfLoopCount--;\n      }\n    }\n    else {\n      if (undirected) {\n        sourceData.undirectedDegree--;\n        targetData.undirectedDegree--;\n      }\n      else {\n        sourceData.outDegree--;\n        targetData.inDegree--;\n      }\n    }\n\n    // Clearing index\n    clearEdgeFromStructureIndex(this, undirected, edgeData);\n\n    if (undirected)\n      this._undirectedSize--;\n    else\n      this._directedSize--;\n\n    // Emitting\n    this.emit('edgeDropped', {\n      key: edge,\n      attributes,\n      source: sourceData.key,\n      target: targetData.key,\n      undirected\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing indices\n    this.clearIndex();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.replaceAttributes: provided attributes are not a plain object.');\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.mergeAttributes: provided attributes are not a plain object.');\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method returning the desired attribute for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to get.\n   * @return {any}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.getNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes[name];\n  }\n\n  /**\n   * Method returning the attributes for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @return {object}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttributes(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.getNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes;\n  }\n\n  /**\n   * Method checking whether the given attribute exists for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to check.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  hasNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to set.\n   * @param  {any}    value - Value for the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  setNodeAttribute(node, name, value) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.setNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError('Graph.setNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or value, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}      node    - Target node.\n   * @param  {string}   name    - Name of the attribute to set.\n   * @param  {function} updater - Function that will update the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if updater is not a function.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  updateNodeAttribute(node, name, updater) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.updateNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError('Graph.updateNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or updater, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to remove.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  removeNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method completely replacing the attributes of the given node.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  replaceNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.replaceNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.replaceNodeAttributes: provided attributes are not a plain object.');\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the attributes of the given node with the provided ones.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  mergeNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.mergeNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.mergeNodeAttributes: provided attributes are not a plain object.');\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateEachNodeAttributes: expecting an updater function.');\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError('Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}');\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while ((step = iterator.next(), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateEachEdgeAttributes: expecting an updater function.');\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError('Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}');\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while ((step = iterator.next(), step.done !== true)) {\n      edgeData = step.value;\n      edgeData.attributes = updater(edgeData.key, edgeData.attributes);\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEach(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEach: expecting a callback.');\n\n    if (this.multi)\n      forEachAdjacencyMulti(false, this, callback);\n    else\n      forEachAdjacencySimple(false, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback until\n   * it returns a truthy value to stop iteration.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachUntil(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEach: expecting a callback.');\n\n    if (this.multi)\n      forEachAdjacencyMulti(true, this, callback);\n    else\n      forEachAdjacencySimple(true, this, callback);\n  }\n\n  /**\n   * Method returning an iterator over the graph's adjacency.\n   *\n   * @return {Iterator}\n   */\n  adjacency() {\n    if (this.multi)\n      return createAdjacencyIteratorMulti(this);\n\n    return createAdjacencyIteratorSimple(this);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    if (typeof Array.from === 'function')\n      return Array.from(this._nodes.keys());\n\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEachNode: expecting a callback.');\n\n    this._nodes.forEach((data, key) => {\n      callback(key, data.attributes);\n    });\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback until\n   * it returns a truthy value to stop iteration.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNodeUntil(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEachNode: expecting a callback.');\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData, shouldBreak;\n\n    while ((step = iterator.next(), step !== true)) {\n      nodeData = step.value;\n\n      shouldBreak = callback(nodeData.key, nodeData.attributes);\n\n      if (shouldBreak)\n        break;\n    }\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const data = step.value;\n\n      return {value: [data.key, data.attributes], done: false};\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method exporting the target node.\n   *\n   * @param  {any}   node - Target node.\n   * @return {array}      - The serialized node.\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  exportNode(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.exportNode: could not find the \"${node}\" node in the graph.`);\n\n    return serializeNode(node, data);\n  }\n\n  /**\n   * Method exporting the target edge.\n   *\n   * @param  {any}   edge - Target edge.\n   * @return {array}      - The serialized edge.\n   *\n   * @throws {Error} - Will throw if the edge is not found.\n   */\n  exportEdge(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.exportEdge: could not find the \"${edge}\" edge in the graph.`);\n\n    return serializeEdge(edge, data);\n  }\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(key, data);\n    });\n\n    return {\n      attributes: this.getAttributes(),\n      nodes,\n      edges,\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      }\n    };\n  }\n\n  /**\n   * Method used to import a serialized node.\n   *\n   * @param  {object} data   - The serialized node.\n   * @param  {boolean} merge - Whether to merge the given node.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importNode(data, merge = false) {\n\n    // Validating\n    const error = validateSerializedNode(data);\n\n    if (error) {\n\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError('Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.');\n      if (error === 'no-key')\n        throw new InvalidArgumentsGraphError('Graph.importNode: no key provided.');\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError('Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.');\n    }\n\n    // Adding the node\n    const {key, attributes = {}} = data;\n\n    if (merge)\n      this.mergeNode(key, attributes);\n    else\n      this.addNode(key, attributes);\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized edge.\n   *\n   * @param  {object}  data  - The serialized edge.\n   * @param  {boolean} merge - Whether to merge the given edge.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importEdge(data, merge = false) {\n\n    // Validating\n    const error = validateSerializedEdge(data);\n\n    if (error) {\n\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.');\n      if (error === 'no-source')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: missing souce.');\n      if (error === 'no-target')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: missing target.');\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.');\n      if (error === 'invalid-undirected')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.');\n    }\n\n    // Adding the edge\n    const {\n      source,\n      target,\n      attributes = {},\n      undirected = false\n    } = data;\n\n    let method;\n\n    if ('key' in data) {\n      method = merge ?\n        (undirected ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey) :\n        (undirected ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey);\n\n      method.call(\n        this,\n        data.key,\n        source,\n        target,\n        attributes\n      );\n    }\n    else {\n      method = merge ?\n        (undirected ? this.mergeUndirectedEdge : this.mergeDirectedEdge) :\n        (undirected ? this.addUndirectedEdge : this.addDirectedEdge);\n\n      method.call(\n        this,\n        source,\n        target,\n        attributes\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n\n    // Importing a Graph instance\n    if (isGraph(data)) {\n\n      this.import(data.export(), merge);\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError('Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.');\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid attributes. Expecting a plain object.');\n\n      if (merge)\n        this.mergeAttributes(data.attributes);\n      else\n        this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid nodes. Expecting an array.');\n\n\n      for (i = 0, l = list.length; i < l; i++)\n        this.importNode(list[i], merge);\n    }\n\n    if (data.edges) {\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid edges. Expecting an array.');\n\n      for (i = 0, l = list.length; i < l; i++)\n        this.importEdge(list[i], merge);\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    return new Graph(assign({}, this._options, options));\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @return {Graph} - The copy.\n   */\n  copy() {\n    const graph = new Graph(this._options);\n    graph.import(this);\n\n    return graph;\n  }\n\n  /**\n   * Method upgrading the graph to a mixed one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMixed() {\n    if (this.type === 'mixed')\n      return this;\n\n    // Upgrading node data:\n    // NOTE: maybe this could lead to some de-optimization by usual\n    // JavaScript engines but I cannot be sure of it. Another solution\n    // would be to reinstantiate the classes but this surely has a performance\n    // and memory impact.\n    this._nodes.forEach(data => (data.upgradeToMixed()));\n\n    // Mutating the options & the instance\n    this._options.type = 'mixed';\n    readOnlyProperty(this, 'type', this._options.type);\n    privateProperty(this, 'NodeDataClass', MixedNodeData);\n\n    return this;\n  }\n\n  /**\n   * Method upgrading the graph to a multi one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMulti() {\n    if (this.multi)\n      return this;\n\n    // Mutating the options & the instance\n    this._options.multi = true;\n    readOnlyProperty(this, 'multi', true);\n\n    // Upgrading indices\n    upgradeStructureIndexToMulti(this);\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Indexes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to clear the desired index to clear memory.\n   *\n   * @return {Graph}       - Returns itself for chaining.\n   */\n  clearIndex() {\n    clearStructureIndex(this);\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n          multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      const desc = `(${data.source.key})${direction}(${data.target.key})`;\n\n      if (!data.generatedKey) {\n        label += `[${key}]: `;\n      }\n      else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        }\n        else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (this.hasOwnProperty(k) &&\n          !EMITTER_PROPS.has(k) &&\n          typeof this[k] !== 'function')\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] = Graph.prototype.inspect;\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb),\n          fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function(source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n    else {\n      Graph.prototype[name] = function(edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Self iterator.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.iterator] = Graph.prototype.adjacency;\n\n/**\n * Attributes-related.\n */\nattachAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError('DirectedGraph.from: inconsistent indication that the graph should be multi in given options!');\n\n    if (finalOptions.type !== 'directed')\n    throw new InvalidArgumentsGraphError('DirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError('UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!');\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError('UndirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError('MultiGraph.from: inconsistent indication that the graph should be simple in given options!');\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError('MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!');\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError('MultiDirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError('MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!');\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError('MultiUndirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function(data, options) {\n\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n"],"names":["assign","target","arguments","i","l","length","k","getMatchingEdge","graph","source","type","sourceData","_nodes","get","edge","out","undirected","isGraph","value","_typeof","addUndirectedEdgeWithKey","dropNode","isPlainObject","constructor","Object","isEmpty","o","privateProperty","name","defineProperty","enumerable","configurable","writable","readOnlyProperty","descriptor","validateHints","hints","attributes","Array","isArray","ReflectOwnKeys","R","Reflect","ReflectApply","apply","receiver","args","Function","prototype","call","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","EventEmitter","init","this","emitter","Promise","resolve","reject","errorListener","err","removeListener","resolver","slice","eventTargetAgnosticAddListener","once","handler","flags","on","addErrorHandlerIfEventEmitter","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","prepend","m","events","existing","warning","create","newListener","emit","unshift","push","warned","w","Error","String","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","unwrapListeners","arrayClone","listenerCount","n","copy","addEventListener","wrapListener","arg","removeEventListener","Iterator","next","done","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","key","keys","rawListeners","eventNames","step","_next","Symbol","iterator","of","empty","is","take","Infinity","array","GraphError","data","InvalidArgumentsGraphError","captureStackTrace","NotFoundGraphError","UsageGraphError","MixedNodeData","inDegree","outDegree","undirectedDegree","directedSelfLoops","undirectedSelfLoops","DirectedNodeData","UndirectedNodeData","EdgeData","generatedKey","updateStructureIndex","edgeData","targetData","adj","container","outKey","inKey","multi","Set","add","clearEdgeFromStructureIndex","sourceIndex","size","upgradeToMixed","ATTRIBUTES_METHODS","element","attacher","Class","method","_edges","hasOwnProperty","updater","require$$0","chain","current","iterators","iterate","EDGES_ITERATION","direction","collectSimple","edges","object","collectMulti","forEach","forEachSimple","callback","avoid","forEachMulti","forEachSimpleUntil","forEachMultiUntil","values","createIterator","inner","collectForKeySimple","collectForKeyMulti","edgesData","forEachForKeySimple","forEachForKeyMulti","forEachForKeySimpleUntil","forEachForKeyMultiUntil","createIteratorForKey","v","createEdgeArray","from","undirectedSize","directedSize","mask","forEachEdge","shouldFilter","forEachEdgeUntil","createEdgeIterator","createEdgeArrayForNode","nodeData","fn","splice","lastIndexOf","forEachEdgeForNode","forEachEdgeForNodeUntil","createEdgeIteratorForNode","createEdgeArrayForPath","forEachEdgeForPath","forEachEdgeForPathUntil","createEdgeIteratorForPath","NEIGHBORS_ITERATION","merge","neighbors","neighbor","createNeighborArrayForNode","forEachInObject","neighborData","forEachInObjectOnce","visited","has","forEachInObjectUntil","forEachInObjectOnceUntil","createObjectIterator","createDedupedObjectIterator","nodeHasNeighbor","node","attachForEachNeighbor","description","forEachName","toUpperCase","forEachNeighborForNode","attachForEachNeighborUntil","forEachUntilName","forEachNeighborForNodeUntil","attachNeighborIteratorCreator","iteratorName","createNeighborIterator","forEachAdjacencySimple","breakable","shouldBreak","forEachAdjacencyMulti","containerStep","serializeNode","serialized","serializeEdge","validateSerializedNode","validateSerializedEdge","TYPES","EMITTER_PROPS","DEFAULTS","allowSelfLoops","edgeKeyGenerator","unsafeAddNode","NodeDataClass","addEdge","mustGenerateKey","eventData","_edgeKeyGenerator","_undirectedSelfLoopCount","_directedSelfLoopCount","_undirectedSize","_directedSize","mergeEdge","asUpdater","alreadyExistingEdgeData","oldAttributes","Graph","options","Map","prop","_this","_options","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undirectedEdge","selfLoops","loops","directedDegree","degree","extremities","opposite","hasExtremity","isUndirected","isDirected","isSelfLoop","hasGeneratedKey","addNode","mergeNode","updateNode","_this2","dropEdge","clear","clearEdges","clearIndex","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","getNodeAttribute","getNodeAttributes","hasNodeAttribute","setNodeAttribute","updateNodeAttribute","removeNodeAttribute","replaceNodeAttributes","mergeNodeAttributes","updateEachNodeAttributes","updateEachEdgeAttributes","forEachUntil","adjacency","offset","createAdjacencyIteratorSimple","nodes","forEachNode","forEachNodeUntil","nodeEntries","exportNode","exportEdge","importNode","importEdge","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addDirectedEdgeWithKey","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","nullCopy","emptyCopy","upgradeToMulti","toJSON","toString","inspect","multiIndex","label","desc","_this3","dummy","verb","generateKey","attachAttributesMethods","attachEdgeArrayCreator","attachForEachEdge","attachForEachEdgeUntil","originalName","attachEdgeIteratorCreator","attachEdgeIterationMethods","node1","node2","attachNeighborArrayCreator","attachNeighborIterationMethods","DirectedGraph","finalOptions","_Graph","UndirectedGraph","_Graph2","MultiGraph","_Graph3","MultiDirectedGraph","_Graph4","MultiUndirectedGraph","_Graph5","attachStaticFromMethod","instance"],"mappings":"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"}