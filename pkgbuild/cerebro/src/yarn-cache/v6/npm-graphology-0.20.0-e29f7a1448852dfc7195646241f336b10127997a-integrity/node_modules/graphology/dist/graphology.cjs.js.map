{"version":3,"file":"graphology.cjs.js","sources":["../src/utils.js","../src/errors.js","../src/data.js","../src/indices.js","../src/attributes.js","../src/iteration/edges.js","../src/iteration/neighbors.js","../src/iteration/adjacency.js","../src/serialization.js","../src/graph.js","../src/classes.js","../src/endpoint.cjs.js"],"sourcesContent":["/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i])\n      continue;\n\n    for (const k in arguments[i])\n      target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function')\n  assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData)\n    return edge;\n\n  if (type === 'mixed') {\n    edge = (\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target])\n    );\n  }\n  else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  }\n  else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a Graph implementation instance.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function'\n  );\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    value.constructor === Object\n  );\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o)\n    return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  }\n  else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints))\n    return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes))\n    return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalId() {\n  let i = 0;\n\n  return () => {\n    return i++;\n  };\n}\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message, data) {\n    super();\n    this.name = 'GraphError';\n    this.message = message || '';\n    this.data = data || {};\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, InvalidArgumentsGraphError.prototype.constructor);\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.directedSelfLoops = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n}\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n}\n\nDirectedNodeData.prototype.upgradeToMixed = function() {\n\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n}\n\nUndirectedNodeData.prototype.upgradeToMixed = function() {\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {boolean} generatedKey - Was its key generated?\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, generatedKey, source, target, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n\n  // Was its key generated?\n  this.generatedKey = generatedKey;\n}\n","/**\n * Graphology Indexes Functions\n * =============================\n *\n * Bunch of functions used to compute or clear indexes.\n */\n\n/**\n * Function updating the 'structure' index with the given edge's data.\n * Note that in the case of the multi graph, related edges are stored in a\n * set that is the same for A -> B & B <- A.\n *\n * @param {Graph}    graph      - Target Graph instance.\n * @param {EdgeData} edgeData   - Added edge's data.\n * @param {NodeData} sourceData - Source node's data.\n * @param {NodeData} targetData - Target node's data.\n */\nexport function updateStructureIndex(\n  graph,\n  undirected,\n  edgeData,\n  source,\n  target,\n  sourceData,\n  targetData\n) {\n  const multi = graph.multi;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (undirected)\n    outKey = inKey = 'undirected';\n\n  let adj, container;\n\n  if (multi) {\n\n    // Handling source\n    adj = sourceData[outKey];\n    container = adj[target];\n\n    if (typeof container === 'undefined') {\n      container = new Set();\n      adj[target] = container;\n    }\n\n    container.add(edgeData);\n\n    // If selfLoop, we break here\n    if (source === target && undirected)\n      return;\n\n    // Handling target (we won't add the edge because it was already taken\n    // care of with source above)\n    adj = targetData[inKey];\n    if (typeof adj[source] === 'undefined')\n      adj[source] = container;\n  }\n  else {\n\n    // Handling source\n    sourceData[outKey][target] = edgeData;\n\n    // If selfLoop, we break here\n    if (source === target && undirected)\n      return;\n\n    // Handling target\n    targetData[inKey][source] = edgeData;\n  }\n}\n\n/**\n * Function clearing the 'structure' index data related to the given edge.\n *\n * @param {Graph}    graph    - Target Graph instance.\n * @param {EdgeData} edgeData - Dropped edge's data.\n */\nexport function clearEdgeFromStructureIndex(graph, undirected, edgeData) {\n  const multi = graph.multi;\n\n  const {source: sourceData, target: targetData} = edgeData;\n\n  const source = sourceData.key,\n        target = targetData.key;\n\n  // NOTE: since the edge set is the same for source & target, we can only\n  // affect source\n  const outKey = undirected ? 'undirected' : 'out',\n        sourceIndex = sourceData[outKey];\n\n  const inKey = undirected ? 'undirected' : 'in';\n\n  if (target in sourceIndex) {\n\n    if (multi) {\n      const set = sourceIndex[target];\n\n      if (set.size === 1) {\n        delete sourceIndex[target];\n        delete targetData[inKey][source];\n      }\n      else {\n        set.delete(edgeData);\n      }\n    }\n    else\n      delete sourceIndex[target];\n  }\n\n  if (multi)\n    return;\n\n  const targetIndex = targetData[inKey];\n\n  delete targetIndex[source];\n}\n\n/**\n * Function clearing the whole 'structure' index.\n *\n * @param {Graph} graph - Target Graph instance.\n */\nexport function clearStructureIndex(graph) {\n  graph._nodes.forEach(data => {\n\n    // Clearing now useless properties\n    if (typeof data.in !== 'undefined') {\n      data.in = {};\n      data.out = {};\n    }\n\n    if (typeof data.undirected !== 'undefined') {\n      data.undirected = {};\n    }\n  });\n}\n\n/**\n * Function used to upgrade a simple `structure` index to a multi on.\n *\n * @param {Graph}  graph - Target Graph instance.\n */\nexport function upgradeStructureIndexToMulti(graph) {\n  graph._nodes.forEach((data, node) => {\n\n    // Directed\n    if (data.out) {\n\n      for (const neighbor in data.out) {\n        const edges = new Set();\n        edges.add(data.out[neighbor]);\n        data.out[neighbor] = edges;\n        graph._nodes.get(neighbor).in[node] = edges;\n      }\n    }\n\n    // Undirected\n    if (data.undirected) {\n      for (const neighbor in data.undirected) {\n        if (neighbor > node)\n          continue;\n\n        const edges = new Set();\n        edges.add(data.undirected[neighbor]);\n        data.undirected[neighbor] = edges;\n        graph._nodes.get(neighbor).undirected[node] = edges;\n      }\n    }\n  });\n}\n","/**\n * Graphology Attributes methods\n * ==============================\n *\n * Attributes-related methods being exactly the same for nodes & edges,\n * we abstract them here for factorization reasons.\n */\nimport {\n  assign,\n  isPlainObject,\n  getMatchingEdge\n} from './utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeGetter(Class, method, type) {\n\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachAttributesGetter(Class, method, type) {\n\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 1) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachAttributeChecker(Class, method, type) {\n\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeSetter(Class, method, type) {\n\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 3) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeUpdater(Class, method, type) {\n\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 3) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.${method}: updater should be a function.`);\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeRemover(Class, method, type) {\n\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributesReplacer(Class, method, type) {\n\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributesMerger(Class, method, type) {\n\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachAttributesMerger\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport function attachAttributesMethods(Graph) {\n  ATTRIBUTES_METHODS.forEach(function({name, attacher}) {\n\n    // For edges\n    attacher(\n      Graph,\n      name('Edge'),\n      'mixed'\n    );\n\n    // For directed edges\n    attacher(\n      Graph,\n      name('DirectedEdge'),\n      'directed'\n    );\n\n    // For undirected edges\n    attacher(\n      Graph,\n      name('UndirectedEdge'),\n      'undirected'\n    );\n  });\n}\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError\n} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function collecting edges from the given object.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @return {array}         - The found edges.\n */\nfunction collectSimple(edges, object) {\n  for (const k in object)\n    edges.push(object[k].key);\n}\n\nfunction collectMulti(edges, object) {\n  for (const k in object)\n    object[k].forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over edges from the given object using a callback.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    const edgeData = object[k];\n\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    );\n  }\n}\n\nfunction forEachMulti(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    object[k].forEach(edgeData => callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    ));\n  }\n}\n\n/**\n * Function iterating over edges from the given object using a callback until\n * the return value of the callback is truthy.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimpleUntil(object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\nfunction forEachMultiUntil(object, callback, avoid) {\n  let iterator, step, edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    iterator = object[k].values();\n\n    while ((step = iterator.next(), step.done !== true)) {\n      edgeData = step.value;\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected,\n        edgeData.generatedKey\n      );\n\n      if (shouldBreak)\n        return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let inner = null,\n      i = 0;\n\n  return new Iterator(function next() {\n    let edgeData;\n\n    if (inner) {\n      const step = inner.next();\n\n      if (step.done) {\n        inner = null;\n        i++;\n        return next();\n      }\n\n      edgeData = step.value;\n    }\n    else {\n      if (i >= l)\n        return {done: true};\n\n      const k = keys[i];\n\n      if (k === avoid) {\n        i++;\n        return next();\n      }\n\n      edgeData = object[k];\n\n      if (edgeData instanceof Set) {\n        inner = edgeData.values();\n        return next();\n      }\n\n      i++;\n    }\n\n    return {\n      done: false,\n      value: [\n        edgeData.key,\n        edgeData.attributes,\n        edgeData.source.key,\n        edgeData.target.key,\n        edgeData.source.attributes,\n        edgeData.target.attributes\n      ]\n    };\n  });\n}\n\n/**\n * Function collecting edges from the given object at given key.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @param  {mixed}  k      - Neighbor key.\n * @return {array}         - The found edges.\n */\nfunction collectForKeySimple(edges, object, k) {\n  const edgeData = object[k];\n\n  if (!edgeData)\n    return;\n\n  edges.push(edgeData.key);\n}\n\nfunction collectForKeyMulti(edges, object, k) {\n  const edgesData = object[k];\n\n  if (!edgesData)\n    return;\n\n  edgesData.forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData)\n    return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  callback(\n    edgeData.key,\n    edgeData.attributes,\n    sourceData.key,\n    targetData.key,\n    sourceData.attributes,\n    targetData.attributes,\n    edgeData.undirected,\n    edgeData.generatedKey\n  );\n}\n\nfunction forEachForKeyMulti(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData)\n    return;\n\n  edgesData.forEach(edgeData => callback(\n    edgeData.key,\n    edgeData.attributes,\n    edgeData.source.key,\n    edgeData.target.key,\n    edgeData.source.attributes,\n    edgeData.target.attributes,\n    edgeData.undirected,\n    edgeData.generatedKey\n  ));\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback until it returns a truthy value to stop iteration.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimpleUntil(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData)\n    return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  return callback(\n    edgeData.key,\n    edgeData.attributes,\n    sourceData.key,\n    targetData.key,\n    sourceData.attributes,\n    targetData.attributes,\n    edgeData.undirected,\n    edgeData.generatedKey\n  );\n}\n\nfunction forEachForKeyMultiUntil(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData)\n    return;\n\n  let shouldBreak = false;\n\n  const iterator = edgesData.values();\n  let step, edgeData;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    edgeData = step.value;\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  const v = object[k];\n\n  if (v instanceof Set) {\n    const iterator = v.values();\n\n    return new Iterator(function() {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const edgeData = step.value;\n\n      return {\n        done: false,\n        value: [\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.source.key,\n          edgeData.target.key,\n          edgeData.source.attributes,\n          edgeData.target.attributes\n        ]\n      };\n    });\n  }\n\n  return Iterator.of([\n    v.key,\n    v.attributes,\n    v.source.key,\n    v.target.key,\n    v.source.attributes,\n    v.target.attributes\n  ]);\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0)\n    return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    if (typeof Array.from === 'function')\n      return Array.from(graph._edges.keys());\n\n    return take(graph._edges.keys(), graph._edges.size);\n  }\n\n  const size = type === 'undirected' ?\n    graph.undirectedSize :\n    graph.directedSize;\n\n  const list = new Array(size),\n        mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask)\n      list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(graph, type, callback) {\n  if (graph.size === 0)\n    return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  const iterator = graph._edges.values();\n\n  while ((step = iterator.next(), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask)\n      continue;\n\n    const {key, attributes, source, target} = data;\n\n    callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected,\n      data.generatedKey\n    );\n  }\n}\n\n/**\n * Function iterating over a graph's edges using a callback until it returns\n * a truthy value to stop iteration.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdgeUntil(graph, type, callback) {\n  if (graph.size === 0)\n    return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while ((step = iterator.next(), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask)\n      continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected,\n      data.generatedKey\n    );\n\n    if (shouldBreak)\n      break;\n  }\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0)\n    return Iterator.empty();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    let step, data;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      data = step.value;\n\n      if (shouldFilter && data.undirected !== mask)\n        continue;\n\n      break;\n    }\n\n    const value = [\n      data.key,\n      data.attributes,\n      data.source.key,\n      data.target.key,\n      data.source.attributes,\n      data.target.attributes\n    ];\n\n    return {value, done: false};\n  });\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = [];\n\n  const fn = multi ? collectMulti : collectSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out')\n      fn(edges, nodeData.in);\n    if (direction !== 'in')\n      fn(edges, nodeData.out);\n\n    // Handling self loop edge case\n    if (!direction && nodeData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(nodeData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    fn(edges, nodeData.undirected);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out')\n      fn(nodeData.in, callback);\n    if (direction !== 'in')\n      fn(nodeData.out, callback, !direction ? nodeData.key : null);\n  }\n\n  if (type !== 'directed') {\n    fn(nodeData.undirected, callback);\n  }\n}\n\n/**\n * Function iterating over a node's edges using a callback until it returns\n * a truthy value to stop iteration.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNodeUntil(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMultiUntil : forEachSimpleUntil;\n\n  let shouldBreak = false;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      shouldBreak = fn(nodeData.in, callback);\n\n      if (shouldBreak)\n        return;\n    }\n    if (direction !== 'in') {\n      shouldBreak = fn(nodeData.out, callback, !direction ? nodeData.key : null);\n\n      if (shouldBreak)\n        return;\n    }\n  }\n\n  if (type !== 'directed') {\n    shouldBreak = fn(nodeData.undirected, callback);\n\n    if (shouldBreak)\n      return;\n  }\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.out, !direction ? nodeData.key : null));\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const fn = multi ? collectForKeyMulti : collectForKeySimple;\n\n  const edges = [];\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(edges, sourceData.in, target);\n\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n      fn(edges, sourceData.out, target);\n\n    // Handling self loop edge case\n    if (!direction && sourceData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(sourceData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(edges, sourceData.undirected, target);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over edges for the given path using a callback.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(type, multi, direction, sourceData, target, callback) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(sourceData.in, target, callback);\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n        fn(sourceData.out, target, callback);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(sourceData.undirected, target, callback);\n  }\n}\n\n/**\n * Function iterating over edges for the given path using a callback until\n * it returns a truthy value to stop iteration.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPathUntil(type, multi, direction, sourceData, target, callback) {\n  const fn = multi ? forEachForKeyMultiUntil : forEachForKeySimpleUntil;\n\n  let shouldBreak = false;\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      shouldBreak = fn(sourceData.in, target, callback);\n\n      if (shouldBreak)\n        return;\n    }\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in') {\n        shouldBreak = fn(sourceData.out, target, callback, !direction ? sourceData.key : null);\n\n        if (shouldBreak)\n          return;\n      }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      shouldBreak = fn(sourceData.undirected, target, callback);\n\n      if (shouldBreak)\n        return;\n    }\n  }\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.undirected, target));\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(source, target) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length)\n      return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(type, this.multi, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function(source, target, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${forEachName}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(type, this.multi, direction, sourceData, target, callback);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdgeUntil(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachUntilName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1) + 'Until';\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback and breaking as soon as the callback return a truthy value.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachUntilName] = function(source, target, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdgeUntil(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${forEachUntilName}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNodeUntil(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${forEachUntilName}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${forEachUntilName}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPathUntil(type, this.multi, direction, sourceData, target, callback);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${forEachUntilName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nexport function attachEdgeIteratorCreator(Class, description) {\n  const {\n    name: originalName,\n    type,\n    direction\n  } = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(source, target) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length)\n      return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachForEachEdgeUntil(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError\n} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function merging neighbors into the given set iterating over the given object.\n *\n * @param {BasicSet} neighbors - Neighbors set.\n * @param {object}   object    - Target object.\n */\nfunction merge(neighbors, object) {\n  if (typeof object === 'undefined')\n    return;\n\n  for (const neighbor in object)\n    neighbors.add(neighbor);\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return Object.keys(nodeData[direction]);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const neighbors = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      merge(neighbors, nodeData.in);\n    }\n    if (direction !== 'in') {\n      merge(neighbors, nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    merge(neighbors, nodeData.undirected);\n  }\n\n  return take(neighbors.values(), neighbors.size);\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n  }\n}\n\nfunction forEachInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      continue;\n\n    visited.add(neighborData.key);\n\n    callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n  }\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback until it returns a truthy value to stop iteration.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObjectUntil(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    const shouldBreak = callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\nfunction forEachInObjectOnceUntil(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      continue;\n\n    visited.add(neighborData.key);\n\n    const shouldBreak = callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\nfunction forEachNeighborForNode(type, direction, nodeData, callback) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      forEachInObjectOnce(visited, nodeData, nodeData.in, callback);\n    }\n    if (direction !== 'in') {\n      forEachInObjectOnce(visited, nodeData, nodeData.out, callback);\n    }\n  }\n\n  if (type !== 'directed') {\n    forEachInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n  }\n}\n\nfunction forEachNeighborForNodeUntil(type, direction, nodeData, callback) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObjectUntil(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObjectUntil(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  let shouldBreak = false;\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.in, callback);\n\n      if (shouldBreak)\n        return;\n    }\n    if (direction !== 'in') {\n      shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.out, callback);\n\n      if (shouldBreak)\n        return;\n    }\n  }\n\n  if (type !== 'directed') {\n    shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.undirected, callback);\n\n    if (shouldBreak)\n      return;\n  }\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createObjectIterator(nodeData, object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    if (i >= l)\n      return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      return next();\n\n    visited.add(neighborData.key);\n\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createObjectIterator(nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createObjectIterator(nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.in));\n    }\n    if (direction !== 'in') {\n      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.out));\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function returning whether the given node has target neighbor.\n *\n * @param  {Graph}        graph     - Target graph.\n * @param  {string}       type      - Type of neighbor.\n * @param  {string}       direction - Direction.\n * @param  {any}          node      - Target node.\n * @param  {any}          neighbor  - Target neighbor.\n * @return {boolean}\n */\nfunction nodeHasNeighbor(graph, type, direction, node, neighbor) {\n\n  const nodeData = graph._nodes.get(node);\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined') {\n      for (const k in nodeData.in)\n        if (k === neighbor)\n          return true;\n    }\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined') {\n      for (const k in nodeData.out)\n        if (k === neighbor)\n          return true;\n    }\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    for (const k in nodeData.undirected)\n        if (k === neighbor)\n          return true;\n  }\n\n  return false;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  /**\n   * Function returning an array or the count of certain neighbors.\n   *\n   * Arity 1: Return all of a node's relevant neighbors.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return whether the two nodes are indeed neighbors.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The neighbors or the number of neighbors.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(node) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (arguments.length === 2) {\n      const node1 = '' + arguments[0],\n            node2 = '' + arguments[1];\n\n      if (!this._nodes.has(node1))\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node1}\" node in the graph.`);\n\n      if (!this._nodes.has(node2))\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node2}\" node in the graph.`);\n\n      // Here, we want to assess whether the two given nodes are neighbors\n      return nodeHasNeighbor(\n        this,\n        type,\n        direction,\n        node1,\n        node2\n      );\n    }\n    else if (arguments.length === 1) {\n      node = '' + node;\n\n      const nodeData = this._nodes.get(node);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node}\" node in the graph.`);\n\n      // Here, we want to iterate over a node's relevant neighbors\n      const neighbors = createNeighborArrayForNode(\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n\n      return neighbors;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid number of arguments (expecting 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function(node, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${forEachName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighborForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighborUntil(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachUntilName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1) + 'Until';\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachUntilName] = function(node, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${forEachUntilName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighborForNodeUntil(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function(node) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachForEachNeighborUntil(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Adjacency Iteration\n * ================================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\nimport Iterator from 'obliterator/iterator';\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable - Can we break?\n * @param {Graph}    graph     - Target Graph instance.\n * @param {callback} function  - Iteration callback.\n */\nexport function forEachAdjacencySimple(breakable, graph, callback) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected,\n          edgeData.generatedKey\n        );\n\n        if (breakable && shouldBreak)\n          return;\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        if (targetData.key !== neighbor)\n          targetData = edgeData.source;\n\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected,\n          edgeData.generatedKey\n        );\n\n        if (breakable && shouldBreak)\n          return;\n      }\n    }\n  }\n}\n\n/**\n * Function iterating over a multi graph's adjacency using a callback.\n *\n * @param {boolean}  breakable - Can we break?\n * @param {Graph}    graph    - Target Graph instance.\n * @param {callback} function - Iteration callback.\n */\nexport function forEachAdjacencyMulti(breakable, graph, callback) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, container, containerStep, adj, edgeData, targetData, shouldBreak;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        container = adj[neighbor].values();\n\n        while ((containerStep = container.next(), containerStep.done !== true)) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected,\n            edgeData.generatedKey\n          );\n\n          if (breakable && shouldBreak)\n            return;\n        }\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        container = adj[neighbor].values();\n\n        while ((containerStep = container.next(), containerStep.done !== true)) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor)\n            targetData = edgeData.source;\n\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected,\n            edgeData.generatedKey\n          );\n\n          if (breakable && shouldBreak)\n            return;\n        }\n      }\n    }\n  }\n}\n\nexport function createAdjacencyIteratorSimple(graph) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let state = 'outer',\n      sourceData,\n      neighbors,\n      adj,\n      offset;\n\n  return new Iterator(function next() {\n    let step;\n\n    if (state === 'outer') {\n      step = iterator.next();\n\n      if (step.done === true)\n        return step;\n\n      sourceData = step.value;\n\n      state = 'directed';\n      return next();\n    }\n\n    if (state === 'directed') {\n      if (type === 'undirected') {\n        state = 'undirected';\n        return next();\n      }\n\n      adj = sourceData.out;\n      neighbors = Object.keys(sourceData.out);\n      offset = 0;\n      state = 'inner-directed';\n\n      return next();\n    }\n\n    if (state === 'undirected') {\n      if (type === 'directed') {\n        state = 'outer';\n        return next();\n      }\n\n      adj = sourceData.undirected;\n      neighbors = Object.keys(sourceData.undirected);\n      offset = 0;\n      state = 'inner-undirected';\n    }\n\n    // Inner\n    if (offset >= neighbors.length) {\n      if (state === 'inner-undirected')\n        state = 'outer';\n      else\n        state = 'undirected';\n\n      return next();\n    }\n\n    const neighbor = neighbors[offset++];\n    const edgeData = adj[neighbor];\n    let targetData = edgeData.target;\n\n    if (state === 'inner-undirected' && targetData.key === sourceData.key)\n      targetData = edgeData.source;\n\n    return {\n      done: false,\n      value: [\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.key,\n        edgeData.attributes\n      ]\n    };\n  });\n}\n\nexport function createAdjacencyIteratorMulti(graph) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let state = 'outer',\n      sourceData,\n      neighbors,\n      container = null,\n      adj,\n      offset;\n\n  return new Iterator(function next() {\n    let step;\n\n    if (state === 'outer') {\n      step = iterator.next();\n\n      if (step.done === true)\n        return step;\n\n      sourceData = step.value;\n\n      state = 'directed';\n      return next();\n    }\n\n    if (state === 'directed') {\n      if (type === 'undirected') {\n        state = 'undirected';\n        return next();\n      }\n\n      adj = sourceData.out;\n      neighbors = Object.keys(sourceData.out);\n      offset = 0;\n      state = 'inner-directed';\n\n      return next();\n    }\n\n    if (state === 'undirected') {\n      if (type === 'directed') {\n        state = 'outer';\n        return next();\n      }\n\n      adj = sourceData.undirected;\n      neighbors = Object.keys(sourceData.undirected);\n      offset = 0;\n      state = 'inner-undirected';\n    }\n\n    // Inner\n    if (!container && offset >= neighbors.length) {\n      if (state === 'inner-undirected')\n        state = 'outer';\n      else\n        state = 'undirected';\n\n      return next();\n    }\n\n    if (!container) {\n      const neighbor = neighbors[offset++];\n      container = adj[neighbor].values();\n      return next();\n    }\n\n    step = container.next();\n\n    if (step.done) {\n      container = null;\n      return next();\n    }\n\n    const edgeData = step.value;\n    let targetData = edgeData.target;\n\n    if (state === 'inner-undirected' && targetData.key === sourceData.key)\n      targetData = edgeData.source;\n\n    return {\n      done: false,\n      value: [\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.key,\n        edgeData.attributes\n      ]\n    };\n  });\n}\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used to validate import-export formats & to ouput\n * them from internal graph data.\n *\n * Serialized Node:\n * {key, ?attributes}\n *\n * Serialized Edge:\n * {key?, source, target, attributes?, undirected?}\n *\n * Serialized Graph:\n * {nodes[], edges?[]}\n */\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(key, data) {\n  const serialized = {\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  // We export the key unless if it was provided by the user\n  if (!data.generatedKey)\n    serialized.key = key;\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (data.undirected)\n    serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    return 'not-object';\n\n  if (!('key' in value))\n    return 'no-key';\n\n  if ('attributes' in value &&\n      (!isPlainObject(value.attributes) || value.attributes === null))\n    return 'invalid-attributes';\n\n  return null;\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    return 'not-object';\n\n  if (!('source' in value))\n    return 'no-source';\n\n  if (!('target' in value))\n    return 'no-target';\n\n  if ('attributes' in value &&\n      (!isPlainObject(value.attributes) || value.attributes === null))\n    return 'invalid-attributes';\n\n  if ('undirected' in value &&\n      (typeof value.undirected !== 'boolean'))\n    return 'invalid-undirected';\n\n  return null;\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport {\n  updateStructureIndex,\n  clearEdgeFromStructureIndex,\n  clearStructureIndex,\n  upgradeStructureIndexToMulti\n} from './indices';\n\nimport {attachAttributesMethods} from './attributes';\nimport {attachEdgeIterationMethods} from './iteration/edges';\nimport {attachNeighborIterationMethods} from './iteration/neighbors';\nimport {\n  forEachAdjacencySimple,\n  forEachAdjacencyMulti,\n  createAdjacencyIteratorSimple,\n  createAdjacencyIteratorMulti\n} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isGraph,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalId,\n  validateHints\n} from './utils';\n\n/**\n * Enums.\n */\nconst TYPES = new Set([\n  'directed',\n  'undirected',\n  'mixed'\n]);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`,\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  edgeKeyGenerator: null,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(`Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(`Graph.addNode: the \"${node}\" node already exist in the graph.`);\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(`Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);\n\n  const sourceData = graph._nodes.get(source),\n        targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(`Graph.${name}: source node \"${source}\" not found.`);\n\n  if (!targetData)\n    throw new NotFoundGraphError(`Graph.${name}: target node \"${target}\" not found.`);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey)\n    edge = graph._edgeKeyGenerator(eventData);\n\n  // Coercion of edge key\n  edge = '' + edge;\n\n  // Here, we have a key collision\n  if (graph._edges.has(edge))\n    throw new UsageGraphError(`Graph.${name}: the \"${edge}\" edge already exists in the graph.`);\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (\n      undirected ?\n        typeof sourceData.undirected[target] !== 'undefined' :\n        typeof sourceData.out[target] !== 'undefined'\n    )\n  ) {\n    throw new UsageGraphError(`Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    mustGenerateKey,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n    else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n  else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    }\n    else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected)\n    graph._undirectedSize++;\n  else\n    graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(`Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`);\n    }\n    else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`);\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(`Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);\n\n  let sourceData = graph._nodes.get(source),\n      targetData = graph._nodes.get(target),\n      edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are coherent\n      if (\n        (edgeData.source.key !== source || edgeData.target.key !== target) ||\n        (undirected && (edgeData.source.key !== target || edgeData.target.key !== source))\n      ) {\n        throw new UsageGraphError(`Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`);\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !alreadyExistingEdgeData &&\n    !graph.multi &&\n    sourceData\n  ) {\n    alreadyExistingEdgeData = undirected ?\n      sourceData.undirected[target] :\n      sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes)\n      return alreadyExistingEdgeData.key;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return alreadyExistingEdgeData.key;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater)\n    attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey)\n    edge = graph._edgeKeyGenerator(eventData);\n\n  // Coercion of edge key\n  edge = '' + edge;\n\n  // Here, we have a key collision\n  if (graph._edges.has(edge))\n    throw new UsageGraphError(`Graph.${name}: the \"${edge}\" edge already exists in the graph.`);\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n\n    if (source === target)\n      targetData = sourceData;\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(\n    undirected,\n    edge,\n    mustGenerateKey,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n    else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n  else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    }\n    else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected)\n    graph._undirectedSize++;\n  else\n    graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (options.edgeKeyGenerator && typeof options.edgeKeyGenerator !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'edgeKeyGenerator' option. Expecting a function but got \"${options.edgeKeyGenerator}\".`);\n\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`);\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`);\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`);\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass = options.type === 'mixed' ?\n      MixedNodeData :\n      (options.type === 'directed') ?\n        DirectedNodeData :\n        UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', options.edgeKeyGenerator || incrementalId());\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(this, 'selfLoopCount', () => this._directedSelfLoopCount + this._undirectedSelfLoopCount);\n    readOnlyProperty(this, 'directedSelfLoopCount', () => this._directedSelfLoopCount);\n    readOnlyProperty(this, 'undirectedSelfLoopCount', () => this._undirectedSelfLoopCount);\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n\n    // Early termination\n    if (this.type === 'undirected')\n      return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return (\n        !!edgeData &&\n        !edgeData.undirected\n      );\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.out[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n\n    // Early termination\n    if (this.type === 'directed')\n      return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return (\n        !!edgeData &&\n        edgeData.undirected\n      );\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.undirected[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      let edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];\n\n      if (!edges)\n        edges = typeof nodeData.undirected !== 'undefined' && nodeData.undirected[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n\n    if (this.type === 'undirected')\n      return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError('Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.');\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.directedEdge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.directedEdge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n\n    if (this.type === 'directed')\n      return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError('Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.');\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError('Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.');\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.edge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.edge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined\n    );\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} allowSelfLoops - Count self-loops?\n   * @return {number}            - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.inDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.inDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    return nodeData.inDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's out degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.outDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.outDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    return nodeData.outDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's directed degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.directedDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.directedDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    const inDegree = nodeData.inDegree + loops;\n    const outDegree = nodeData.outDegree + loops;\n\n    return inDegree + outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's undirected degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.undirectedDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'directed')\n      return 0;\n\n    const loops = selfLoops ? nodeData.undirectedSelfLoops : 0;\n\n    return nodeData.undirectedDegree + loops * 2;\n  }\n\n  /**\n   * Method returning the given node's degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.degree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.degree: could not find the \"${node}\" node in the graph.`);\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      if (selfLoops)\n        loops = nodeData.undirectedSelfLoops;\n\n      degree += nodeData.undirectedDegree + loops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      if (selfLoops)\n        loops = nodeData.directedSelfLoops;\n\n      degree += nodeData.inDegree + nodeData.outDegree + loops * 2;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.source: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.target: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(`Graph.extremities: could not find the \"${edge}\" edge in the graph.`);\n\n    return [\n      edgeData.source.key,\n      edgeData.target.key\n    ];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.opposite: could not find the \"${edge}\" edge in the graph.`);\n\n    const source = data.source.key,\n          target = data.target.key;\n\n    if (node !== source && node !== target)\n      throw new NotFoundGraphError(`Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`);\n\n    return node === source ? target : source;\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`);\n\n    return (\n      data.source.key === node ||\n      data.target.key === node\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.isDirected: could not find the \"${edge}\" edge in the graph.`);\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.source === data.target;\n  }\n\n  /**\n   * Method returning whether the given edge has a generated key.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  hasGeneratedKey(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasGeneratedKey: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.generatedKey;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return node;\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`);\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return node;\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.dropNode: could not find the \"${node}\" node in the graph.`);\n\n    // Removing attached edges\n    // TODO: we could do faster\n    this.forEachEdge(node, edge => {\n      this.dropEdge(edge);\n    });\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0],\n            target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(`Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`);\n    }\n    else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(`Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`);\n    }\n\n    // Dropping the edge from the register\n    this._edges.delete(edgeData.key);\n\n    // Updating related degrees\n    const {\n      source: sourceData,\n      target: targetData,\n      attributes\n    } = edgeData;\n\n    const undirected = edgeData.undirected;\n\n    if (sourceData === targetData) {\n      if (undirected) {\n        sourceData.undirectedSelfLoops--;\n        this._undirectedSelfLoopCount--;\n      }\n      else {\n        sourceData.directedSelfLoops--;\n        this._directedSelfLoopCount--;\n      }\n    }\n    else {\n      if (undirected) {\n        sourceData.undirectedDegree--;\n        targetData.undirectedDegree--;\n      }\n      else {\n        sourceData.outDegree--;\n        targetData.inDegree--;\n      }\n    }\n\n    // Clearing index\n    clearEdgeFromStructureIndex(this, undirected, edgeData);\n\n    if (undirected)\n      this._undirectedSize--;\n    else\n      this._directedSize--;\n\n    // Emitting\n    this.emit('edgeDropped', {\n      key: edge,\n      attributes,\n      source: sourceData.key,\n      target: targetData.key,\n      undirected\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing indices\n    this.clearIndex();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.replaceAttributes: provided attributes are not a plain object.');\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.mergeAttributes: provided attributes are not a plain object.');\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method returning the desired attribute for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to get.\n   * @return {any}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.getNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes[name];\n  }\n\n  /**\n   * Method returning the attributes for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @return {object}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttributes(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.getNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes;\n  }\n\n  /**\n   * Method checking whether the given attribute exists for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to check.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  hasNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to set.\n   * @param  {any}    value - Value for the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  setNodeAttribute(node, name, value) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.setNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError('Graph.setNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or value, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}      node    - Target node.\n   * @param  {string}   name    - Name of the attribute to set.\n   * @param  {function} updater - Function that will update the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if updater is not a function.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  updateNodeAttribute(node, name, updater) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.updateNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError('Graph.updateNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or updater, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to remove.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  removeNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method completely replacing the attributes of the given node.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  replaceNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.replaceNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.replaceNodeAttributes: provided attributes are not a plain object.');\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the attributes of the given node with the provided ones.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  mergeNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.mergeNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.mergeNodeAttributes: provided attributes are not a plain object.');\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateEachNodeAttributes: expecting an updater function.');\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError('Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}');\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while ((step = iterator.next(), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateEachEdgeAttributes: expecting an updater function.');\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError('Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}');\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while ((step = iterator.next(), step.done !== true)) {\n      edgeData = step.value;\n      edgeData.attributes = updater(edgeData.key, edgeData.attributes);\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEach(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEach: expecting a callback.');\n\n    if (this.multi)\n      forEachAdjacencyMulti(false, this, callback);\n    else\n      forEachAdjacencySimple(false, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback until\n   * it returns a truthy value to stop iteration.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachUntil(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEach: expecting a callback.');\n\n    if (this.multi)\n      forEachAdjacencyMulti(true, this, callback);\n    else\n      forEachAdjacencySimple(true, this, callback);\n  }\n\n  /**\n   * Method returning an iterator over the graph's adjacency.\n   *\n   * @return {Iterator}\n   */\n  adjacency() {\n    if (this.multi)\n      return createAdjacencyIteratorMulti(this);\n\n    return createAdjacencyIteratorSimple(this);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    if (typeof Array.from === 'function')\n      return Array.from(this._nodes.keys());\n\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEachNode: expecting a callback.');\n\n    this._nodes.forEach((data, key) => {\n      callback(key, data.attributes);\n    });\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback until\n   * it returns a truthy value to stop iteration.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNodeUntil(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEachNode: expecting a callback.');\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData, shouldBreak;\n\n    while ((step = iterator.next(), step !== true)) {\n      nodeData = step.value;\n\n      shouldBreak = callback(nodeData.key, nodeData.attributes);\n\n      if (shouldBreak)\n        break;\n    }\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const data = step.value;\n\n      return {value: [data.key, data.attributes], done: false};\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method exporting the target node.\n   *\n   * @param  {any}   node - Target node.\n   * @return {array}      - The serialized node.\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  exportNode(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.exportNode: could not find the \"${node}\" node in the graph.`);\n\n    return serializeNode(node, data);\n  }\n\n  /**\n   * Method exporting the target edge.\n   *\n   * @param  {any}   edge - Target edge.\n   * @return {array}      - The serialized edge.\n   *\n   * @throws {Error} - Will throw if the edge is not found.\n   */\n  exportEdge(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.exportEdge: could not find the \"${edge}\" edge in the graph.`);\n\n    return serializeEdge(edge, data);\n  }\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(key, data);\n    });\n\n    return {\n      attributes: this.getAttributes(),\n      nodes,\n      edges,\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      }\n    };\n  }\n\n  /**\n   * Method used to import a serialized node.\n   *\n   * @param  {object} data   - The serialized node.\n   * @param  {boolean} merge - Whether to merge the given node.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importNode(data, merge = false) {\n\n    // Validating\n    const error = validateSerializedNode(data);\n\n    if (error) {\n\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError('Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.');\n      if (error === 'no-key')\n        throw new InvalidArgumentsGraphError('Graph.importNode: no key provided.');\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError('Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.');\n    }\n\n    // Adding the node\n    const {key, attributes = {}} = data;\n\n    if (merge)\n      this.mergeNode(key, attributes);\n    else\n      this.addNode(key, attributes);\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized edge.\n   *\n   * @param  {object}  data  - The serialized edge.\n   * @param  {boolean} merge - Whether to merge the given edge.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importEdge(data, merge = false) {\n\n    // Validating\n    const error = validateSerializedEdge(data);\n\n    if (error) {\n\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.');\n      if (error === 'no-source')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: missing souce.');\n      if (error === 'no-target')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: missing target.');\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.');\n      if (error === 'invalid-undirected')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.');\n    }\n\n    // Adding the edge\n    const {\n      source,\n      target,\n      attributes = {},\n      undirected = false\n    } = data;\n\n    let method;\n\n    if ('key' in data) {\n      method = merge ?\n        (undirected ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey) :\n        (undirected ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey);\n\n      method.call(\n        this,\n        data.key,\n        source,\n        target,\n        attributes\n      );\n    }\n    else {\n      method = merge ?\n        (undirected ? this.mergeUndirectedEdge : this.mergeDirectedEdge) :\n        (undirected ? this.addUndirectedEdge : this.addDirectedEdge);\n\n      method.call(\n        this,\n        source,\n        target,\n        attributes\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n\n    // Importing a Graph instance\n    if (isGraph(data)) {\n\n      this.import(data.export(), merge);\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError('Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.');\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid attributes. Expecting a plain object.');\n\n      if (merge)\n        this.mergeAttributes(data.attributes);\n      else\n        this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid nodes. Expecting an array.');\n\n\n      for (i = 0, l = list.length; i < l; i++)\n        this.importNode(list[i], merge);\n    }\n\n    if (data.edges) {\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid edges. Expecting an array.');\n\n      for (i = 0, l = list.length; i < l; i++)\n        this.importEdge(list[i], merge);\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    return new Graph(assign({}, this._options, options));\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @return {Graph} - The copy.\n   */\n  copy() {\n    const graph = new Graph(this._options);\n    graph.import(this);\n\n    return graph;\n  }\n\n  /**\n   * Method upgrading the graph to a mixed one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMixed() {\n    if (this.type === 'mixed')\n      return this;\n\n    // Upgrading node data:\n    // NOTE: maybe this could lead to some de-optimization by usual\n    // JavaScript engines but I cannot be sure of it. Another solution\n    // would be to reinstantiate the classes but this surely has a performance\n    // and memory impact.\n    this._nodes.forEach(data => (data.upgradeToMixed()));\n\n    // Mutating the options & the instance\n    this._options.type = 'mixed';\n    readOnlyProperty(this, 'type', this._options.type);\n    privateProperty(this, 'NodeDataClass', MixedNodeData);\n\n    return this;\n  }\n\n  /**\n   * Method upgrading the graph to a multi one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMulti() {\n    if (this.multi)\n      return this;\n\n    // Mutating the options & the instance\n    this._options.multi = true;\n    readOnlyProperty(this, 'multi', true);\n\n    // Upgrading indices\n    upgradeStructureIndexToMulti(this);\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Indexes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to clear the desired index to clear memory.\n   *\n   * @return {Graph}       - Returns itself for chaining.\n   */\n  clearIndex() {\n    clearStructureIndex(this);\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n          multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      const desc = `(${data.source.key})${direction}(${data.target.key})`;\n\n      if (!data.generatedKey) {\n        label += `[${key}]: `;\n      }\n      else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        }\n        else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (this.hasOwnProperty(k) &&\n          !EMITTER_PROPS.has(k) &&\n          typeof this[k] !== 'function')\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] = Graph.prototype.inspect;\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb),\n          fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function(source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n    else {\n      Graph.prototype[name] = function(edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Self iterator.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.iterator] = Graph.prototype.adjacency;\n\n/**\n * Attributes-related.\n */\nattachAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError('DirectedGraph.from: inconsistent indication that the graph should be multi in given options!');\n\n    if (finalOptions.type !== 'directed')\n    throw new InvalidArgumentsGraphError('DirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError('UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!');\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError('UndirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError('MultiGraph.from: inconsistent indication that the graph should be simple in given options!');\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError('MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!');\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError('MultiDirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError('MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!');\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError('MultiUndirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function(data, options) {\n\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n","/**\n * Graphology CommonJS Endoint\n * ============================\n *\n * Endpoint for CommonJS modules consumers.\n */\nimport {Graph} from './classes';\n\nexport default Graph;\n"],"names":["assignPolyfill","target","arguments","i","l","length","k","assign","Object","getMatchingEdge","graph","source","type","sourceData","_nodes","get","edge","out","undirected","isGraph","value","addUndirectedEdgeWithKey","dropNode","isPlainObject","constructor","isEmpty","o","privateProperty","name","defineProperty","enumerable","configurable","writable","readOnlyProperty","descriptor","validateHints","hints","attributes","Array","isArray","incrementalId","GraphError","message","data","Error","InvalidArgumentsGraphError","captureStackTrace","prototype","NotFoundGraphError","UsageGraphError","MixedNodeData","key","inDegree","outDegree","undirectedDegree","directedSelfLoops","undirectedSelfLoops","DirectedNodeData","upgradeToMixed","UndirectedNodeData","EdgeData","generatedKey","updateStructureIndex","edgeData","targetData","multi","outKey","inKey","adj","container","Set","add","clearEdgeFromStructureIndex","sourceIndex","set","size","targetIndex","clearStructureIndex","forEach","upgradeStructureIndexToMulti","node","neighbor","edges","attachAttributeGetter","Class","method","element","_edges","attachAttributesGetter","attachAttributeChecker","hasOwnProperty","attachAttributeSetter","emit","attachAttributeUpdater","updater","attachAttributeRemover","attachAttributesReplacer","attachAttributesMerger","ATTRIBUTES_METHODS","attacher","attachAttributesMethods","Graph","EDGES_ITERATION","direction","collectSimple","object","push","collectMulti","forEachSimple","callback","avoid","forEachMulti","forEachSimpleUntil","shouldBreak","forEachMultiUntil","iterator","step","values","next","done","createIterator","keys","inner","Iterator","collectForKeySimple","collectForKeyMulti","edgesData","forEachForKeySimple","forEachForKeyMulti","forEachForKeySimpleUntil","forEachForKeyMultiUntil","createIteratorForKey","v","of","createEdgeArray","from","take","undirectedSize","directedSize","list","mask","forEachEdge","shouldFilter","forEachEdgeUntil","createEdgeIterator","empty","createEdgeArrayForNode","nodeData","fn","splice","lastIndexOf","forEachEdgeForNode","forEachEdgeForNodeUntil","createEdgeIteratorForNode","chain","createEdgeArrayForPath","forEachEdgeForPath","forEachEdgeForPathUntil","createEdgeIteratorForPath","attachEdgeArrayCreator","description","has","attachForEachEdge","forEachName","toUpperCase","slice","attachForEachEdgeUntil","forEachUntilName","attachEdgeIteratorCreator","originalName","attachEdgeIterationMethods","NEIGHBORS_ITERATION","merge","neighbors","createNeighborArrayForNode","forEachInObject","neighborData","forEachInObjectOnce","visited","forEachInObjectUntil","forEachInObjectOnceUntil","forEachNeighborForNode","forEachNeighborForNodeUntil","createObjectIterator","createDedupedObjectIterator","createNeighborIterator","nodeHasNeighbor","attachNeighborArrayCreator","node1","node2","attachForEachNeighbor","attachForEachNeighborUntil","attachNeighborIteratorCreator","iteratorName","attachNeighborIterationMethods","forEachAdjacencySimple","breakable","forEachAdjacencyMulti","containerStep","createAdjacencyIteratorSimple","state","offset","createAdjacencyIteratorMulti","serializeNode","serialized","serializeEdge","validateSerializedNode","validateSerializedEdge","TYPES","EMITTER_PROPS","EDGE_ADD_METHODS","verb","generateKey","DEFAULTS","allowSelfLoops","edgeKeyGenerator","addNode","NodeDataClass","unsafeAddNode","addEdge","mustGenerateKey","eventData","_edgeKeyGenerator","_undirectedSelfLoopCount","_directedSelfLoopCount","_undirectedSize","_directedSize","mergeEdge","asUpdater","undefined","alreadyExistingEdgeData","oldAttributes","options","Map","prop","_options","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undirectedEdge","selfLoops","loops","directedDegree","degree","extremities","opposite","hasExtremity","isUndirected","isDirected","isSelfLoop","hasGeneratedKey","mergeNode","updateNode","dropEdge","clear","clearEdges","clearIndex","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","getNodeAttribute","getNodeAttributes","hasNodeAttribute","setNodeAttribute","updateNodeAttribute","removeNodeAttribute","replaceNodeAttributes","mergeNodeAttributes","updateEachNodeAttributes","updateEachEdgeAttributes","forEachUntil","adjacency","nodes","forEachNode","forEachNodeUntil","nodeEntries","exportNode","exportEdge","importNode","error","importEdge","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addDirectedEdgeWithKey","call","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","nullCopy","emptyCopy","copy","upgradeToMulti","toJSON","toString","inspect","multiIndex","label","desc","dummy","EventEmitter","Symbol","DirectedGraph","finalOptions","UndirectedGraph","MultiGraph","MultiDirectedGraph","MultiUndirectedGraph","attachStaticFromMethod","instance"],"mappings":"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"}