{
  "manifest": {
    "name": "tsconfig-paths",
    "version": "3.9.0",
    "description": "Load node modules according to tsconfig paths, in run-time or via API.",
    "main": "lib/index.js",
    "types": "lib/index",
    "author": {
      "name": "Jonas Kello"
    },
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/dividab/tsconfig-paths"
    },
    "devDependencies": {
      "@types/chai": "^4.1.4",
      "@types/minimist": "^1.2.0",
      "@types/mocha": "^5.2.3",
      "@types/node": "^6.0.54",
      "@types/strip-bom": "^3.0.0",
      "@types/strip-json-comments": "^0.0.30",
      "chai": "^4.1.2",
      "codecov": "^3.1.0",
      "husky": "^0.14.3",
      "lint-staged": "^4.3.0",
      "mocha": "^5.2.0",
      "nyc": "^11.4.1",
      "prettier": "1.7.4",
      "rimraf": "^2.6.2",
      "shelljs": "^0.7.5",
      "ts-node": "^7.0.0",
      "tslint": "^5.8.0",
      "typescript": "^2.4.1"
    },
    "dependencies": {
      "@types/json5": "^0.0.29",
      "json5": "^1.0.1",
      "minimist": "^1.2.0",
      "strip-bom": "^3.0.0"
    },
    "scripts": {
      "start": "cd src && ts-node index.ts",
      "example:node": "yarn build && cd ./example/node && ts-node -r ../register.js main.ts",
      "example:project": "yarn build && ts-node -r ./register.js -P ./example/project/tsconfig.json ./example/project/main.ts",
      "example:api": "cd example/api && ts-node main.ts",
      "example:perf": "cd example/perf && ts-node main.ts",
      "test": "mocha",
      "build": "rimraf lib && tsc -p src",
      "build:test": "rimraf ./test/js_out && tsc -p test",
      "lint": "tslint './{src,tests}/**/*.ts{,x}'",
      "verify": "yarn build && yarn lint && yarn coverage",
      "coverage": "rimraf coverage .nyc_output && nyc yarn test",
      "report-coverage": "codecov -f coverage/*.json",
      "precommit": "lint-staged",
      "publish:major": "yarn build && node scripts/publish.js major",
      "publish:minor": "yarn build && node scripts/publish.js minor",
      "publish:patch": "yarn build && node scripts/publish.js patch",
      "preversion": "yarn verify",
      "postversion": "git push --tags && yarn publish --new-version $npm_package_version && git push && echo \"Successfully released version $npm_package_version!\""
    },
    "lint-staged": {
      "*.ts": [
        "tslint",
        "prettier --write",
        "git add"
      ]
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-tsconfig-paths-3.9.0-098547a6c4448807e8fcb8eae081064ee9a3c90b-integrity/node_modules/tsconfig-paths/package.json",
    "readmeFilename": "README.md",
    "readme": "# tsconfig-paths\n\n[![npm version][version-image]][version-url]\n[![travis build][travis-image]][travis-url]\n[![Coverage Status][codecov-image]][codecov-url]\n[![MIT license][license-image]][license-url]\n[![code style: prettier][prettier-image]][prettier-url]\n\nUse this to load modules whose location is specified in the `paths` section of `tsconfig.json`. Both loading at run-time and via API are supported.\n\nTypescript by default mimics the Node.js runtime resolution strategy of modules. But it also allows the use of [path mapping](https://www.typescriptlang.org/docs/handbook/module-resolution.html) which allows arbitrary module paths (that doesn't start with \"/\" or \".\") to be specified and mapped to physical paths in the filesystem. The typescript compiler can resolve these paths from `tsconfig` so it will compile OK. But if you then try to execute the compiled files with node (or ts-node), it will only look in the `node_modules` folders all the way up to the root of the filesystem and thus will not find the modules specified by `paths` in `tsconfig`.\n\nIf you require this package's `tsconfig-paths/register` module it will read the `paths` from `tsconfig.json` and convert node's module loading calls into to physcial file paths that node can load.\n\n## How to install\n\n```\nyarn add --dev tsconfig-paths\n```\n\nor\n\n```\nnpm install --save-dev tsconfig-paths\n```\n\n## How to use\n\n### With node\n\n`node -r tsconfig-paths/register main.js`\n\n### With ts-node\n\n`ts-node -r tsconfig-paths/register main.ts`\n\nIf `process.env.TS_NODE_PROJECT` is set it will be used to resolved tsconfig.json\n\n### With webpack\n\nFor webpack please use the [tsconfig-paths-webpack-plugin](https://github.com/dividab/tsconfig-paths-webpack-plugin).\n\n### With mocha and ts-node\n\nAs of Mocha >= 4.0.0 the `--compiler` was [deprecated](https://github.com/mochajs/mocha/wiki/compilers-deprecation). Instead `--require` should be used. You also have to specify a glob that includes `.ts` files because mocha looks after files with `.js` extension by default.\n\n```bash\nmocha -r ts-node/register -r tsconfig-paths/register \"test/**/*.ts\"\n```\n\n### With other commands\n\nAs long as the command has something similar to a `--require` option that can load a module before it starts, tsconfig-paths should be able to work with it.\n\n## Bootstraping with explicit params\n\nIf you want more granular control over tsconfig-paths you can bootstrap it. This can be useful if you for instance have compiled with `tsc` to another directory where `tsconfig.json` doesn't exists.\n\n```javascript\nconst tsConfig = require(\"./tsconfig.json\");\nconst tsConfigPaths = require(\"tsconfig-paths\");\n\nconst baseUrl = \"./\"; // Either absolute or relative path. If relative it's resolved to current working directory.\nconst cleanup = tsConfigPaths.register({\n  baseUrl,\n  paths: tsConfig.compilerOptions.paths\n});\n\n// When path registration is no longer needed\ncleanup();\n```\n\nThen run with:\n\n`node -r ./tsconfig-paths-bootstrap.js main.js`\n\n## Configuration Options\n\nYou can set options by passing them before the script path, via programmatic usage or via environment variables.\n\n```bash\nts-node --project customLocation/tsconfig.json -r tsconfig-paths/register \"test/**/*.ts\"\n```\n\n### CLI and Programmatic Options\n\n_Environment variable denoted in parentheses._\n\n- `-P, --project [path]` Path to TypeScript JSON project file (`TS_NODE_PROJECT`)\n\n## Config loading process\n\n1.  Use explicit params passed to register\n2.  Use `process.env.TS_NODE_PROJECT` to resolve tsConfig.json and the specified baseUrl and paths.\n3.  Resolves tsconfig.json from current working directory and the specified baseUrl and paths.\n\n## Programmatic use\n\nThe public API consists of these functions:\n\n- [register](#register)\n- [loadConfig](#loadConfig)\n- [createMatchPath](#createMatchPath) / [createMatchPathAsync](#createMatchPathAsync)\n- [matchFromAbsolutePaths](#matchFromAbsolutePaths) / [matchFromAbsolutePathsAsync](#matchFromAbsolutePathsAsync)\n\n### register\n\n```typescript\nexport interface ExplicitParams {\n  baseUrl: string;\n  paths: { [key: string]: Array<string> };\n  mainFields?: Array<string>;\n  addMatchAll?: boolean;\n}\n\n/**\n * Installs a custom module load function that can adhere to paths in tsconfig.\n */\nexport function register(explicitParams: ExplicitParams): () => void;\n```\n\nThis function will patch the node's module loading so it will look for modules in paths specified by tsconfig.json.\nA function is returned for you to reinstate Node's original module loading.\n\n### loadConfig\n\n```typescript\nexport function loadConfig(cwd: string = process.cwd()): ConfigLoaderResult;\n\nexport type ConfigLoaderResult =\n  | ConfigLoaderSuccessResult\n  | ConfigLoaderFailResult;\n\nexport interface ConfigLoaderSuccessResult {\n  resultType: \"success\";\n  absoluteBaseUrl: string;\n  paths: { [key: string]: Array<string> };\n}\n\nexport interface ConfigLoaderFailResult {\n  resultType: \"failed\";\n  message: string;\n}\n```\n\nThis function loads the tsconfig.json. It will start searching from the specified `cwd` directory. Passing the tsconfig.json file directly instead of a directory also works.\n\n### createMatchPath\n\n```typescript\n/**\n * Function that can match a path\n */\nexport interface MatchPath {\n  (\n    requestedModule: string,\n    readJson?: Filesystem.ReadJsonSync,\n    fileExists?: (name: string) => boolean,\n    extensions?: ReadonlyArray<string>\n  ): string | undefined;\n}\n\n/**\n * Creates a function that can resolve paths according to tsconfig paths property.\n * @param absoluteBaseUrl Absolute version of baseUrl as specified in tsconfig.\n * @param paths The paths as specified in tsconfig.\n * @param mainFields A list of package.json field names to try when resolving module files.\n * @param addMatchAll Add a match-all \"*\" rule if none is present\n * @returns a function that can resolve paths.\n */\nexport function createMatchPath(\n  absoluteBaseUrl: string,\n  paths: { [key: string]: Array<string> },\n  mainFields: string[] = [\"main\"],\n  addMatchAll: boolean = true\n): MatchPath {\n```\n\nThe `createMatchPath` function will create a function that can match paths. It accepts `baseUrl` and `paths` directly as they are specified in tsconfig and will handle resolving paths to absolute form. The created function has the signare specified by the type `MatchPath` above.\n\n### matchFromAbsolutePaths\n\n```typescript\n/**\n * Finds a path from tsconfig that matches a module load request.\n * @param absolutePathMappings The paths to try as specified in tsconfig but resolved to absolute form.\n * @param requestedModule The required module name.\n * @param readJson Function that can read json from a path (useful for testing).\n * @param fileExists Function that checks for existance of a file at a path (useful for testing).\n * @param extensions File extensions to probe for (useful for testing).\n * @param mainFields A list of package.json field names to try when resolving module files.\n * @returns the found path, or undefined if no path was found.\n */\nexport function matchFromAbsolutePaths(\n  absolutePathMappings: ReadonlyArray<MappingEntry.MappingEntry>,\n  requestedModule: string,\n  readJson: Filesystem.ReadJsonSync = Filesystem.readJsonFromDiskSync,\n  fileExists: Filesystem.FileExistsSync = Filesystem.fileExistsSync,\n  extensions: Array<string> = Object.keys(require.extensions),\n  mainFields: string[] = [\"main\"]\n): string | undefined {\n```\n\nThis function is lower level and requries that the paths as already been resolved to absolute form and sorted in correct order into an array.\n\n### createMatchPathAsync\n\nThis is the async version of `createMatchPath`. It has the same signature but with a callback parameter for the result.\n\n### matchFromAbsolutePathsAsync\n\nThis is the async version of `matchFromAbsolutePaths`. It has the same signature but with a callback parameter for the result.\n\n## How to publish\n\n```\nyarn version --patch\nyarn version --minor\nyarn version --major\n```\n\n[version-image]: https://img.shields.io/npm/v/tsconfig-paths.svg?style=flat\n[version-url]: https://www.npmjs.com/package/tsconfig-paths\n[travis-image]: https://travis-ci.com/dividab/tsconfig-paths.svg?branch=master&style=flat\n[travis-url]: https://travis-ci.com/dividab/tsconfig-paths\n[codecov-image]: https://codecov.io/gh/dividab/tsconfig-paths/branch/master/graph/badge.svg\n[codecov-url]: https://codecov.io/gh/dividab/tsconfig-paths\n[license-image]: https://img.shields.io/github/license/dividab/tsconfig-paths.svg?style=flat\n[license-url]: https://opensource.org/licenses/MIT\n[prettier-image]: https://img.shields.io/badge/code_style-prettier-ff69b4.svg\n[prettier-url]: https://github.com/prettier/prettier\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2016 Jonas Kello\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/tsconfig-paths/-/tsconfig-paths-3.9.0.tgz#098547a6c4448807e8fcb8eae081064ee9a3c90b",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/tsconfig-paths/-/tsconfig-paths-3.9.0.tgz",
    "hash": "098547a6c4448807e8fcb8eae081064ee9a3c90b",
    "integrity": "sha512-dRcuzokWhajtZWkQsDVKbWyY+jgcLC5sqJhg2PSgf4ZkH2aHPvaOY8YWGhmjb68b5qqTfasSsDO9k7RUiEmZAw==",
    "registry": "npm",
    "packageName": "tsconfig-paths",
    "cacheIntegrity": "sha512-dRcuzokWhajtZWkQsDVKbWyY+jgcLC5sqJhg2PSgf4ZkH2aHPvaOY8YWGhmjb68b5qqTfasSsDO9k7RUiEmZAw== sha1-CYVHpsREiAfo/Ljq4IEGTumjyQs="
  },
  "registry": "npm",
  "hash": "098547a6c4448807e8fcb8eae081064ee9a3c90b"
}