"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IcnsImage = exports.BitmapBuilder = void 0;
const pngjs_1 = require("pngjs");
const packbits_1 = require("@fiahfy/packbits");
const icns_1 = require("./icns");
class BitmapBuilder {
    constructor(png, osType, format) {
        this.png = png;
        this.osType = osType;
        this.format = format;
    }
    build() {
        switch (this.format) {
            case 'MASK':
                return this.mask;
            case 'RGB':
                return this.rgb;
            case 'ARGB':
                return this.argb;
            default:
                return undefined;
        }
    }
    get mask() {
        return this.getChannel(3);
    }
    get rgb() {
        // the "it32" data seams to be offset by 4 bytes
        // @see https://gist.github.com/raweden/1065894#file-icnsencoder-as-L63
        const offset = this.osType === 'it32' ? 4 : 0;
        const header = Buffer.alloc(offset);
        return Buffer.concat([
            header,
            packbits_1.encode(this.getChannel(0), { format: 'icns' }),
            packbits_1.encode(this.getChannel(1), { format: 'icns' }),
            packbits_1.encode(this.getChannel(2), { format: 'icns' }),
        ]);
    }
    get argb() {
        const header = Buffer.alloc(4);
        header.write('ARGB', 0, 4, 'ascii');
        return Buffer.concat([
            header,
            packbits_1.encode(this.getChannel(3), { format: 'icns' }),
            packbits_1.encode(this.getChannel(0), { format: 'icns' }),
            packbits_1.encode(this.getChannel(1), { format: 'icns' }),
            packbits_1.encode(this.getChannel(2), { format: 'icns' }),
        ]);
    }
    getChannel(index) {
        const data = [];
        for (let i = 0; i < this.png.data.length; i += 4) {
            data.push(this.png.data.slice(index + i, index + i + 1));
        }
        return Buffer.concat(data);
    }
}
exports.BitmapBuilder = BitmapBuilder;
class IcnsImage {
    constructor(osType = 'ic10', bytes = 8, image = Buffer.alloc(0)) {
        this.osType = osType;
        this.bytes = bytes;
        this.image = image;
    }
    /**
     * Create ICNS image from the buffer.
     * @param buffer The ICNS image buffer.
     */
    static from(buffer) {
        const osType = buffer.toString('ascii', 0, 4);
        const bytes = buffer.readUInt32BE(4);
        const image = buffer.slice(8, bytes);
        return new IcnsImage(osType, bytes, image);
    }
    /**
     * Create ICNS Image from the PNG image buffer.
     * @param buffer The PNG image buffer.
     * @param osType The icon OSType.
     */
    static fromPNG(buffer, osType) {
        const iconType = icns_1.Icns.supportedIconTypes.find((iconType) => iconType.osType === osType);
        if (!iconType) {
            throw new TypeError('No supported osType');
        }
        const png = IcnsImage.readPNG(buffer);
        if (!png) {
            throw new TypeError('Image must be PNG format');
        }
        const width = png.width;
        const height = png.height;
        if (width !== height) {
            throw new TypeError('Image must be squre');
        }
        if (width !== iconType.size) {
            throw new TypeError(`Image size must be ${iconType.size}x${iconType.size} for '${osType}'`);
        }
        const image = iconType.format === 'PNG'
            ? buffer
            : new BitmapBuilder(png, osType, iconType.format).build();
        if (!image) {
            throw new TypeError(`Invalid format '${iconType.format}'`);
        }
        const bytes = 8 + image.length;
        return new IcnsImage(osType, bytes, image);
    }
    get data() {
        const buffer = Buffer.alloc(8);
        buffer.write(this.osType, 0, 4, 'ascii');
        buffer.writeUInt32BE(this.bytes, 4);
        return Buffer.concat([buffer, this.image]);
    }
    static readPNG(buffer) {
        try {
            return pngjs_1.PNG.sync.read(buffer);
        }
        catch (e) {
            return undefined;
        }
    }
}
exports.IcnsImage = IcnsImage;
