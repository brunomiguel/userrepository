import l from"path";import{fileURLToPath as g,pathToFileURL as W}from"url";import{installSourceMapSupport as v,compareNodeVersion as w,resolveTsPath as D,transform as P,transformDynamicImport as k}from"@esbuild-kit/core-utils";import{parseTsconfig as F,getTsconfig as A,createPathsMatcher as I}from"get-tsconfig";import T from"fs";const f=v(),u=process.env.ESBK_TSCONFIG_PATH?{path:process.env.ESBK_TSCONFIG_PATH,config:F(process.env.ESBK_TSCONFIG_PATH)}:A(),E=u==null?void 0:u.config,S=u&&I(u),y=/\.([cm]?ts|[tj]sx)$/,j=t=>{const s=l.extname(t);if(s===".mjs"||s===".mts")return"module";if(s===".cjs"||s===".cts")return"commonjs"},d=new Map;async function L(t){if(d.has(t))return d.get(t);if(!await T.promises.access(t).then(()=>!0,()=>!1)){d.set(t,void 0);return}const o=await T.promises.readFile(t,"utf8");try{const n=JSON.parse(o);return d.set(t,n),n}catch{throw new Error(`Error parsing: ${t}`)}}async function M(t){let s=new URL("package.json",t);for(;!s.pathname.endsWith("/node_modules/package.json");){const o=g(s),n=await L(o);if(n)return n;const r=s;if(s=new URL("../package.json",s),s.pathname===r.pathname)break}}async function O(t){var s;const o=await M(t);return(s=o==null?void 0:o.type)!=null?s:"commonjs"}const x=[".js",".json",".ts",".tsx",".jsx"];async function U(t,s,o){let n;for(const r of x)try{return await h(t+r,s,o,!0)}catch(a){if(n===void 0){const{message:c}=a;a.message=a.message.replace(`${r}'`,"'"),a.stack=a.stack.replace(c,a.message),n=a}}throw n}async function N(t,s,o){const n=t.endsWith("/")?"index":"/index";try{return await U(t+n,s,o)}catch(r){const{message:a}=r;throw r.message=r.message.replace(`${n.replace("/",l.sep)}'`,"'"),r.stack=r.stack.replace(a,r.message),r}}const R="file://",b=/^\.{0,2}\//,C=w([14,13,1])>=0||w([12,20,0])>=0,h=async function(t,s,o,n){var r,a;if(!C&&t.startsWith("node:")&&(t=t.slice(5)),t.endsWith("/"))return await N(t,s,o);const c=t.startsWith(R)||b.test(t);if(S&&!c&&!((r=s.parentURL)!=null&&r.includes("/node_modules/"))){const i=S(t);for(const p of i)try{return await h(W(p).toString(),s,o)}catch{}}if(y.test(s.parentURL)){const i=D(t);if(i)try{return await h(i,s,o,!0)}catch(p){const{code:_}=p;if(_!=="ERR_MODULE_NOT_FOUND"&&_!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw p}}let e;try{e=await o(t,s,o)}catch(i){if(i instanceof Error&&!n){if(i.code==="ERR_UNSUPPORTED_DIR_IMPORT")return await N(t,s,o);if(i.code==="ERR_MODULE_NOT_FOUND")return await U(t,s,o)}throw i}if(e.url.endsWith(".json"))return{...e,format:"json"};let{format:m}=e;return e.url.startsWith(R)&&(m=(a=j(e.url))!=null?a:m,m||(m=await O(e.url))),{...e,format:m}},H=async function(t,s,o){process.send&&process.send({type:"dependency",path:t}),t.endsWith(".json")&&(s.importAssertions||(s.importAssertions={}),s.importAssertions.type="json");const n=await o(t,s,o);if(!n.source)return n;const r=g(t),a=n.source.toString();if(n.format==="json"||y.test(t)){const e=await P(a,r,{tsconfigRaw:E});return{format:"module",source:f(e,t)}}const c=k(r,a);return c&&(n.source=f(c,t)),n},K=async function(t,s,o){var n;return t.endsWith(".json")?{format:"module"}:t.startsWith("file:")?{format:(n=j(t))!=null?n:await O(t)}:await o(t,s,o)},$=async function(t,s,o){const{url:n}=s,r=g(n);if(process.send&&process.send({type:"dependency",path:n}),n.endsWith(".json")||y.test(n)){const e=await P(t.toString(),r,{tsconfigRaw:E});return{source:f(e,n)}}const a=await o(t,s,o),c=k(r,a.source.toString());return c&&(a.source=f(c,n)),a},J=w([16,12,0])<0,B=J?K:void 0,G=J?$:void 0;export{B as getFormat,H as load,h as resolve,G as transformSource};
