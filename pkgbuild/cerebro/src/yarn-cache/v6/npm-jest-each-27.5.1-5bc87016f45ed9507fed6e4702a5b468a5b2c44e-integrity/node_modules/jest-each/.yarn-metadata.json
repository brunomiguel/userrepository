{
  "manifest": {
    "name": "jest-each",
    "version": "27.5.1",
    "description": "Parameterised tests for Jest",
    "main": "./build/index.js",
    "types": "./build/index.d.ts",
    "exports": {
      ".": {
        "types": "./build/index.d.ts",
        "default": "./build/index.js"
      },
      "./package.json": "./package.json"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/facebook/jest.git",
      "directory": "packages/jest-each"
    },
    "keywords": [
      "jest",
      "parameterised",
      "test",
      "each"
    ],
    "author": {
      "name": "Matt Phillips",
      "url": "mattphillips"
    },
    "license": "MIT",
    "dependencies": {
      "@jest/types": "^27.5.1",
      "chalk": "^4.0.0",
      "jest-get-type": "^27.5.1",
      "jest-util": "^27.5.1",
      "pretty-format": "^27.5.1"
    },
    "engines": {
      "node": "^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"
    },
    "publishConfig": {
      "access": "public"
    },
    "gitHead": "67c1aa20c5fec31366d733e901fee2b981cb1850",
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-jest-each-27.5.1-5bc87016f45ed9507fed6e4702a5b468a5b2c44e-integrity/node_modules/jest-each/package.json",
    "readmeFilename": "README.md",
    "readme": "<div align=\"center\">\n  <h1>jest-each</h1>\n  Jest Parameterised Testing\n</div>\n\n<hr />\n\n[![version](https://img.shields.io/npm/v/jest-each.svg?style=flat-square)](https://www.npmjs.com/package/jest-each) [![downloads](https://img.shields.io/npm/dm/jest-each.svg?style=flat-square)](http://npm-stat.com/charts.html?package=jest-each&from=2017-03-21) [![MIT License](https://img.shields.io/npm/l/jest-each.svg?style=flat-square)](https://github.com/facebook/jest/blob/main/LICENSE)\n\nA parameterised testing library for [Jest](https://jestjs.io/) inspired by [mocha-each](https://github.com/ryym/mocha-each).\n\njest-each allows you to provide multiple arguments to your `test`/`describe` which results in the test/suite being run once per row of parameters.\n\n## Features\n\n- `.test` to runs multiple tests with parameterised data\n  - Also under the alias: `.it`\n- `.test.only` to only run the parameterised tests\n  - Also under the aliases: `.it.only` or `.fit`\n- `.test.skip` to skip the parameterised tests\n  - Also under the aliases: `.it.skip` or `.xit` or `.xtest`\n- `.test.concurrent`\n  - Also under the alias: `.it.concurrent`\n- `.test.concurrent.only`\n  - Also under the alias: `.it.concurrent.only`\n- `.test.concurrent.skip`\n  - Also under the alias: `.it.concurrent.skip`\n- `.describe` to runs test suites with parameterised data\n- `.describe.only` to only run the parameterised suite of tests\n  - Also under the aliases: `.fdescribe`\n- `.describe.skip` to skip the parameterised suite of tests\n  - Also under the aliases: `.xdescribe`\n- Asynchronous tests with `done`\n- Unique test titles with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):\n  - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).\n  - `%s`- String.\n  - `%d`- Number.\n  - `%i` - Integer.\n  - `%f` - Floating point value.\n  - `%j` - JSON.\n  - `%o` - Object.\n  - `%#` - Index of the test case.\n  - `%%` - single percent sign ('%'). This does not consume an argument.\n- Unique test titles by injecting properties of test case object\n- ðŸ–– Spock like data tables with [Tagged Template Literals](#tagged-template-literal-of-rows)\n\n---\n\n- [Demo](#demo)\n- [Installation](#installation)\n- [Importing](#importing)\n- APIs\n  - [Array of Rows](#array-of-rows)\n    - [Usage](#usage)\n  - [Tagged Template Literal of rows](#tagged-template-literal-of-rows)\n    - [Usage](#usage-1)\n\n## Demo\n\n#### Tests without jest-each\n\n![Current jest tests](assets/default-demo.gif)\n\n#### Tests can be re-written with jest-each to:\n\n**`.test`**\n\n![Current jest tests](assets/test-demo.gif)\n\n**`.test` with Tagged Template Literals**\n\n![Current jest tests](assets/tagged-template-literal.gif)\n\n**`.describe`**\n\n![Current jest tests](assets/describe-demo.gif)\n\n## Installation\n\n`npm i --save-dev jest-each`\n\n`yarn add -D jest-each`\n\n## Importing\n\njest-each is a default export so it can be imported with whatever name you like.\n\n```js\n// es6\nimport each from 'jest-each';\n```\n\n```js\n// es5\nconst each = require('jest-each').default;\n```\n\n## Array of rows\n\n### API\n\n#### `each([parameters]).test(name, testFn)`\n\n##### `each`:\n\n- parameters: `Array` of Arrays with the arguments that are passed into the `testFn` for each row\n  - _Note_ If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. `[1, 2, 3] -> [[1], [2], [3]]`\n\n##### `.test`:\n\n- name: `String` the title of the `test`.\n  - Generate unique test titles by positionally injecting parameters with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):\n    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).\n    - `%s`- String.\n    - `%d`- Number.\n    - `%i` - Integer.\n    - `%f` - Floating point value.\n    - `%j` - JSON.\n    - `%o` - Object.\n    - `%#` - Index of the test case.\n    - `%%` - single percent sign ('%'). This does not consume an argument.\n  - Or generate unique test titles by injecting properties of test case object with `$variable`\n    - To inject nested object values use you can supply a keyPath i.e. `$variable.path.to.value`\n    - You can use `$#` to inject the index of the test case\n    - You cannot use `$variable` with the `printf` formatting except for `%%`\n- testFn: `Function` the test logic, this is the function that will receive the parameters of each row as function arguments\n\n#### `each([parameters]).describe(name, suiteFn)`\n\n##### `each`:\n\n- parameters: `Array` of Arrays with the arguments that are passed into the `suiteFn` for each row\n  - _Note_ If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. `[1, 2, 3] -> [[1], [2], [3]]`\n\n##### `.describe`:\n\n- name: `String` the title of the `describe`\n  - Generate unique test titles by positionally injecting parameters with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):\n    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).\n    - `%s`- String.\n    - `%d`- Number.\n    - `%i` - Integer.\n    - `%f` - Floating point value.\n    - `%j` - JSON.\n    - `%o` - Object.\n    - `%#` - Index of the test case.\n    - `%%` - single percent sign ('%'). This does not consume an argument.\n  - Or generate unique test titles by injecting properties of test case object with `$variable`\n    - To inject nested object values use you can supply a keyPath i.e. `$variable.path.to.value`\n    - You can use `$#` to inject the index of the test case\n    - You cannot use `$variable` with the `printf` formatting except for `%%`\n- suiteFn: `Function` the suite of `test`/`it`s to be ran, this is the function that will receive the parameters in each row as function arguments\n\n### Usage\n\n#### `.test(name, fn)`\n\nAlias: `.it(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).test('returns the result of adding %d to %d', (a, b, expected) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n```js\neach([\n  {a: 1, b: 1, expected: 2},\n  {a: 1, b: 2, expected: 3},\n  {a: 2, b: 1, expected: 3},\n]).test('returns the result of adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### `.test.only(name, fn)`\n\nAliases: `.it.only(name, fn)` or `.fit(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).test.only('returns the result of adding %d to %d', (a, b, expected) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### `.test.skip(name, fn)`\n\nAliases: `.it.skip(name, fn)` or `.xit(name, fn)` or `.xtest(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).test.skip('returns the result of adding %d to %d', (a, b, expected) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### `.test.concurrent(name, fn)`\n\nAliases: `.it.concurrent(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).test.concurrent(\n  'returns the result of adding %d to %d',\n  (a, b, expected) => {\n    expect(a + b).toBe(expected);\n  },\n);\n```\n\n#### `.test.concurrent.only(name, fn)`\n\nAliases: `.it.concurrent.only(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).test.concurrent.only(\n  'returns the result of adding %d to %d',\n  (a, b, expected) => {\n    expect(a + b).toBe(expected);\n  },\n);\n```\n\n#### `.test.concurrent.skip(name, fn)`\n\nAliases: `.it.concurrent.skip(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).test.concurrent.skip(\n  'returns the result of adding %d to %d',\n  (a, b, expected) => {\n    expect(a + b).toBe(expected);\n  },\n);\n```\n\n#### Asynchronous `.test(name, fn(done))`\n\nAlias: `.it(name, fn(done))`\n\n```js\neach([['hello'], ['mr'], ['spy']]).test(\n  'gives 007 secret message: %s',\n  (str, done) => {\n    const asynchronousSpy = message => {\n      expect(message).toBe(str);\n      done();\n    };\n    callSomeAsynchronousFunction(asynchronousSpy)(str);\n  },\n);\n```\n\n#### `.describe(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).describe('.add(%d, %d)', (a, b, expected) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n\n  test('does not mutate first arg', () => {\n    a + b;\n    expect(a).toBe(a);\n  });\n\n  test('does not mutate second arg', () => {\n    a + b;\n    expect(b).toBe(b);\n  });\n});\n```\n\n```js\neach([\n  {a: 1, b: 1, expected: 2},\n  {a: 1, b: 2, expected: 3},\n  {a: 2, b: 1, expected: 3},\n]).describe('.add($a, $b)', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n\n  test('does not mutate first arg', () => {\n    a + b;\n    expect(a).toBe(a);\n  });\n\n  test('does not mutate second arg', () => {\n    a + b;\n    expect(b).toBe(b);\n  });\n});\n```\n\n#### `.describe.only(name, fn)`\n\nAliases: `.fdescribe(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).describe.only('.add(%d, %d)', (a, b, expected) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n});\n```\n\n#### `.describe.skip(name, fn)`\n\nAliases: `.xdescribe(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).describe.skip('.add(%d, %d)', (a, b, expected) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n});\n```\n\n---\n\n## Tagged Template Literal of rows\n\n### API\n\n#### `each[tagged template].test(name, suiteFn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n##### `each` takes a tagged template string with:\n\n- First row of variable name column headings separated with `|`\n- One or more subsequent rows of data supplied as template literal expressions using `${value}` syntax.\n\n##### `.test`:\n\n- name: `String` the title of the `test`, use `$variable` in the name string to inject test values into the test title from the tagged template expressions\n  - To inject nested object values use you can supply a keyPath i.e. `$variable.path.to.value`\n  - You can use `$#` to inject the index of the table row.\n- testFn: `Function` the test logic, this is the function that will receive the parameters of each row as function arguments\n\n#### `each[tagged template].describe(name, suiteFn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n\n  test('does not mutate first arg', () => {\n    a + b;\n    expect(a).toBe(a);\n  });\n\n  test('does not mutate second arg', () => {\n    a + b;\n    expect(b).toBe(b);\n  });\n});\n```\n\n##### `each` takes a tagged template string with:\n\n- First row of variable name column headings separated with `|`\n- One or more subsequent rows of data supplied as template literal expressions using `${value}` syntax.\n\n##### `.describe`:\n\n- name: `String` the title of the `test`, use `$variable` in the name string to inject test values into the test title from the tagged template expressions\n  - To inject nested object values use you can supply a keyPath i.e. `$variable.path.to.value`\n- suiteFn: `Function` the suite of `test`/`it`s to be ran, this is the function that will receive the parameters in each row as function arguments\n\n### Usage\n\n#### `.test(name, fn)`\n\nAlias: `.it(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### `.test.only(name, fn)`\n\nAliases: `.it.only(name, fn)` or `.fit(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test.only('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### `.test.skip(name, fn)`\n\nAliases: `.it.skip(name, fn)` or `.xit(name, fn)` or `.xtest(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test.skip('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### Asynchronous `.test(name, fn(done))`\n\nAlias: `.it(name, fn(done))`\n\n```js\neach`\n  str\n  ${'hello'}\n  ${'mr'}\n  ${'spy'}\n`.test('gives 007 secret message: $str', ({str}, done) => {\n  const asynchronousSpy = message => {\n    expect(message).toBe(str);\n    done();\n  };\n  callSomeAsynchronousFunction(asynchronousSpy)(str);\n});\n```\n\n#### `.describe(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n\n  test('does not mutate first arg', () => {\n    a + b;\n    expect(a).toBe(a);\n  });\n\n  test('does not mutate second arg', () => {\n    a + b;\n    expect(b).toBe(b);\n  });\n});\n```\n\n#### `.describe.only(name, fn)`\n\nAliases: `.fdescribe(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe.only('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n});\n```\n\n#### `.describe.skip(name, fn)`\n\nAliases: `.xdescribe(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe.skip('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n});\n```\n\n## License\n\nMIT\n",
    "licenseText": "MIT License\n\nCopyright (c) Facebook, Inc. and its affiliates.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/jest-each/-/jest-each-27.5.1.tgz#5bc87016f45ed9507fed6e4702a5b468a5b2c44e",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/jest-each/-/jest-each-27.5.1.tgz",
    "hash": "5bc87016f45ed9507fed6e4702a5b468a5b2c44e",
    "integrity": "sha512-1Ff6p+FbhT/bXQnEouYy00bkNSY7OUpfIcmdl8vZ31A1UUaurOLPA8a8BbJOF2RDUElwJhmeaV7LnagI+5UwNQ==",
    "registry": "npm",
    "packageName": "jest-each",
    "cacheIntegrity": "sha512-1Ff6p+FbhT/bXQnEouYy00bkNSY7OUpfIcmdl8vZ31A1UUaurOLPA8a8BbJOF2RDUElwJhmeaV7LnagI+5UwNQ== sha1-W8hwFvRe2VB/7W5HAqW0aKWyxE4="
  },
  "registry": "npm",
  "hash": "5bc87016f45ed9507fed6e4702a5b468a5b2c44e"
}