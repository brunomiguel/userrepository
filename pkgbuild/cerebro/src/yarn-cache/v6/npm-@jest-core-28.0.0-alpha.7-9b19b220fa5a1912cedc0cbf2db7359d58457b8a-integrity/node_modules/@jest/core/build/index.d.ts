/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import {AggregatedResult} from '@jest/test-result';
import type {ChangedFiles} from 'jest-changed-files';
import type {Config} from '@jest/types';
import type {Context} from 'jest-runtime';
import emittery = require('emittery');
import {Reporter} from '@jest/reporters';
import {Test} from '@jest/test-result';

export declare function createTestScheduler(
  globalConfig: Config.GlobalConfig,
  options: TestSchedulerOptions,
  context: TestSchedulerContext,
): Promise<TestScheduler>;

declare type Filter = (testPaths: Array<string>) => Promise<{
  filtered: Array<FilterResult>;
}>;

declare type FilterResult = {
  test: string;
  message: string;
};

export declare function getVersion(): string;

export declare function runCLI(
  argv: Config.Argv,
  projects: Array<string>,
): Promise<{
  results: AggregatedResult;
  globalConfig: Config.GlobalConfig;
}>;

declare type SearchResult = {
  noSCM?: boolean;
  stats?: Stats;
  collectCoverageFrom?: Set<string>;
  tests: Array<Test>;
  total?: number;
};

export declare class SearchSource {
  private _context;
  private _dependencyResolver;
  private _testPathCases;
  constructor(context: Context);
  private _getOrBuildDependencyResolver;
  private _filterTestPathsWithStats;
  private _getAllTestPaths;
  isTestFilePath(path: string): boolean;
  findMatchingTests(testPathPattern: string): SearchResult;
  findRelatedTests(
    allPaths: Set<string>,
    collectCoverage: boolean,
  ): Promise<SearchResult>;
  findTestsByPaths(paths: Array<string>): SearchResult;
  findRelatedTestsFromPattern(
    paths: Array<string>,
    collectCoverage: boolean,
  ): Promise<SearchResult>;
  findTestRelatedToChangedFiles(
    changedFilesInfo: ChangedFiles,
    collectCoverage: boolean,
  ): Promise<SearchResult>;
  private _getTestPaths;
  filterPathsWin32(paths: Array<string>): Array<string>;
  getTestPaths(
    globalConfig: Config.GlobalConfig,
    changedFiles?: ChangedFiles,
    filter?: Filter,
  ): Promise<SearchResult>;
  findRelatedSourcesFromTestsInChangedFiles(
    changedFilesInfo: ChangedFiles,
  ): Promise<Array<string>>;
}

declare type State = {
  interrupted: boolean;
};

declare type Stats = {
  roots: number;
  testMatch: number;
  testPathIgnorePatterns: number;
  testRegex: number;
  testPathPattern?: number;
};

declare class TestScheduler {
  private readonly _dispatcher;
  private readonly _globalConfig;
  private readonly _options;
  private readonly _context;
  constructor(
    globalConfig: Config.GlobalConfig,
    options: TestSchedulerOptions,
    context: TestSchedulerContext,
  );
  addReporter(reporter: Reporter): void;
  removeReporter(ReporterClass: Function): void;
  scheduleTests(
    tests: Array<Test>,
    watcher: TestWatcher,
  ): Promise<AggregatedResult>;
  private _partitionTests;
  private _shouldAddDefaultReporters;
  _setupReporters(): Promise<void>;
  private _setupDefaultReporters;
  private _addCustomReporters;
  /**
   * Get properties of a reporter in an object
   * to make dealing with them less painful.
   */
  private _getReporterProps;
  private _bailIfNeeded;
}

declare type TestSchedulerContext = {
  firstRun: boolean;
  previousSuccess: boolean;
  changedFiles?: Set<string>;
  sourcesRelatedToTestsInChangedFiles?: Set<string>;
};

declare type TestSchedulerOptions = {
  startRun: (globalConfig: Config.GlobalConfig) => void;
};

export declare class TestWatcher extends emittery<{
  change: State;
}> {
  state: State;
  private _isWatchMode;
  constructor({isWatchMode}: {isWatchMode: boolean});
  setState(state: State): Promise<void>;
  isInterrupted(): boolean;
  isWatchMode(): boolean;
}

export {};
