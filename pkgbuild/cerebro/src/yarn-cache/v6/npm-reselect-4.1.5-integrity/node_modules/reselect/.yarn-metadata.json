{
  "manifest": {
    "name": "reselect",
    "version": "4.1.5",
    "description": "Selectors for Redux.",
    "main": "./lib/index.js",
    "jsnext:main": "./es/index.js",
    "module": "./es/index.js",
    "types": "./es/index.d.ts",
    "unpkg": "./dist/reselect.js",
    "typesVersions": {
      "<4.2": {
        "*": [
          "./src/typesVersions/ts4.1/index.d.ts"
        ]
      }
    },
    "files": [
      "lib",
      "src",
      "dist",
      "es"
    ],
    "sideEffects": false,
    "bugs": {
      "url": "https://github.com/reduxjs/reselect/issues"
    },
    "scripts": {
      "build:commonjs": "cross-env BABEL_ENV=commonjs babel src/*.ts --ignore src/types.ts --extensions .ts --out-dir lib ",
      "build:es": "babel src/*.ts --ignore src/types.ts --extensions .ts --out-dir es",
      "build:umd": "cross-env NODE_ENV=development rollup -c -o dist/reselect.js",
      "build:umd:min": "cross-env NODE_ENV=production rollup -c -o dist/reselect.min.js",
      "build:types": "tsc",
      "build": "rimraf dist lib es && yarn build:types && yarn build:commonjs && yarn build:es && yarn build:umd && yarn build:umd:min",
      "clean": "rimraf lib dist es coverage",
      "api-types": "api-extractor run --local",
      "format": "prettier --write \"{src,test}/**/*.{js,ts}\" \"docs/**/*.md\"",
      "lint": "eslint src test",
      "prepublishOnly": "yarn build",
      "test": "jest",
      "test:cov": "jest --coverage",
      "test:typescript": "tsc --noEmit -p typescript_test/tsconfig.json"
    },
    "keywords": [
      "react",
      "redux"
    ],
    "authors": [
      "Lee Bannard",
      "Robert Binna",
      "Martijn Faassen",
      "Philip Spitzlinger"
    ],
    "repository": {
      "type": "git",
      "url": "https://github.com/reduxjs/reselect.git"
    },
    "license": "MIT",
    "devDependencies": {
      "@babel/cli": "^7.15.7",
      "@babel/core": "^7.15.8",
      "@babel/preset-env": "^7.15.8",
      "@babel/preset-typescript": "^7.15.0",
      "@babel/register": "^7.15.3",
      "@microsoft/api-extractor": "^7.18.16",
      "@reduxjs/toolkit": "^1.6.2",
      "@rollup/plugin-babel": "^5.3.0",
      "@rollup/plugin-commonjs": "^21.0.1",
      "@rollup/plugin-node-resolve": "^13.0.6",
      "@rollup/plugin-replace": "^3.0.0",
      "@types/jest": "^27.0.2",
      "@types/lodash": "^4.14.175",
      "@typescript-eslint/eslint-plugin": "5.1.0",
      "@typescript-eslint/eslint-plugin-tslint": "5.1.0",
      "@typescript-eslint/parser": "5.1.0",
      "chai": "^4.3.4",
      "codecov.io": "^0.1.6",
      "coveralls": "^3.1.1",
      "cross-env": "^7.0.3",
      "eslint": "^8.0.1",
      "eslint-plugin-react": "^7.26.1",
      "eslint-plugin-typescript": "0.14.0",
      "jest": "^27.3.1",
      "lodash.memoize": "^4.1.2",
      "memoize-one": "^6.0.0",
      "micro-memoize": "^4.0.9",
      "mkdirp": "^1.0.4",
      "mocha": "^9.1.3",
      "ncp": "^2.0.0",
      "nyc": "^15.1.0",
      "prettier": "^2.4.1",
      "react-redux": "^7.2.6",
      "rimraf": "^3.0.2",
      "rollup": "^2.58.0",
      "rollup-plugin-terser": "^7.0.2",
      "ts-jest": "27.0.7",
      "tslint": "6.1.3",
      "typescript": "^4.4.0"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-reselect-4.1.5-integrity/node_modules/reselect/package.json",
    "readmeFilename": "README.md",
    "readme": "# Reselect\n\nA library for creating memoized \"selector\" functions. Commonly used with Redux, but usable with any plain JS immutable data as well.\n\n- Selectors can compute derived data, allowing Redux to store the minimal possible state.\n- Selectors are efficient. A selector is not recomputed unless one of its arguments changes.\n- Selectors are composable. They can be used as input to other selectors.\n\nThe **Redux docs usage page on [Deriving Data with Selectors](https://redux.js.org/usage/deriving-data-selectors)** covers the purpose and motivation for selectors, why memoized selectors are useful, typical Reselect usage patterns, and using selectors with React-Redux.\n\n[![GitHub Workflow Status][build-badge]][build]\n[![npm package][npm-badge]][npm]\n[![Coveralls][coveralls-badge]][coveralls]\n\n## Installation\n\n### Redux Toolkit\n\nWhile Reselect is not exclusive to Redux, it is already included by default in [the official Redux Toolkit package](https://redux-toolkit.js.org) - no further installation needed.\n\n```js\nimport { createSelector } from '@reduxjs/toolkit'\n```\n\n### Standalone\n\nFor standalone usage, install the `reselect` package:\n\n```bash\nnpm install reselect\n\nyarn add reselect\n```\n\n## Basic Usage\n\nReselect exports a `createSelector` API, which generates memoized selector functions. `createSelector` accepts one or more \"input\" selectors, which extract values from arguments, and an \"output\" selector that receives the extracted values and should return a derived value. If the generated selector is called multiple times, the output will only be recalculated when the extracted values have changed.\n\nYou can play around with the following **example** in [this CodeSandbox](https://codesandbox.io/s/objective-waterfall-1z5y8?file=/src/index.js):\n\n```js\nimport { createSelector } from 'reselect'\n\nconst selectShopItems = state => state.shop.items\nconst selectTaxPercent = state => state.shop.taxPercent\n\nconst selectSubtotal = createSelector(selectShopItems, items =>\n  items.reduce((subtotal, item) => subtotal + item.value, 0)\n)\n\nconst selectTax = createSelector(\n  selectSubtotal,\n  selectTaxPercent,\n  (subtotal, taxPercent) => subtotal * (taxPercent / 100)\n)\n\nconst selectTotal = createSelector(\n  selectSubtotal,\n  selectTax,\n  (subtotal, tax) => ({ total: subtotal + tax })\n)\n\nconst exampleState = {\n  shop: {\n    taxPercent: 8,\n    items: [\n      { name: 'apple', value: 1.2 },\n      { name: 'orange', value: 0.95 }\n    ]\n  }\n}\n\nconsole.log(selectSubtotal(exampleState)) // 2.15\nconsole.log(selectTax(exampleState)) // 0.172\nconsole.log(selectTotal(exampleState)) // { total: 2.322 }\n```\n\n## Table of Contents\n\n- [Installation](#installation)\n  - [Redux Toolkit](#redux-toolkit)\n  - [Standalone](#standalone)\n- [Basic Usage](#basic-usage)\n- [API](#api)\n  - [createSelector(...inputSelectors | [inputSelectors], resultFunc, selectorOptions?)](#createselectorinputselectors--inputselectors-resultfunc-selectoroptions)\n  - [defaultMemoize(func, equalityCheckOrOptions = defaultEqualityCheck)](#defaultmemoizefunc-equalitycheckoroptions--defaultequalitycheck)\n  - [createSelectorCreator(memoize, ...memoizeOptions)](#createselectorcreatormemoize-memoizeoptions)\n    - [Customize `equalityCheck` for `defaultMemoize`](#customize-equalitycheck-for-defaultmemoize)\n    - [Use memoize function from Lodash for an unbounded cache](#use-memoize-function-from-lodash-for-an-unbounded-cache)\n  - [createStructuredSelector({inputSelectors}, selectorCreator = createSelector)](#createstructuredselectorinputselectors-selectorcreator--createselector)\n- [FAQ](#faq)\n  - [Q: Why isn’t my selector recomputing when the input state changes?](#q-why-isnt-my-selector-recomputing-when-the-input-state-changes)\n  - [Q: Why is my selector recomputing when the input state stays the same?](#q-why-is-my-selector-recomputing-when-the-input-state-stays-the-same)\n  - [Q: Can I use Reselect without Redux?](#q-can-i-use-reselect-without-redux)\n  - [Q: How do I create a selector that takes an argument?](#q-how-do-i-create-a-selector-that-takes-an-argument)\n  - [Q: The default memoization function is no good, can I use a different one?](#q-the-default-memoization-function-is-no-good-can-i-use-a-different-one)\n  - [Q: How do I test a selector?](#q-how-do-i-test-a-selector)\n  - [Q: Can I share a selector across multiple component instances?](#q-can-i-share-a-selector-across-multiple-component-instances)\n  - [Q: Are there TypeScript Typings?](#q-are-there-typescript-typings)\n  - [Q: How can I make a curried selector?](#q-how-can-i-make-a-curried-selector)\n- [Related Projects](#related-projects)\n  - [re-reselect](#re-reselect)\n  - [reselect-tools](#reselect-tools)\n  - [reselect-debugger](#reselect-debugger)\n- [License](#license)\n- [Prior Art and Inspiration](#prior-art-and-inspiration)\n\n## API\n\n### createSelector(...inputSelectors | [inputSelectors], resultFunc, selectorOptions?)\n\nAccepts one or more \"input selectors\" (either as separate arguments or a single array), a single \"output selector\" / \"result function\", and an optional options object, and generates a memoized selector function.\n\nWhen the selector is called, each input selector will be called with all of the provided arguments. The extracted values are then passed as separate arguments to the output selector, which should calculate and return a final result. The inputs and result are cached for later use.\n\nIf the selector is called again with the same arguments, the previously cached result is returned instead of recalculating a new result.\n\n`createSelector` determines if the value returned by an input-selector has changed between calls using reference equality (`===`). Inputs to selectors created with `createSelector` should be immutable.\n\nBy default, selectors created with `createSelector` have a cache size of 1. This means they always recalculate when the value of an input-selector changes, as a selector only stores the preceding value of each input-selector. This can be customized by passing a `selectorOptions` object with a `memoizeOptions` field containing options for the built-in `defaultMemoize` memoization function .\n\n```js\nconst selectValue = createSelector(\n  state => state.values.value1,\n  state => state.values.value2,\n  (value1, value2) => value1 + value2\n)\n\n// You can also pass an array of selectors\nconst selectTotal = createSelector(\n  [state => state.values.value1, state => state.values.value2],\n  (value1, value2) => value1 + value2\n)\n\n// Selector behavior can be customized\nconst customizedSelector = createSelector(\n  state => state.a,\n  state => state.b,\n  (a, b) => a + b,\n  {\n    // New in 4.1: Pass options through to the built-in `defaultMemoize` function\n    memoizeOptions: {\n      equalityCheck: (a, b) => a === b,\n      maxSize: 10,\n      resultEqualityCheck: shallowEqual\n    }\n  }\n)\n```\n\nSelectors are typically called with a Redux `state` value as the first argument, and the input selectors extract pieces of the `state` object for use in calculations. However, it's also common to want to pass additional arguments, such as a value to filter by. Since input selectors are given all arguments, they can extract the additional arguments and pass them to the output selector:\n\n```js\nconst selectItemsByCategory = createSelector(\n  [\n    // Usual first input - extract value from `state`\n    state => state.items,\n    // Take the second arg, `category`, and forward to the output selector\n    (state, category) => category\n  ],\n  // Output selector gets (`items, category)` as args\n  (items, category) => items.filter(item => item.category === category)\n)\n```\n\n### defaultMemoize(func, equalityCheckOrOptions = defaultEqualityCheck)\n\n`defaultMemoize` memoizes the function passed in the func parameter. It is the standard memoize function used by `createSelector`.\n\n`defaultMemoize` has a default cache size of 1. This means it always recalculates when the value of an argument changes. However, this can be customized as needed with a specific max cache size (new in 4.1).\n\n`defaultMemoize` determines if an argument has changed by calling the `equalityCheck` function. As `defaultMemoize` is designed to be used with immutable data, the default `equalityCheck` function checks for changes using reference equality:\n\n```js\nfunction defaultEqualityCheck(previousVal, currentVal) {\n  return currentVal === previousVal\n}\n```\n\nAs of Reselect 4.1, `defaultMemoize` also accepts an options object as its first argument instead of `equalityCheck`. The options object may contain:\n\n```ts\ninterface DefaultMemoizeOptions {\n  equalityCheck?: EqualityFn\n  resultEqualityCheck?: EqualityFn\n  maxSize?: number\n}\n```\n\nAvailable options are:\n\n- `equalityCheck`: used to compare the individual arguments of the provided calculation function\n- `resultEqualityCheck`: if provided, used to compare a newly generated output value against previous values in the cache. If a match is found, the old value is returned. This address the common `todos.map(todo => todo.id)` use case, where an update to another field in the original data causes a recalculate due to changed references, but the output is still effectively the same.\n- `maxSize`: the cache size for the selector. If `maxSize` is greater than 1, the selector will use an LRU cache internally\n\nThe returned memoized function will have a `.clearCache()` method attached.\n\n`defaultMemoize` can also be used with `createSelectorCreator` to create a new selector factory that always has the same settings for each selector.\n\n### createSelectorCreator(memoize, ...memoizeOptions)\n\n`createSelectorCreator` can be used to make a customized version of `createSelector`.\n\nThe `memoize` argument is a memoization function to replace `defaultMemoize`.\n\nThe `...memoizeOptions` rest parameters are zero or more configuration options to be passed to `memoizeFunc`. The selectors `resultFunc` is passed as the first argument to `memoize` and the `memoizeOptions` are passed as the second argument onwards:\n\n```js\nconst customSelectorCreator = createSelectorCreator(\n  customMemoize, // function to be used to memoize resultFunc\n  option1, // option1 will be passed as second argument to customMemoize\n  option2, // option2 will be passed as third argument to customMemoize\n  option3 // option3 will be passed as fourth argument to customMemoize\n)\n\nconst customSelector = customSelectorCreator(\n  input1,\n  input2,\n  resultFunc // resultFunc will be passed as first argument to customMemoize\n)\n```\n\nInternally `customSelector` calls the memoize function as follows:\n\n```js\ncustomMemoize(resultFunc, option1, option2, option3)\n```\n\nHere are some examples of how you might use `createSelectorCreator`:\n\n#### Customize `equalityCheck` for `defaultMemoize`\n\n```js\nimport { createSelectorCreator, defaultMemoize } from 'reselect'\nimport isEqual from 'lodash.isequal'\n\n// create a \"selector creator\" that uses lodash.isequal instead of ===\nconst createDeepEqualSelector = createSelectorCreator(defaultMemoize, isEqual)\n\n// use the new \"selector creator\" to create a selector\nconst selectSum = createDeepEqualSelector(\n  state => state.values.filter(val => val < 5),\n  values => values.reduce((acc, val) => acc + val, 0)\n)\n```\n\n#### Use memoize function from Lodash for an unbounded cache\n\n```js\nimport { createSelectorCreator } from 'reselect'\nimport memoize from 'lodash.memoize'\n\nlet called = 0\nconst hashFn = (...args) =>\n  args.reduce((acc, val) => acc + '-' + JSON.stringify(val), '')\nconst customSelectorCreator = createSelectorCreator(memoize, hashFn)\nconst selector = customSelectorCreator(\n  state => state.a,\n  state => state.b,\n  (a, b) => {\n    called++\n    return a + b\n  }\n)\n```\n\n### createStructuredSelector({inputSelectors}, selectorCreator = createSelector)\n\n`createStructuredSelector` is a convenience function for a common pattern that arises when using Reselect. The selector passed to a `connect` decorator often just takes the values of its input-selectors and maps them to keys in an object:\n\n```js\nconst selectA = state => state.a\nconst selectB = state => state.b\n\n// The result function in the following selector\n// is simply building an object from the input selectors\nconst structuredSelector = createSelector(selectA, selectB, (a, b) => ({\n  a,\n  b\n}))\n```\n\n`createStructuredSelector` takes an object whose properties are input-selectors and returns a structured selector. The structured selector returns an object with the same keys as the `inputSelectors` argument, but with the selectors replaced with their values.\n\n```js\nconst selectA = state => state.a\nconst selectB = state => state.b\n\nconst structuredSelector = createStructuredSelector({\n  x: selectA,\n  y: selectB\n})\n\nconst result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\n```\n\nStructured selectors can be nested:\n\n```js\nconst nestedSelector = createStructuredSelector({\n  subA: createStructuredSelector({\n    selectorA,\n    selectorB\n  }),\n  subB: createStructuredSelector({\n    selectorC,\n    selectorD\n  })\n})\n```\n\n## FAQ\n\n### Q: Why isn’t my selector recomputing when the input state changes?\n\nA: Check that your memoization function is compatible with your state update function (i.e. the reducer if you are using Redux). For example, a selector created with `createSelector` will not work with a state update function that mutates an existing object instead of creating a new one each time. `createSelector` uses an identity check (`===`) to detect that an input has changed, so mutating an existing object will not trigger the selector to recompute because mutating an object does not change its identity. Note that if you are using Redux, mutating the state object is [almost certainly a mistake](http://redux.js.org/docs/Troubleshooting.html).\n\nThe following example defines a simple selector that determines if the first todo item in an array of todos has been completed:\n\n```js\nconst selectIsFirstTodoComplete = createSelector(\n  state => state.todos[0],\n  todo => todo && todo.completed\n)\n```\n\nThe following state update function **will not** work with `selectIsFirstTodoComplete`:\n\n```js\nexport default function todos(state = initialState, action) {\n  switch (action.type) {\n    case COMPLETE_ALL:\n      const areAllMarked = state.every(todo => todo.completed)\n      // BAD: mutating an existing object\n      return state.map(todo => {\n        todo.completed = !areAllMarked\n        return todo\n      })\n\n    default:\n      return state\n  }\n}\n```\n\nThe following state update function **will** work with `selectIsFirstTodoComplete`:\n\n```js\nexport default function todos(state = initialState, action) {\n  switch (action.type) {\n    case COMPLETE_ALL:\n      const areAllMarked = state.every(todo => todo.completed)\n      // GOOD: returning a new object each time with Object.assign\n      return state.map(todo =>\n        Object.assign({}, todo, {\n          completed: !areAllMarked\n        })\n      )\n\n    default:\n      return state\n  }\n}\n```\n\nIf you are not using Redux and have a requirement to work with mutable data, you can use `createSelectorCreator` to replace the default memoization function and/or use a different equality check function. See [here](#use-memoize-function-from-lodash-for-an-unbounded-cache) and [here](#customize-equalitycheck-for-defaultmemoize) for examples.\n\n### Q: Why is my selector recomputing when the input state stays the same?\n\nA: Check that your memoization function is compatible with your state update function (i.e. the reducer if you are using Redux). For example, a selector created with `createSelector` that recomputes unexpectedly may be receiving a new object on each update whether the values it contains have changed or not. `createSelector` uses an identity check (`===`) to detect that an input has changed, so returning a new object on each update means that the selector will recompute on each update.\n\n```js\nimport { REMOVE_OLD } from '../constants/ActionTypes'\n\nconst initialState = [\n  {\n    text: 'Use Redux',\n    completed: false,\n    id: 0,\n    timestamp: Date.now()\n  }\n]\n\nexport default function todos(state = initialState, action) {\n  switch (action.type) {\n    case REMOVE_OLD:\n      return state.filter(todo => {\n        return todo.timestamp + 30 * 24 * 60 * 60 * 1000 > Date.now()\n      })\n    default:\n      return state\n  }\n}\n```\n\nThe following selector is going to recompute every time REMOVE_OLD is invoked because Array.filter always returns a new object. However, in the majority of cases the REMOVE_OLD action will not change the list of todos so the recomputation is unnecessary.\n\n```js\nimport { createSelector } from 'reselect'\n\nconst todosSelector = state => state.todos\n\nexport const selectVisibleTodos = createSelector(\n  todosSelector,\n  (todos) => {\n    ...\n  }\n)\n```\n\nYou can eliminate unnecessary recomputations by returning a new object from the state update function only when a deep equality check has found that the list of todos has actually changed:\n\n```js\nimport { REMOVE_OLD } from '../constants/ActionTypes'\nimport isEqual from 'lodash.isequal'\n\nconst initialState = [\n  {\n    text: 'Use Redux',\n    completed: false,\n    id: 0,\n    timestamp: Date.now()\n  }\n]\n\nexport default function todos(state = initialState, action) {\n  switch (action.type) {\n    case REMOVE_OLD:\n      const updatedState = state.filter(todo => {\n        return todo.timestamp + 30 * 24 * 60 * 60 * 1000 > Date.now()\n      })\n      return isEqual(updatedState, state) ? state : updatedState\n    default:\n      return state\n  }\n}\n```\n\nAlternatively, the default `equalityCheck` function in the selector can be replaced by a deep equality check:\n\n```js\nimport { createSelectorCreator, defaultMemoize } from 'reselect'\nimport isEqual from 'lodash.isequal'\n\nconst selectTodos = state => state.todos\n\n// create a \"selector creator\" that uses lodash.isequal instead of ===\nconst createDeepEqualSelector = createSelectorCreator(\n  defaultMemoize,\n  isEqual\n)\n\n// use the new \"selector creator\" to create a selector\nconst mySelector = createDeepEqualSelector(\n  todosSelector,\n  (todos) => {\n    ...\n  }\n)\n```\n\nAlways check that the cost of an alternative `equalityCheck` function or deep equality check in the state update function is not greater than the cost of recomputing every time. If recomputing every time does work out to be the cheaper option, it may be that for this case Reselect is not giving you any benefit over passing a plain `mapStateToProps` function to `connect`.\n\n### Q: Can I use Reselect without Redux?\n\nA: Yes. Reselect has no dependencies on any other package, so although it was designed to be used with Redux it can be used independently. It can be used with any plain JS data, such as typical React state values, as long as that data is being updated immutably.\n\n### Q: How do I create a selector that takes an argument?\n\nAs shown in the API reference section above, provide input selectors that extract the arguments and forward them to the output selector for calculation:\n\n```js\nconst selectItemsByCategory = createSelector(\n  [\n    // Usual first input - extract value from `state`\n    state => state.items,\n    // Take the second arg, `category`, and forward to the output selector\n    (state, category) => category\n  ],\n  // Output selector gets (`items, category)` as args\n  (items, category) => items.filter(item => item.category === category)\n)\n```\n\n### Q: The default memoization function is no good, can I use a different one?\n\nA: We think it works great for a lot of use cases, but sure. See [these examples](#customize-equalitycheck-for-defaultmemoize).\n\n### Q: How do I test a selector?\n\nA: For a given input, a selector should always produce the same output. For this reason they are simple to unit test.\n\n```js\nconst selector = createSelector(\n  state => state.a,\n  state => state.b,\n  (a, b) => ({\n    c: a * 2,\n    d: b * 3\n  })\n)\n\ntest('selector unit test', () => {\n  assert.deepEqual(selector({ a: 1, b: 2 }), { c: 2, d: 6 })\n  assert.deepEqual(selector({ a: 2, b: 3 }), { c: 4, d: 9 })\n})\n```\n\nIt may also be useful to check that the memoization function for a selector works correctly with the state update function (i.e. the reducer if you are using Redux). Each selector has a `recomputations` method that will return the number of times it has been recomputed:\n\n```js\nsuite('selector', () => {\n  let state = { a: 1, b: 2 }\n\n  const reducer = (state, action) => ({\n    a: action(state.a),\n    b: action(state.b)\n  })\n\n  const selector = createSelector(\n    state => state.a,\n    state => state.b,\n    (a, b) => ({\n      c: a * 2,\n      d: b * 3\n    })\n  )\n\n  const plusOne = x => x + 1\n  const id = x => x\n\n  test('selector unit test', () => {\n    state = reducer(state, plusOne)\n    assert.deepEqual(selector(state), { c: 4, d: 9 })\n    state = reducer(state, id)\n    assert.deepEqual(selector(state), { c: 4, d: 9 })\n    assert.equal(selector.recomputations(), 1)\n    state = reducer(state, plusOne)\n    assert.deepEqual(selector(state), { c: 6, d: 12 })\n    assert.equal(selector.recomputations(), 2)\n  })\n})\n```\n\nAdditionally, selectors keep a reference to the last result function as `.resultFunc`. If you have selectors composed of many other selectors this can help you test each selector without coupling all of your tests to the shape of your state.\n\nFor example if you have a set of selectors like this:\n\n**selectors.js**\n\n```js\nexport const selectFirst = createSelector( ... )\nexport const selectSecond = createSelector( ... )\nexport const selectThird = createSelector( ... )\n\nexport const myComposedSelector = createSelector(\n  selectFirst,\n  selectSecond,\n  selectThird,\n  (first, second, third) => first * second < third\n)\n```\n\nAnd then a set of unit tests like this:\n\n**test/selectors.js**\n\n```js\n// tests for the first three selectors...\ntest(\"selectFirst unit test\", () => { ... })\ntest(\"selectSecond unit test\", () => { ... })\ntest(\"selectThird unit test\", () => { ... })\n\n// We have already tested the previous\n// three selector outputs so we can just call `.resultFunc`\n// with the values we want to test directly:\ntest(\"myComposedSelector unit test\", () => {\n  // here instead of calling selector()\n  // we just call selector.resultFunc()\n  assert(myComposedSelector.resultFunc(1, 2, 3), true)\n  assert(myComposedSelector.resultFunc(2, 2, 1), false)\n})\n```\n\nFinally, each selector has a `resetRecomputations` method that sets\nrecomputations back to 0. The intended use is for a complex selector that may\nhave many independent tests and you don't want to manually manage the\ncomputation count or create a \"dummy\" selector for each test.\n\n### Q: Can I share a selector across multiple component instances?\n\nA: Yes, although it requires some planning.\n\nAs of Reselect 4.1, you can create a selector with a cache size greater than one by passing in a `maxSize` option under `memoizeOptions` for use with the built-in `defaultMemoize`.\n\nOtherwise, selectors created using `createSelector` only have a cache size of one. This can make them unsuitable for sharing across multiple instances if the arguments to the selector are different for each instance of the component. There are a couple of ways to get around this:\n\n- Create a factory function which returns a new selector for each instance of the component. This can be called in a React component inside the `useMemo` hook to generate a unique selector instance per component.\n- Create a custom selector with a cache size greater than one using `createSelectorCreator`\n\n### Q: Are there TypeScript Typings?\n\nA: Yes! Reselect is now written in TS itself, so they should Just Work™.\n\n### Q: I am seeing a TypeScript error: `Type instantiation is excessively deep and possibly infinite`\n\nA: This can often occur with deeply recursive types, which occur in this library. Please see [this\ncomment](https://github.com/reduxjs/reselect/issues/534#issuecomment-956708953) for a discussion of the problem, as\nrelating to nested selectors.\n\n### Q: How can I make a [curried](https://github.com/hemanth/functional-programming-jargon#currying) selector?\n\nA: Try these [helper functions](https://github.com/reduxjs/reselect/issues/159#issuecomment-238724788) courtesy of [MattSPalmer](https://github.com/MattSPalmer)\n\n## Related Projects\n\n### [re-reselect](https://github.com/toomuchdesign/re-reselect)\n\nEnhances Reselect selectors by wrapping `createSelector` and returning a memoized collection of selectors indexed with the cache key returned by a custom resolver function.\n\nUseful to reduce selectors recalculation when the same selector is repeatedly called with one/few different arguments.\n\n### [reselect-tools](https://github.com/skortchmark9/reselect-tools)\n\n[Chrome extension](https://chrome.google.com/webstore/detail/reselect-devtools/cjmaipngmabglflfeepmdiffcijhjlbb?hl=en) and [companion lib](https://github.com/skortchmark9/reselect-tools) for debugging selectors.\n\n- Measure selector recomputations across the app and identify performance bottlenecks\n- Check selector dependencies, inputs, outputs, and recomputations at any time with the chrome extension\n- Statically export a JSON representation of your selector graph for further analysis\n\n### [reselect-debugger](https://github.com/vlanemcev/reselect-debugger-flipper)\n\n[Flipper plugin](https://github.com/vlanemcev/flipper-plugin-reselect-debugger) and [and the connect app](https://github.com/vlanemcev/reselect-debugger-flipper) for debugging selectors in **React Native Apps**.\n\nInspired by Reselect Tools, so it also has all functionality from this library and more, but only for React Native and Flipper.\n\n- Selectors Recomputations count in live time across the App for identify performance bottlenecks\n- Highlight most recomputed selectors\n- Dependency Graph\n- Search by Selectors Graph\n- Selectors Inputs\n- Selectors Output (In case if selector not dependent from external arguments)\n- Shows \"Not Memoized (NM)\" selectors\n\n## License\n\nMIT\n\n## Prior Art and Inspiration\n\nOriginally inspired by getters in [NuclearJS](https://github.com/optimizely/nuclear-js.git), [subscriptions](https://github.com/Day8/re-frame#just-a-read-only-cursor) in [re-frame](https://github.com/Day8/re-frame) and this [proposal](https://github.com/reduxjs/redux/pull/169) from [speedskater](https://github.com/speedskater).\n\n[build-badge]: https://img.shields.io/github/workflow/status/reduxjs/redux-thunk/Tests\n[build]: https://github.com/reduxjs/reselect/actions/workflows/build-and-test-types.yml\n[npm-badge]: https://img.shields.io/npm/v/reselect.svg?style=flat-square\n[npm]: https://www.npmjs.org/package/reselect\n[coveralls-badge]: https://img.shields.io/coveralls/reduxjs/reselect/master.svg?style=flat-square\n[coveralls]: https://coveralls.io/github/reduxjs/reselect\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2015-2018 Reselect Contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmjs.org/reselect/-/reselect-4.1.5.tgz",
    "type": "tarball",
    "reference": "https://registry.npmjs.org/reselect/-/reselect-4.1.5.tgz",
    "hash": "",
    "integrity": "sha512-uVdlz8J7OO+ASpBYoz1Zypgx0KasCY20H+N8JD13oUMtPvSHQuscrHop4KbXrbsBcdB9Ds7lVK7eRkBIfO43vQ==",
    "registry": "npm",
    "packageName": "reselect",
    "cacheIntegrity": "sha512-uVdlz8J7OO+ASpBYoz1Zypgx0KasCY20H+N8JD13oUMtPvSHQuscrHop4KbXrbsBcdB9Ds7lVK7eRkBIfO43vQ== sha1-hSw2EkcZjaZ1bQfZKWwrUe3befY="
  },
  "registry": "npm",
  "hash": "b95765cfc27b38ef804a9058a33d59ca9831d0a6ac098db41fe37c243d77a1432d3ef48742eb1cac7a29e0a6d7adbb0171d07d0ecee554aede4640487cee37bd"
}