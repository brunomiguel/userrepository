{
  "manifest": {
    "type": "module",
    "name": "form-data-encoder",
    "version": "2.1.4",
    "description": "Encode FormData content into the multipart/form-data format",
    "repository": {
      "type": "git",
      "url": "https://github.com/octet-stream/form-data-encoder.git"
    },
    "sideEffects": false,
    "engines": {
      "node": ">= 14.17"
    },
    "keywords": [
      "form-data",
      "encoder",
      "multipart",
      "files-upload",
      "async-iterator",
      "spec-compatible",
      "form"
    ],
    "main": "./lib/index.js",
    "module": "./lib/index.js",
    "exports": {
      "types": "./@type/index.d.ts",
      "default": "./lib/index.js"
    },
    "types": "./@type/index.d.ts",
    "scripts": {
      "eslint": "eslint src/**/*.ts",
      "staged": "lint-staged",
      "coverage": "c8 npm test",
      "ci": "c8 npm test && c8 report --reporter=json",
      "build:types": "tsc --project tsconfig.d.ts.json",
      "build": "tsc && npm run build:types",
      "test": "ava --fail-fast",
      "cleanup": "del-cli @type lib",
      "prepare": "npm run cleanup && npm run build",
      "_postinstall": "husky install",
      "prepublishOnly": "pinst --disable",
      "postpublish": "pinst --enable"
    },
    "author": {
      "name": "Nick K."
    },
    "license": "MIT",
    "devDependencies": {
      "@octetstream/eslint-config": "6.2.2",
      "@types/mime-types": "2.1.1",
      "@types/node": "18.11.9",
      "@types/sinon": "^10.0.13",
      "@typescript-eslint/eslint-plugin": "5.44.0",
      "@typescript-eslint/parser": "5.44.0",
      "ava": "5.1.0",
      "c8": "7.12.0",
      "del-cli": "5.0.0",
      "eslint": "8.28.0",
      "eslint-config-airbnb-typescript": "17.0.0",
      "eslint-import-resolver-typescript": "3.5.2",
      "eslint-plugin-ava": "13.2.0",
      "eslint-plugin-import": "^2.26.0",
      "eslint-plugin-jsx-a11y": "6.6.1",
      "eslint-plugin-react": "7.31.11",
      "formdata-node": "5.0.0",
      "husky": "8.0.2",
      "lint-staged": "13.0.3",
      "pinst": "3.0.0",
      "sinon": "^14.0.2",
      "ts-node": "10.9.1",
      "ttypescript": "1.5.13",
      "typescript": "4.9.3",
      "web-streams-polyfill": "4.0.0-beta.3"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-form-data-encoder-2.1.4-261ea35d2a70d48d30ec7a9603130fa5515e9cd5-integrity/node_modules/form-data-encoder/package.json",
    "readmeFilename": "readme.md",
    "readme": "# form-data-encoder\n\nEncode `FormData` content into the `multipart/form-data` format\n\n[![Code Coverage](https://codecov.io/github/octet-stream/form-data-encoder/coverage.svg?branch=master)](https://codecov.io/github/octet-stream/form-data-encoder?branch=master)\n[![CI](https://github.com/octet-stream/form-data-encoder/workflows/CI/badge.svg)](https://github.com/octet-stream/form-data-encoder/actions/workflows/ci.yml)\n[![ESLint](https://github.com/octet-stream/form-data-encoder/workflows/ESLint/badge.svg)](https://github.com/octet-stream/form-data-encoder/actions/workflows/eslint.yml)\n\n## Requirements\n\n- Node.js v14.17 or higher;\n- Runtime should support `TextEncoder`, `TextDecoder`, `WeakMap`, `WeakSet` and async generator functions;\n- For TypeScript users: tsc v4.3 or higher.\n\n## Installation\n\nYou can install this package using npm:\n\n```sh\nnpm install form-data-encoder\n```\n\nOr yarn:\n\n```sh\nyarn add form-data-encoder\n```\n\nOr pnpm:\n\n```sh\npnpm add form-data-encoder\n```\n\n## Usage\n\n1. To start the encoding process, you need to create a new Encoder instance with the FormData you want to encode:\n\n```js\nimport {Readable} from \"stream\"\n\nimport {FormData, File} from \"formdata-node\"\nimport {FormDataEncoder} from \"form-data-encoder\"\n\nimport fetch from \"node-fetch\"\n\nconst form = new FormData()\n\nform.set(\"greeting\", \"Hello, World!\")\nform.set(\"file\", new File([\"On Soviet Moon landscape see binoculars through YOU\"], \"file.txt\"))\n\nconst encoder = new FormDataEncoder(form)\n\nconst options = {\n  method: \"post\",\n\n  // Set request headers provided by the Encoder.\n  // The `headers` property has `Content-Type` and `Content-Length` headers.\n  headers: encoder.headers,\n\n  // Create a Readable stream from the Encoder.\n  // You can omit usage of `Readable.from` for HTTP clients whose support async iterables in request body.\n  // The Encoder will yield FormData content portions encoded into the multipart/form-data format as node-fetch consumes the stream.\n  body: Readable.from(encoder.encode()) // or just Readable.from(encoder)\n}\n\nconst response = await fetch(\"https://httpbin.org/post\", options)\n\nconsole.log(await response.json())\n```\n\n2. Encoder support different spec-compatible FormData implementations. Let's try it with [`formdata-polyfill`](https://github.com/jimmywarting/FormData):\n\n```js\nimport {Readable} from \"stream\"\n\nimport {FormDataEncoder} from \"form-data-encoder\"\nimport {FormData} from \"formdata-polyfill/esm-min.js\"\nimport {File} from \"fetch-blob\" // v3\n\nconst form = new FormData()\n\nform.set(\"field\", \"Some value\")\nform.set(\"file\", new File([\"File content goes here\"], \"file.txt\"))\n\nconst encoder = new FormDataEncoder(form)\n\nconst options = {\n  method: \"post\",\n  headers: encoder.headers,\n  body: Readable.from(encoder)\n}\n\nawait fetch(\"https://httpbin.org/post\", options)\n```\n\n3. Because the Encoder is iterable (it has both Symbol.asyncIterator and Symbol.iterator methods), you can use it with different targets. Let's say you want to convert FormData content into `Blob`, for that you can write a function like this:\n\n```js\nimport {Readable} from \"stream\"\n\nimport {FormDataEncoder} from \"form-data-encoder\"\n\nimport {FormData, File, Blob, fileFromPath} from \"formdata-node\"\n\nimport fetch from \"node-fetch\"\n\nconst form = new FormData()\n\nform.set(\"field\", \"Just a random string\")\nform.set(\"file\", new File([\"Using files is class amazing\"], \"file.txt\"))\nform.set(\"fileFromPath\", await fileFromPath(\"path/to/a/file.txt\"))\n\n// Note 1: When using with native Blob or fetch-blob@2 you might also need to generate boundary string for your FormDataEncoder instance\n// because Blob will lowercase value of the `type` option and default boundary generator produces a string with both lower and upper cased alphabetical characters. Math.random() should be enough to fix this:\n// const encoder = new FormDataEncoder(form, String(Math.random()))\nconst encoder = new FormDataEncoder(form)\n\nconst options = {\n  method: \"post\",\n\n  // Note 2: To use this approach with fetch-blob@2 you probably gonna need to convert the encoder parts output to an array first:\n  // new Blob([...encoder], {type: encoder.contentType})\n  body: new Blob(encoder, {type: encoder.contentType})\n}\n\nconst response = await fetch(\"https://httpbin.org/post\", options)\n\nconsole.log(await response.json())\n```\n\n4. Here's FormData to Blob conversion with async-iterator approach:\n\n```js\nimport {FormData} from \"formdata-polyfill/esm-min.js\"\nimport {blobFrom} from \"fetch-blob/from.js\"\nimport {FormDataEncoder} from \"form-data-encoder\"\n\nimport Blob from \"fetch-blob\"\nimport fetch from \"node-fetch\"\n\n// This approach may require much more RAM compared to the previous one, but it works too.\nasync function toBlob(form) {\n  const encoder = new Encoder(form)\n  const chunks = []\n\n  for await (const chunk of encoder) {\n    chunks.push(chunk)\n  }\n\n  return new Blob(chunks, {type: encoder.contentType})\n}\n\nconst form = new FormData()\n\nform.set(\"name\", \"John Doe\")\nform.set(\"avatar\", await blobFrom(\"path/to/an/avatar.png\"), \"avatar.png\")\n\nconst options = {\n  method: \"post\",\n  body: await toBlob(form)\n}\n\nawait fetch(\"https://httpbin.org/post\", options)\n```\n\n5. Another way to convert FormData parts to blob using `form-data-encoder` is making a Blob-ish class:\n\n```js\nimport {Readable} from \"stream\"\n\nimport {FormDataEncoder} from \"form-data-encoder\"\nimport {FormData} from \"formdata-polyfill/esm-min.js\"\nimport {blobFrom} from \"fetch-blob/from.js\"\n\nimport Blob from \"fetch-blob\"\nimport fetch from \"node-fetch\"\n\nclass BlobDataItem {\n  constructor(encoder) {\n    this.#encoder = encoder\n    this.#size = encoder.headers[\"Content-Length\"]\n    this.#type = encoder.headers[\"Content-Type\"]\n  }\n\n  get type() {\n    return this.#type\n  }\n\n  get size() {\n    return this.#size\n  }\n\n  stream() {\n    return Readable.from(this.#encoder)\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"Blob\"\n  }\n}\n\nconst form = new FormData()\n\nform.set(\"name\", \"John Doe\")\nform.set(\"avatar\", await blobFrom(\"path/to/an/avatar.png\"), \"avatar.png\")\n\nconst encoder = new FormDataEncoder(form)\n\n// Note that node-fetch@2 performs more strictness tests for Blob objects, so you may need to do extra steps before you set up request body (like, maybe you'll need to instaniate a Blob with BlobDataItem as one of its blobPart)\nconst blob = new BlobDataItem(enocoder) // or new Blob([new BlobDataItem(enocoder)], {type: encoder.contentType})\n\nconst options = {\n  method: \"post\",\n  body: blob\n}\n\nawait fetch(\"https://httpbin.org/post\", options)\n```\n\n6. In this example we will pull FormData content into the ReadableStream:\n\n```js\n // This module is only necessary when you targeting Node.js or need web streams that implement Symbol.asyncIterator\nimport {ReadableStream} from \"web-streams-polyfill/ponyfill/es2018\"\n\nimport {FormDataEncoder} from \"form-data-encoder\"\nimport {FormData} from \"formdata-node\"\n\nimport fetch from \"node-fetch\"\n\nfunction toReadableStream(encoder) {\n  const iterator = encoder.encode()\n\n  return new ReadableStream({\n    async pull(controller) {\n      const {value, done} = await iterator.next()\n\n      if (done) {\n        return controller.close()\n      }\n\n      controller.enqueue(value)\n    }\n  })\n}\n\nconst form = new FormData()\n\nform.set(\"field\", \"My hovercraft is full of eels\")\n\nconst encoder = new FormDataEncoder(form)\n\nconst options = {\n  method: \"post\",\n  headers: encoder.headers,\n  body: toReadableStream(encoder)\n}\n\n// Note that this example requires `fetch` to support Symbol.asyncIterator, which node-fetch lacks of (but will support eventually)\nawait fetch(\"https://httpbin.org/post\", options)\n```\n\n7. Speaking of async iterables - if HTTP client supports them, you can use encoder like this:\n\n```js\nimport {FormDataEncoder} from \"form-data-encoder\"\nimport {FormData} from \"formdata-node\"\n\nimport fetch from \"node-fetch\"\n\nconst form = new FormData()\n\nform.set(\"field\", \"My hovercraft is full of eels\")\n\nconst encoder = new FormDataEncoder(form)\n\nconst options = {\n  method: \"post\",\n  headers: encoder.headers,\n  body: encoder\n}\n\nawait fetch(\"https://httpbin.org/post\", options)\n```\n\n8. ...And for those client whose supporting form-data-encoder out of the box, the usage will be much, much more simpler:\n\n```js\nimport {FormData} from \"formdata-node\" // Or any other spec-compatible implementation\n\nimport fetch from \"node-fetch\"\n\nconst form = new FormData()\n\nform.set(\"field\", \"My hovercraft is full of eels\")\n\nconst options = {\n  method: \"post\",\n  body: form\n}\n\n// Note that node-fetch does NOT support form-data-encoder\nawait fetch(\"https://httpbin.org/post\", options)\n```\n\n## API\n\n### `class FormDataEncoder`\n\n##### `constructor(form[, boundary, options]) -> {FormDataEncoder}`\n\n  - **{FormDataLike}** form - FormData object to encode. This object must be a spec-compatible FormData implementation.\n  - **{string}** [boundary] - An optional boundary string that will be used by the encoder. If there's no boundary string is present, FormDataEncoder will generate it automatically.\n  - **{object}** [options] - FormDataEncoder options.\n  - **{boolean}** [options.enableAdditionalHeaders = false] - When enabled, the encoder will emit additional per part headers, such as `Content-Length`. Please note that the web clients do not include these, so when enabled this option might cause an error if `multipart/form-data` does not consider additional headers.\n\nCreates a `multipart/form-data` encoder.\n\n#### Instance properties\n\n##### `boundary -> {string}`\n\nReturns boundary string.\n\n##### `contentType -> {string}`\n\nReturns Content-Type header.\n\n##### `contentLength -> {string}`\n\nReturn Content-Length header.\n\n##### `headers -> {object}`\n\nReturns headers object with Content-Type and Content-Length header.\n\n#### Instance methods\n\n##### `values() -> {Generator<Uint8Array | FileLike, void, undefined>}`\n\nCreates an iterator allowing to go through form-data parts (with metadata).\nThis method **will not** read the files.\n\n##### `encode() -> {AsyncGenerator<Uint8Array, void, undefined>}`\n\nCreates an async iterator allowing to perform the encoding by portions.\nThis method **will** also read files.\n\n##### `[Symbol.iterator]() -> {Generator<Uint8Array | FileLike, void, undefined>}`\n\nAn alias for `Encoder#values()` method.\n\n##### `[Symbol.asyncIterator]() -> {AsyncGenerator<Uint8Array, void, undefined>}`\n\nAn alias for `Encoder#encode()` method.\n\n### `isFile(value) -> {boolean}`\n\nCheck if a value is File-ish object.\n\n  - **{unknown}** value - a value to test\n\n### `isFormData(value) -> {boolean}`\n\nCheck if a value is FormData-ish object.\n\n  - **{unknown}** value - a value to test\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2021-present Nick K.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/form-data-encoder/-/form-data-encoder-2.1.4.tgz#261ea35d2a70d48d30ec7a9603130fa5515e9cd5",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/form-data-encoder/-/form-data-encoder-2.1.4.tgz",
    "hash": "261ea35d2a70d48d30ec7a9603130fa5515e9cd5",
    "integrity": "sha512-yDYSgNMraqvnxiEXO4hi88+YZxaHC6QKzb5N84iRCTDeRO7ZALpir/lVmf/uXUhnwUr2O4HU8s/n6x+yNjQkHw==",
    "registry": "npm",
    "packageName": "form-data-encoder",
    "cacheIntegrity": "sha512-yDYSgNMraqvnxiEXO4hi88+YZxaHC6QKzb5N84iRCTDeRO7ZALpir/lVmf/uXUhnwUr2O4HU8s/n6x+yNjQkHw== sha1-Jh6jXSpw1I0w7HqWAxMPpVFenNU="
  },
  "registry": "npm",
  "hash": "261ea35d2a70d48d30ec7a9603130fa5515e9cd5"
}