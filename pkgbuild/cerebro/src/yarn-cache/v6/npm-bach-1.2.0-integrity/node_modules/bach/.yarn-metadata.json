{
  "manifest": {
    "name": "bach",
    "version": "1.2.0",
    "description": "Compose your async functions with elegance.",
    "author": {
      "name": "Gulp Team",
      "email": "team@gulpjs.com",
      "url": "http://gulpjs.com/"
    },
    "contributors": [
      {
        "name": "Blaine Bublitz",
        "email": "blaine.bublitz@gmail.com"
      },
      {
        "name": "Pawel Kozlowski",
        "email": "pkozlowski.opensource@gmail.com"
      },
      {
        "name": "Benjamin Tan",
        "email": "demoneaux@gmail.com"
      }
    ],
    "repository": {
      "type": "git",
      "url": "https://github.com/gulpjs/bach.git"
    },
    "license": "MIT",
    "engines": {
      "node": ">= 0.10"
    },
    "main": "index.js",
    "files": [
      "index.js",
      "lib",
      "LICENSE"
    ],
    "scripts": {
      "lint": "eslint . && jscs index.js lib/ test/",
      "pretest": "npm run lint",
      "test": "mocha --async-only",
      "cover": "istanbul cover _mocha --report lcovonly",
      "coveralls": "npm run cover && istanbul-coveralls"
    },
    "dependencies": {
      "arr-filter": "^1.1.1",
      "arr-flatten": "^1.0.1",
      "arr-map": "^2.0.0",
      "array-each": "^1.0.0",
      "array-initial": "^1.0.0",
      "array-last": "^1.1.1",
      "async-done": "^1.2.2",
      "async-settle": "^1.0.0",
      "now-and-later": "^2.0.0"
    },
    "devDependencies": {
      "eslint": "^1.7.3",
      "eslint-config-gulp": "^2.0.0",
      "expect": "^1.19.0",
      "istanbul": "^0.4.3",
      "istanbul-coveralls": "^1.0.3",
      "jscs": "^2.3.5",
      "jscs-preset-gulp": "^1.0.0",
      "mocha": "^2.4.5"
    },
    "keywords": [
      "compose",
      "fluent",
      "composing",
      "continuation",
      "function composition",
      "functional",
      "async",
      "map",
      "series",
      "parallel",
      "extension",
      "tracing",
      "debug",
      "timing",
      "aop",
      "settle",
      "promises",
      "callbacks",
      "observables",
      "streams",
      "end",
      "completion",
      "complete",
      "finish",
      "done",
      "error handling"
    ],
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-bach-1.2.0-integrity/node_modules/bach/package.json",
    "readmeFilename": "README.md",
    "readme": "<p align=\"center\">\n  <a href=\"http://gulpjs.com\">\n    <img height=\"257\" width=\"114\" src=\"https://raw.githubusercontent.com/gulpjs/artwork/master/gulp-2x.png\">\n  </a>\n</p>\n\n# bach\n\n[![NPM version][npm-image]][npm-url] [![Downloads][downloads-image]][npm-url] [![Build Status][travis-image]][travis-url] [![AppVeyor Build Status][appveyor-image]][appveyor-url] [![Coveralls Status][coveralls-image]][coveralls-url] [![Gitter chat][gitter-image]][gitter-url]\n\nCompose your async functions with elegance.\n\n## Usage\n\nWith `bach`, it is very easy to compose async functions to run in series or parallel.\n\n```js\nvar bach = require('bach');\n\nfunction fn1(cb) {\n  cb(null, 1);\n}\n\nfunction fn2(cb) {\n  cb(null, 2);\n}\n\nfunction fn3(cb) {\n  cb(null, 3);\n}\n\nvar seriesFn = bach.series(fn1, fn2, fn3);\n// fn1, fn2, and fn3 will be run in series\nseriesFn(function(err, res) {\n  if (err) { // in this example, err is undefined\n    // handle error\n  }\n  // handle results\n  // in this example, res is [1, 2, 3]\n});\n\nvar parallelFn = bach.parallel(fn1, fn2, fn3);\n// fn1, fn2, and fn3 will be run in parallel\nparallelFn(function(err, res) {\n  if (err) { // in this example, err is undefined\n    // handle error\n  }\n  // handle results\n  // in this example, res is [1, 2, 3]\n});\n```\n\nSince the composer functions return a function, you can combine them.\n\n```js\nvar combinedFn = bach.series(fn1, bach.parallel(fn2, fn3));\n// fn1 will be executed before fn2 and fn3 are run in parallel\ncombinedFn(function(err, res) {\n  if (err) { // in this example, err is undefined\n    // handle error\n  }\n  // handle results\n  // in this example, res is [1, [2, 3]]\n});\n```\n\nFunctions are called with [async-done], so you can return a stream, promise, observable or child process. See [`async-done` completion and error resolution][completions] for more detail.\n\n```js\n// streams\nvar fs = require('fs');\n\nfunction streamFn1() {\n  return fs.createReadStream('./example')\n    .pipe(fs.createWriteStream('./example'));\n}\n\nfunction streamFn2() {\n  return fs.createReadStream('./example')\n    .pipe(fs.createWriteStream('./example'));\n}\n\nvar parallelStreams = bach.parallel(streamFn1, streamFn2);\nparallelStreams(function(err) {\n  if (err) { // in this example, err is undefined\n    // handle error\n  }\n  // all streams have emitted an 'end' or 'close' event\n});\n```\n\n```js\n// promises\nvar when = require('when');\n\nfunction promiseFn1() {\n  return when.resolve(1);\n}\n\nfunction promiseFn2() {\n  return when.resolve(2);\n}\n\nvar parallelPromises = bach.parallel(promiseFn1, promiseFn2);\nparallelPromises(function(err, res) {\n  if (err) { // in this example, err is undefined\n    // handle error\n  }\n  // handle results\n  // in this example, res is [1, 2]\n});\n```\n\nAll errors are caught in a [domain] and passed to the final callback as the first argument.\n\n```js\nfunction success(cb) {\n  setTimeout(function() {\n    cb(null, 1);\n  }, 500);\n}\n\nfunction error() {\n  throw new Error('Thrown Error');\n}\n\nvar errorThrownFn = bach.parallel(error, success);\nerrorThrownFn(function(err, res) {\n  if (err) {\n    // handle error\n    // in this example, err is an error caught by the domain\n  }\n  // handle results\n  // in this example, res is [undefined]\n});\n```\n\nWhen an error happens in a parallel composition, the callback will be called as soon as the error happens.\nIf you want to continue on error and wait until all functions have finished before calling the callback, use `settleSeries` or `settleParallel`.\n\n```js\nfunction success(cb) {\n  setTimeout(function() {\n    cb(null, 1);\n  }, 500);\n}\n\nfunction error(cb) {\n  cb(new Error('Async Error'));\n}\n\nvar parallelSettlingFn = bach.settleParallel(success, error);\nparallelSettlingFn(function(err, res) {\n  // all functions have finished executing\n  if (err) {\n    // handle error\n    // in this example, err is an error passed to the callback\n  }\n  // handle results\n  // in this example, res is [1]\n});\n```\n\n## API\n\n### `series(fns..., [extensions])`\n\nTakes a variable amount of functions (`fns`) to be called in series when the returned function is\ncalled. Optionally, takes an [extensions](#extensions) object as the last argument.\n\nReturns an `invoker(cb)` function to be called to start the serial execution. The invoker function takes a callback (`cb`) with the `function(error, results)` signature.\n\nIf all functions complete successfully, the callback function will be called with all `results` as the second argument.\n\nIf an error occurs, execution will stop and the error will be passed to the callback function as the first parameter. The error parameter will always be a single error.\n\n### `parallel(fns..., [extensions])`\n\nTakes a variable amount of functions (`fns`) to be called in parallel when the returned function is\ncalled. Optionally, takes an [extensions](#extensions) object as the last argument.\n\nReturns an `invoker(cb)` function to be called to start the parallel execution. The invoker function takes a callback (`cb`) with the `function(error, results)` signature.\n\nIf all functions complete successfully, the callback function will be called with all `results` as the second argument.\n\nIf an error occurs, the callback function will be called with the error as the first parameter. Any async functions that have not completed, will still complete, but their results will __not__ be available. The error parameter will always be a single error.\n\n### `settleSeries(fns..., [extensions])`\n\nTakes a variable amount of functions (`fns`) to be called in series when the returned function is\ncalled. Optionally, takes an [extensions](#extensions) object as the last argument.\n\nReturns an `invoker(cb)` function to be called to start the serial execution. The invoker function takes a callback (`cb`) with the `function(error, results)` signature.\n\nAll functions will always be called and the callback will receive all settled errors and results. If any errors occur, the error parameter will be an array of errors.\n\n### `settleParallel(fns..., [extensions])`\n\nTakes a variable amount of functions (`fns`) to be called in parallel when the returned function is\ncalled. Optionally, takes an [extensions](#extensions) object as the last argument.\n\nReturns an `invoker(cb)` function to be called to start the parallel execution. The invoker function takes a callback (`cb`) with the `function(error, results)` signature.\n\nAll functions will always be called and the callback will receive all settled errors and results. If any errors occur, the error parameter will be an array of errors.\n\n### `extensions`\n\nThe `extensions` object is used for specifying functions that give insight into the lifecycle of each function call. The possible extension points are `create`, `before`, `after` and `error`. If an extension point is not specified, it defaults to a no-op function.\n\n##### `extensions.create(fn, index)`\n\nCalled at the very beginning of each function call with the function (`fn`) being executed and the `index` from the array/arguments. If `create` returns a value (`storage`), it is passed to the `before`, `after` and `error` extension points.\n\nIf a value is not returned, an empty object is used as `storage` for each other extension point.\n\nThis is useful for tracking information across an iteration.\n\n##### `extensions.before(storage)`\n\nCalled immediately before each function call with the `storage` value returned from the `create` extension point.\n\n##### `extensions.after(result, storage)`\n\nCalled immediately after each function call with the `result` of the function and the `storage` value returned from the `create` extension point.\n\n##### `extensions.error(error, storage)`\n\nCalled immediately after a failed function call with the `error` of the function and the `storage` value returned from the `create` extension point.\n\n## License\n\nMIT\n\n[domain]: http://nodejs.org/api/domain.html\n[async-done]: https://github.com/gulpjs/async-done\n[completions]: https://github.com/gulpjs/async-done#completion-and-error-resolution\n\n[downloads-image]: http://img.shields.io/npm/dm/bach.svg\n[npm-url]: https://www.npmjs.com/package/bach\n[npm-image]: http://img.shields.io/npm/v/bach.svg\n\n[travis-url]: https://travis-ci.org/gulpjs/bach\n[travis-image]: http://img.shields.io/travis/gulpjs/bach.svg?label=travis-ci\n\n[appveyor-url]: https://ci.appveyor.com/project/gulpjs/bach\n[appveyor-image]: https://img.shields.io/appveyor/ci/gulpjs/bach.svg?label=appveyor\n\n[coveralls-url]: https://coveralls.io/r/gulpjs/bach\n[coveralls-image]: http://img.shields.io/coveralls/gulpjs/bach.svg\n\n[gitter-url]: https://gitter.im/gulpjs/gulp\n[gitter-image]: https://badges.gitter.im/gulpjs/gulp.svg\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2014 Blaine Bublitz, Eric Schoffstall and other contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmjs.org/bach/-/bach-1.2.0.tgz",
    "type": "tarball",
    "reference": "https://registry.npmjs.org/bach/-/bach-1.2.0.tgz",
    "hash": "",
    "integrity": "sha1-Szzpa/JxNPeaG0FKUcFONMO9mIA=",
    "registry": "npm",
    "packageName": "bach",
    "cacheIntegrity": "sha512-bZOOfCb3gXBXbTFXq3OZtGR88LwGeJvzu6szttaIzymOTS4ZttBNOWSv7aLZja2EMycKtRYV0Oa8SNKH/zkxvg== sha1-Szzpa/JxNPeaG0FKUcFONMO9mIA="
  },
  "registry": "npm",
  "hash": "6d938e7c26f78170576d3157ab7399b4647cf0bc06789bf3bbab33b6d688cf298e4d2e19b6d04d3964afeda2d98dad8433270ab51615d0e6bc48d287ff3931be"
}