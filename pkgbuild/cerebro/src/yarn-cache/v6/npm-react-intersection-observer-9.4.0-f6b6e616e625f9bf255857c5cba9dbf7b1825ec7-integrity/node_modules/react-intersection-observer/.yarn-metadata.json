{
  "manifest": {
    "name": "react-intersection-observer",
    "version": "9.4.0",
    "description": "Monitor if a component is inside the viewport, using IntersectionObserver API",
    "source": "./src/index.tsx",
    "main": "./react-intersection-observer.js",
    "module": "./react-intersection-observer.esm.js",
    "unpkg": "./react-intersection-observer.umd.js",
    "types": "./index.d.ts",
    "exports": {
      "./test-utils": {
        "types": "./test-utils.d.ts",
        "default": "./test-utils.js"
      },
      ".": {
        "types": "./index.d.ts",
        "require": "./react-intersection-observer.js",
        "default": "./react-intersection-observer.modern.mjs"
      }
    },
    "author": {
      "name": "Daniel Schmidt"
    },
    "sideEffects": false,
    "repository": {
      "type": "git",
      "url": "https://github.com/thebuilder/react-intersection-observer.git"
    },
    "license": "MIT",
    "keywords": [
      "react",
      "component",
      "hooks",
      "viewport",
      "intersection",
      "observer",
      "lazy load",
      "inview",
      "useInView",
      "useIntersectionObserver"
    ],
    "release": {
      "branches": [
        "master",
        {
          "name": "beta",
          "prerelease": true
        }
      ],
      "plugins": [
        "@semantic-release/commit-analyzer",
        "@semantic-release/release-notes-generator",
        [
          "@semantic-release/npm",
          {
            "pkgRoot": "dist"
          }
        ],
        "@semantic-release/github"
      ]
    },
    "size-limit": [
      {
        "path": "dist/react-intersection-observer.esm.js",
        "name": "InView",
        "import": "{ InView }",
        "limit": "1.8 kB"
      },
      {
        "path": "dist/react-intersection-observer.esm.js",
        "name": "useInView",
        "import": "{ useInView }",
        "limit": "1.3 kB"
      },
      {
        "path": "dist/react-intersection-observer.esm.js",
        "name": "observe",
        "import": "{ observe }",
        "limit": "1 kB"
      }
    ],
    "peerDependencies": {
      "react": "^15.0.0 || ^16.0.0 || ^17.0.0|| ^18.0.0"
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-react-intersection-observer-9.4.0-f6b6e616e625f9bf255857c5cba9dbf7b1825ec7-integrity/node_modules/react-intersection-observer/package.json",
    "readmeFilename": "README.md",
    "readme": "# react-intersection-observer\n\n[![Version Badge][npm-version-svg]][package-url]\n[![GZipped size][npm-minzip-svg]][bundlephobia-url]\n[![Test][test-image]][test-url] [![License][license-image]][license-url]\n[![Downloads][downloads-image]][downloads-url]\n\nReact implementation of the\n[Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)\nto tell you when an element enters or leaves the viewport. Contains both a\n[Hooks](#hooks-), [render props](#render-props) and\n[plain children](#plain-children) implementation.\n\n**Storybook Demo:**\n[https://react-intersection-observer.vercel.app](https://react-intersection-observer.vercel.app)\n\n## Features\n\n- ü™ù **Hooks or Component API** - With `useInView` it's easier than ever to\n  monitor elements\n- ‚ö°Ô∏è **Optimized performance** - Reuses Intersection Observer instances where\n  possible\n- ‚öôÔ∏è **Matches native API** - Intuitive to use\n- üõ† **Written in TypeScript** - It'll fit right into your existing TypeScript\n  project\n- üß™ **Ready to test** - Mocks the Intersection Observer for easy testing with\n  [Jest](https://jestjs.io/) or [Vitest](https://vitest.dev/)\n- üå≥ **Tree-shakeable** - Only include the parts you use\n- üí• **Tiny bundle** - Around **~1.15kB** for `useInView` and **~1.6kB** for\n  `<InView>`\n\n## Installation\n\nInstall using [Yarn](https://yarnpkg.com):\n\n```sh\nyarn add react-intersection-observer\n```\n\nor NPM:\n\n```sh\nnpm install react-intersection-observer --save\n```\n\n## Usage\n\n### `useInView` hook\n\n```js\n// Use object destructing, so you don't need to remember the exact order\nconst { ref, inView, entry } = useInView(options);\n\n// Or array destructing, making it easy to customize the field names\nconst [ref, inView, entry] = useInView(options);\n```\n\nThe `useInView` hook makes it easy to monitor the `inView` state of your\ncomponents. Call the `useInView` hook with the (optional) [options](#options)\nyou need. It will return an array containing a `ref`, the `inView` status and\nthe current\n[`entry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry).\nAssign the `ref` to the DOM element you want to monitor, and the hook will\nreport the status.\n\n```jsx\nimport React from 'react';\nimport { useInView } from 'react-intersection-observer';\n\nconst Component = () => {\n  const { ref, inView, entry } = useInView({\n    /* Optional options */\n    threshold: 0,\n  });\n\n  return (\n    <div ref={ref}>\n      <h2>{`Header inside viewport ${inView}.`}</h2>\n    </div>\n  );\n};\n```\n\n[![Edit useInView](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/useinview-ud2vo?fontsize=14&hidenavigation=1&theme=dark)\n\n### Render props\n\nTo use the `<InView>` component, you pass it a function. It will be called\nwhenever the state changes, with the new value of `inView`. In addition to the\n`inView` prop, children also receive a `ref` that should be set on the\ncontaining DOM element. This is the element that the Intersection Observer will\nmonitor.\n\nIf you need it, you can also access the\n[`IntersectionObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)\non `entry`, giving you access to all the details about the current intersection\nstate.\n\n```jsx\nimport { InView } from 'react-intersection-observer';\n\nconst Component = () => (\n  <InView>\n    {({ inView, ref, entry }) => (\n      <div ref={ref}>\n        <h2>{`Header inside viewport ${inView}.`}</h2>\n      </div>\n    )}\n  </InView>\n);\n\nexport default Component;\n```\n\n[![Edit InView render props](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/inview-render-props-hvhcb?fontsize=14&hidenavigation=1&theme=dark)\n\n### Plain children\n\nYou can pass any element to the `<InView />`, and it will handle creating the\nwrapping DOM element. Add a handler to the `onChange` method, and control the\nstate in your own component. Any extra props you add to `<InView>` will be\npassed to the HTML element, allowing you set the `className`, `style`, etc.\n\n```jsx\nimport { InView } from 'react-intersection-observer';\n\nconst Component = () => (\n  <InView as=\"div\" onChange={(inView, entry) => console.log('Inview:', inView)}>\n    <h2>Plain children are always rendered. Use onChange to monitor state.</h2>\n  </InView>\n);\n\nexport default Component;\n```\n\n[![Edit InView plain children](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/inview-plain-children-vv51y?fontsize=14&hidenavigation=1&theme=dark)\n\n> **Note**<br>\n> When rendering a plain child, make sure you keep your HTML output semantic.\n> Change the `as` to match the context, and add a `className` to style the\n> `<InView />`. The component does not support Ref Forwarding, so if you need a\n> `ref` to the HTML element, use the Render Props version instead.\n\n## API\n\n### Options\n\nProvide these as the options argument in the `useInView` hook or as props on the\n**`<InView />`** component.\n\n| Name                   | Type                      | Default     | Description                                                                                                                                                                                                                                                                                     |\n| ---------------------- | ------------------------- | ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **root**               | `Element`                 | `document`  | The Intersection Observer interface's read-only root property identifies the Element or Document whose bounds are treated as the bounding box of the viewport for the element which is the observer's target. If the root is `null`, then the bounds of the actual document viewport are used.  |\n| **rootMargin**         | `string`                  | `'0px'`     | Margin around the root. Can have values similar to the CSS margin property, e.g. `\"10px 20px 30px 40px\"` (top, right, bottom, left).                                                                                                                                                            |\n| **threshold**          | `number` or `number[]`    | `0`         | Number between `0` and `1` indicating the percentage that should be visible before triggering. Can also be an array of numbers, to create multiple trigger points.                                                                                                                              |\n| **onChange**           | `(inView, entry) => void` | `undefined` | Call this function whenever the in view state changes. It will receive the `inView` boolean, alongside the current `IntersectionObserverEntry`.                                                                                                                                                 |\n| **trackVisibility** üß™ | `boolean`                 | `false`     | A boolean indicating whether this Intersection Observer will track visibility changes on the target.                                                                                                                                                                                            |\n| **delay** üß™           | `number`                  | `undefined` | A number indicating the minimum delay in milliseconds between notifications from this observer for a given target. This must be set to at least `100` if `trackVisibility` is `true`.                                                                                                           |\n| **skip**               | `boolean`                 | `false`     | Skip creating the IntersectionObserver. You can use this to enable and disable the observer as needed. If `skip` is set while `inView`, the current state will still be kept.                                                                                                                   |\n| **triggerOnce**        | `boolean`                 | `false`     | Only trigger the observer once.                                                                                                                                                                                                                                                                 |\n| **initialInView**      | `boolean`                 | `false`     | Set the initial value of the `inView` boolean. This can be used if you expect the element to be in the viewport to start with, and you want to trigger something when it leaves.                                                                                                                |\n| **fallbackInView**     | `boolean`                 | `undefined` | If the `IntersectionObserver` API isn't available in the client, the default behavior is to throw an Error. You can set a specific fallback behavior, and the `inView` value will be set to this instead of failing. To set a global default, you can set it with the `defaultFallbackInView()` |\n\n### InView Props\n\nThe **`<InView />`** component also accepts the following props:\n\n| Name         | Type                                                 | Default     | Description                                                                                                                                                                                                                                                                                                                    |\n| ------------ | ---------------------------------------------------- | ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **as**       | `string`                                             | `'div'`     | Render the wrapping element as this element. Defaults to `div`.                                                                                                                                                                                                                                                                |\n| **children** | `({ref, inView, entry}) => ReactNode` or `ReactNode` | `undefined` | Children expects a function that receives an object containing the `inView` boolean and a `ref` that should be assigned to the element root. Alternatively pass a plain child, to have the `<InView />` deal with the wrapping element. You will also get the `IntersectionObserverEntry` as `entry`, giving you more details. |\n\n### Intersection Observer v2 üß™\n\nThe new\n[v2 implementation of IntersectionObserver](https://developers.google.com/web/updates/2019/02/intersectionobserver-v2)\nextends the original API, so you can track if the element is covered by another\nelement or has filters applied to it. Useful for blocking clickjacking attempts\nor tracking ad exposure.\n\nTo use it, you'll need to add the new `trackVisibility` and `delay` options.\nWhen you get the `entry` back, you can then monitor if `isVisible` is `true`.\n\n```jsx\nconst TrackVisible = () => {\n  const { ref, entry } = useInView({ trackVisibility: true, delay: 100 });\n  return <div ref={ref}>{entry?.isVisible}</div>;\n};\n```\n\nThis is still a very new addition, so check\n[caniuse](https://caniuse.com/#feat=intersectionobserver-v2) for current browser\nsupport. If `trackVisibility` has been set, and the current browser doesn't\nsupport it, a fallback has been added to always report `isVisible` as `true`.\n\nIt's not added to the TypeScript `lib.d.ts` file yet, so you will also have to\nextend the `IntersectionObserverEntry` with the `isVisible` boolean.\n\n## Recipes\n\nThe `IntersectionObserver` itself is just a simple but powerful tool. Here's a\nfew ideas for how you can use it.\n\n- [Lazy image load](docs/Recipes.md#lazy-image-load)\n- [Trigger animations](docs/Recipes.md#trigger-animations)\n- [Track impressions](docs/Recipes.md#track-impressions) _(Google Analytics, Tag\n  Manager, etc)_\n\n## FAQ\n\n### How can I assign multiple refs to a component?\n\nYou can wrap multiple `ref` assignments in a single `useCallback`:\n\n```jsx\nimport React, { useRef, useCallback } from 'react';\nimport { useInView } from 'react-intersection-observer';\n\nfunction Component(props) {\n  const ref = useRef();\n  const { ref: inViewRef, inView } = useInView();\n\n  // Use `useCallback` so we don't recreate the function on each render\n  const setRefs = useCallback(\n    (node) => {\n      // Ref's from useRef needs to have the node assigned to `current`\n      ref.current = node;\n      // Callback refs, like the one from `useInView`, is a function that takes the node as an argument\n      inViewRef(node);\n    },\n    [inViewRef],\n  );\n\n  return <div ref={setRefs}>Shared ref is visible: {inView}</div>;\n}\n```\n\n### `rootMargin` isn't working as expected\n\nWhen using `rootMargin`, the margin gets added to the current `root` - If your\napplication is running inside a `<iframe>`, or you have defined a custom `root`\nthis will not be the current viewport.\n\nYou can read more about this on these links:\n\n- [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API#The_intersection_root_and_root_margin)\n- [w3c/IntersectionObserver: rootMargin ignored within iframe](https://github.com/w3c/IntersectionObserver/issues/283#issuecomment-507397917)\n- [w3c/IntersectionObserver: Cannot track intersection with an iframe's viewport](https://github.com/w3c/IntersectionObserver/issues/372)\n- [w3c/Support iframe viewport tracking](https://github.com/w3c/IntersectionObserver/pull/465)\n\n## Testing\n\nIn order to write meaningful tests, the `IntersectionObserver` needs to be\nmocked. You can use the included `react-intersection-observer/test-utils` to\nhelp with this. It mocks the `IntersectionObserver`, and includes a few methods\nto assist with faking the `inView` state. When setting the `isIntersecting`\nvalue you can pass either a `boolean` value or a threshold between 0 and 1.It\nwil emulate the real IntersectionObserver, allowing you to validate that your\ncomponents are behaving as expected.\n\n| Method                                        | Description                                                                                                                                                                       |\n| --------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `mockAllIsIntersecting(isIntersecting)`       | Set `isIntersecting` on all current Intersection Observer instances. The value of `isIntersecting` should be either a `boolean` or a threshold between 0 and 1.                   |\n| `mockIsIntersecting(element, isIntersecting)` | Set `isIntersecting` for the Intersection Observer of a specific `element`. The value of `isIntersecting` should be either a `boolean` or a threshold between 0 and 1.            |\n| `intersectionMockInstance(element)`           | Call the `intersectionMockInstance` method with an element, to get the (mocked) `IntersectionObserver` instance. You can use this to spy on the `observe` and`unobserve` methods. |\n| `setupIntersectionMocking(mockFn)`            | Mock the `IntersectionObserver`, so we can interact with them in tests - Should be called in `beforeEach`. (**Done automatically in Jest environment**)                           |\n| `resetIntersectionMocking()`                  | Reset the mocks on `IntersectionObserver` - Should be called in `afterEach`. (**Done automatically in Jest environment**)                                                         |\n\n### Testing Libraries\n\nThis library comes with built-in support for writing tests in both\n[Jest](https://jestjs.io/) and [Vitest](https://vitest.dev/)\n\n#### Jest\n\nTesting with Jest should work out of the box. Just import the\n`react-intersection-observer/test-utils` in your test files, and you can use the\nmocking methods.\n\n#### Vitest\n\nIf you're running Vitest with [globals](https://vitest.dev/config/#globals),\nthen it'll automatically mock the IntersectionObserver, just like running with\nJest. Otherwise, you'll need to manually setup/reset the mocking in either the\nindividual tests, or a [setup file](https://vitest.dev/config/#setupfiles).\n\n```js\nimport { vi, beforeEach, afterEach } from 'vitest';\nimport {\n  setupIntersectionMocking,\n  resetIntersectionMocking,\n} from 'react-intersection-observer/test-utils';\n\nbeforeEach(() => {\n  setupIntersectionMocking(jest.fn);\n});\n\nafterEach(() => {\n  resetIntersectionMocking();\n});\n```\n\nYou only need to do this if the test environment does not support\n`beforeEach` globally, alongside either `jest.fn` or `vi.fn`.\n\n#### Other Testing Libraries\n\nSee the instructions for [Vitest](#vitest). You should be able to use a similar\nsetup/reset code, adapted to the testing library you are using. Failing that,\ncopy the code from [test-utils.ts][test-utils-url], and make your own version.\n\n### Fallback Behavior\n\nYou can create a\n[Jest setup file](https://jestjs.io/docs/configuration#setupfilesafterenv-array)\nthat leverages the\n[unsupported fallback](https://github.com/thebuilder/react-intersection-observer#unsupported-fallback)\noption. In this case, you can override the `IntersectionObserver` in test files\nwere you actively import `react-intersection-observer/test-utils`.\n\n**test-setup.js**\n\n```js\nimport { defaultFallbackInView } from 'react-intersection-observer';\n\ndefaultFallbackInView(true); // or `false` - whichever consistent behavior makes the most sense for your use case.\n```\n\nAlternatively, you can mock the Intersection Observer in all tests with a global\nsetup file. Add `react-intersection-observer/test-utils` to\n[setupFilesAfterEnv](https://jestjs.io/docs/configuration#setupfilesafterenv-array)\nin the Jest config, or [setupFiles](https://vitest.dev/config/#setupfiles) in\nVitest.\n\n```js\nmodule.exports = {\n  setupFilesAfterEnv: ['react-intersection-observer/test-utils'],\n};\n```\n\n### Test Example\n\n```js\nimport React from 'react';\nimport { screen, render } from '@testing-library/react';\nimport { useInView } from 'react-intersection-observer';\nimport {\n  mockAllIsIntersecting,\n  mockIsIntersecting,\n  intersectionMockInstance,\n} from 'react-intersection-observer/test-utils';\n\nconst HookComponent = ({ options }) => {\n  const { ref, inView } = useInView(options);\n  return (\n    <div ref={ref} id=\"wrapper\">\n      {inView.toString()}\n    </div>\n  );\n};\n\ntest('should create a hook inView', () => {\n  render(<HookComponent />);\n\n  // This causes all (existing) IntersectionObservers to be set as intersecting\n  mockAllIsIntersecting(true);\n  screen.getByText('true');\n});\n\ntest('should create a hook inView with threshold', () => {\n  render(<HookComponent options={{ threshold: 0.3 }} />);\n\n  mockAllIsIntersecting(0.1);\n  screen.getByText('false');\n\n  // Once the threshold has been passed, it will trigger inView.\n  mockAllIsIntersecting(0.3);\n  screen.getByText('true');\n});\n\ntest('should mock intersecing on specific hook', () => {\n  render(<HookComponent />);\n  const wrapper = screen.getByTestId('wrapper');\n\n  // Set the intersection state on the wrapper.\n  mockIsIntersecting(wrapper, 0.5);\n  screen.getByText('true');\n});\n\ntest('should create a hook and call observe', () => {\n  const { getByTestId } = render(<HookComponent />);\n  const wrapper = getByTestId('wrapper');\n  // Access the `IntersectionObserver` instance for the wrapper Element.\n  const instance = intersectionMockInstance(wrapper);\n\n  expect(instance.observe).toHaveBeenCalledWith(wrapper);\n});\n```\n\n## Intersection Observer\n\n[Intersection Observer](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)\nis the API used to determine if an element is inside the viewport or not.\n[Browser support is excellent](http://caniuse.com/#feat=intersectionobserver) -\nWith\n[Safari adding support in 12.1](https://webkit.org/blog/8718/new-webkit-features-in-safari-12-1/),\nall major browsers now support Intersection Observers natively. Add the\npolyfill, so it doesn't break on older versions of iOS and IE11.\n\n### Unsupported fallback\n\nIf the client doesn't have support for the `IntersectionObserver`, then the\ndefault behavior is to throw an error. This will crash the React application,\nunless you capture it with an Error Boundary.\n\nIf you prefer, you can set a fallback `inView` value to use if the\n`IntersectionObserver` doesn't exist. This will make\n`react-intersection-observer` fail gracefully, but you must ensure your\napplication can correctly handle all your observers firing either `true` or\n`false` at the same time.\n\nYou can set the fallback globally:\n\n```js\nimport { defaultFallbackInView } from 'react-intersection-observer';\ndefaultFallbackInView(true); // or 'false'\n```\n\nYou can also define the fallback locally on `useInView` or `<InView>` as an\noption. This will override the global fallback value.\n\n```jsx\nimport React from 'react';\nimport { useInView } from 'react-intersection-observer';\n\nconst Component = () => {\n  const { ref, inView, entry } = useInView({\n    fallbackInView: true,\n  });\n\n  return (\n    <div ref={ref}>\n      <h2>{`Header inside viewport ${inView}.`}</h2>\n    </div>\n  );\n};\n```\n\n### Polyfill\n\nYou can import the\n[polyfill](https://www.npmjs.com/package/intersection-observer) directly or use\na service like [polyfill.io](https://polyfill.io/v2/docs/) to add it when\nneeded.\n\n```sh\nyarn add intersection-observer\n```\n\nThen import it in your app:\n\n```js\nimport 'intersection-observer';\n```\n\nIf you are using Webpack (or similar) you could use\n[dynamic imports](https://webpack.js.org/api/module-methods/#import-), to load\nthe Polyfill only if needed. A basic implementation could look something like\nthis:\n\n```js\n/**\n * Do feature detection, to figure out which polyfills needs to be imported.\n **/\nasync function loadPolyfills() {\n  if (typeof window.IntersectionObserver === 'undefined') {\n    await import('intersection-observer');\n  }\n}\n```\n\n## Low level API\n\nYou can access the [`observe`](src/observe.ts) method, that\n`react-intersection-observer` uses internally to create and destroy\nIntersectionObserver instances. This allows you to handle more advanced use\ncases, where you need full control over when and how observers are created.\n\n```js\nimport { observe } from 'react-intersection-observer';\nconst destroy = observe(element, callback, options);\n```\n\n| Name         | Type                       | Required | Description                                                |\n| ------------ | -------------------------- | -------- | ---------------------------------------------------------- |\n| **element**  | `Element`                  | true     | DOM element to observe                                     |\n| **callback** | `ObserverInstanceCallback` | true     | The callback function that Intersection Observer will call |\n| **options**  | `IntersectionObserverInit` | false    | The options for the Intersection Observer                  |\n\nThe `observe` method returns an `unobserve` function, that you must call in\norder to destroy the observer again.\n\n> **Warning**<br>\n> You most likely won't need this, but it can be useful if you need to handle\n> IntersectionObservers outside React, or need full control over how instances\n> are created.\n\n[package-url]: https://npmjs.org/package/react-intersection-observer\n[npm-version-svg]: https://img.shields.io/npm/v/react-intersection-observer.svg\n[npm-minzip-svg]:\n  https://img.shields.io/bundlephobia/minzip/react-intersection-observer.svg\n[bundlephobia-url]:\n  https://bundlephobia.com/result?p=react-intersection-observer\n[license-image]: http://img.shields.io/npm/l/react-intersection-observer.svg\n[license-url]: LICENSE\n[downloads-image]: http://img.shields.io/npm/dm/react-intersection-observer.svg\n[downloads-url]:\n  http://npm-stat.com/charts.html?package=react-intersection-observer\n[test-image]:\n  https://github.com/thebuilder/react-intersection-observer/workflows/Test/badge.svg\n[test-url]:\n  https://github.com/thebuilder/react-intersection-observer/actions?query=workflow%3ATest\n[test-utils-url]:\n  https://github.com/thebuilder/react-intersection-observer/blob/feat/vitest/src/test-utils.ts\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2022 React Intersection Observer authors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/react-intersection-observer/-/react-intersection-observer-9.4.0.tgz#f6b6e616e625f9bf255857c5cba9dbf7b1825ec7",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/react-intersection-observer/-/react-intersection-observer-9.4.0.tgz",
    "hash": "f6b6e616e625f9bf255857c5cba9dbf7b1825ec7",
    "integrity": "sha512-v0403CmomOVlzhqFXlzOxg0ziLcVq8mfbP0AwAcEQWgZmR2OulOT79Ikznw4UlB3N+jlUYqLMe4SDHUOyp0t2A==",
    "registry": "npm",
    "packageName": "react-intersection-observer",
    "cacheIntegrity": "sha512-v0403CmomOVlzhqFXlzOxg0ziLcVq8mfbP0AwAcEQWgZmR2OulOT79Ikznw4UlB3N+jlUYqLMe4SDHUOyp0t2A== sha1-9rbmFuYl+b8lWFfFy6nb97GCXsc="
  },
  "registry": "npm",
  "hash": "f6b6e616e625f9bf255857c5cba9dbf7b1825ec7"
}