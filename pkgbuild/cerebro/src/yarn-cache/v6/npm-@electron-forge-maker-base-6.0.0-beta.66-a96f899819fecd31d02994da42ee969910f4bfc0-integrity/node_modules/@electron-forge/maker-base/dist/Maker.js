"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _path = _interopRequireDefault(require("path"));
var _which = _interopRequireDefault(require("which"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class Maker {
    constructor(configFetcher = {}, providedPlatforms){
        this.configFetcher = configFetcher;
        this.providedPlatforms = providedPlatforms;
        this.requiredExternalBinaries = [];
        Object.defineProperty(this, '__isElectronForgeMaker', {
            value: true,
            enumerable: false,
            configurable: false
        });
    }
    get platforms() {
        if (this.providedPlatforms) return this.providedPlatforms;
        return this.defaultPlatforms;
    }
    // TODO: Remove this, it is an eye-sore and is a nasty hack to provide forge
    //       v5 style functionality in the new API
    prepareConfig(targetArch) {
        if (typeof this.configFetcher === 'function') {
            this.config = this.configFetcher(targetArch);
        } else {
            this.config = this.configFetcher;
        }
    }
    /**
   * Makers must implement this method and return true or false indicating whether
   * this maker can be run on the current platform.  Normally this is just a process.platform
   * check but it can be a deeper check for dependencies like fake-root or other
   * required external build tools.
   *
   * If the issue is a missing dependency you should log out a HELPFUL error message
   * telling the developer exactly what is missing and if possible how to get it.
   */ isSupportedOnCurrentPlatform() {
        if (this.isSupportedOnCurrentPlatform === Maker.prototype.isSupportedOnCurrentPlatform) {
            throw new Error(`Maker ${this.name} did not implement the isSupportedOnCurrentPlatform method`);
        }
        return true;
    }
    /**
   * Makers must implement this method and return an array of absolute paths
   * to the artifacts generated by your maker
   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async make(opts) {
        if (this.make === Maker.prototype.make) {
            throw new Error(`Maker ${this.name} did not implement the make method`);
        }
        return [];
    }
    /**
   * Helpers
   */ /**
   * Ensures the directory exists and is forced to be empty.
   *
   * I.e. If the directory already exists it is deleted and recreated, this
   * is a destructive operation
   */ async ensureDirectory(dir) {
        if (await _fsExtra.default.pathExists(dir)) {
            await _fsExtra.default.remove(dir);
        }
        return _fsExtra.default.mkdirs(dir);
    }
    /**
   * Ensures the path to the file exists and the file does not exist
   *
   * I.e. If the file already exists it is deleted and the path created
   */ async ensureFile(file) {
        if (await _fsExtra.default.pathExists(file)) {
            await _fsExtra.default.remove(file);
        }
        await _fsExtra.default.mkdirs(_path.default.dirname(file));
    }
    /**
   * Checks if the specified binaries exist, which are required for the maker to be used.
   */ externalBinariesExist() {
        return this.requiredExternalBinaries.every((binary)=>_which.default.sync(binary, {
                nothrow: true
            }) !== null
        );
    }
    /**
   * Throws an error if any of the binaries don't exist.
   */ ensureExternalBinariesExist() {
        if (!this.externalBinariesExist()) {
            throw new Error(`Cannot make for ${this.name}, the following external binaries need to be installed: ${this.requiredExternalBinaries.join(', ')}`);
        }
    }
    /**
   * Checks if the given module is installed, used for testing if optional dependencies
   * are installed or not
   */ isInstalled(module) {
        try {
            // eslint-disable-next-line global-require, import/no-dynamic-require
            require(module);
            return true;
        } catch (e) {
            // Package doesn't exist -- must not be installable on this platform
            return false;
        }
    }
    /**
   * Normalize the given semver-formatted version to a 4-part dot delimited version number without
   * prerelease information for use in Windows apps.
   */ normalizeWindowsVersion(version) {
        const noPrerelease = version.replace(/-.*/, '');
        return `${noPrerelease}.0`;
    }
}
exports.default = Maker;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NYWtlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGb3JnZUFyY2gsIEZvcmdlQ29uZmlnLCBGb3JnZVBsYXRmb3JtLCBJRm9yZ2VNYWtlciB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHdoaWNoIGZyb20gJ3doaWNoJztcblxuZXhwb3J0IHR5cGUgRW1wdHlDb25maWcgPSBSZWNvcmQ8c3RyaW5nLCBuZXZlcj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFrZXJPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBkaXJlY3RvcnkgY29udGFpbmluZyB0aGUgcGFja2FnZWQgRWxlY3Ryb24gYXBwbGljYXRpb25cbiAgICovXG4gIGRpcjogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGRpcmVjdG9yeSB5b3Ugc2hvdWxkIHB1dCBhbGwgeW91ciBhcnRpZmFjdHMgaW4gKHBvdGVudGlhbGx5IGluIHN1YiBmb2xkZXJzKVxuICAgKiBOT1RFOiB0aGlzIGRpcmVjdG9yeSBpcyBub3QgZ3VhcnVudGVlZCB0byBhbHJlYWR5IGV4aXN0XG4gICAqL1xuICBtYWtlRGlyOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcmVzb2x2ZWQgaHVtYW4gZnJpZW5kbHkgbmFtZSBvZiB0aGUgcHJvamVjdFxuICAgKi9cbiAgYXBwTmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHRhcmdldCBwbGF0Zm9ybSB5b3Ugc2hvdWxkIG1ha2UgZm9yXG4gICAqL1xuICB0YXJnZXRQbGF0Zm9ybTogRm9yZ2VQbGF0Zm9ybTtcbiAgLyoqXG4gICAqIFRoZSB0YXJnZXQgYXJjaGl0ZWN0dXJlIHlvdSBzaG91bGQgbWFrZSBmb3JcbiAgICovXG4gIHRhcmdldEFyY2g6IEZvcmdlQXJjaDtcbiAgLyoqXG4gICAqIEZ1bGx5IHJlc29sdmVkIGZvcmdlIGNvbmZpZ3VyYXRpb24sIHlvdSBzaG91bGRuJ3QgcmVhbGx5IG5lZWQgdGhpc1xuICAgKi9cbiAgZm9yZ2VDb25maWc6IEZvcmdlQ29uZmlnO1xuICAvKipcbiAgICogVGhlIGFwcGxpY2F0aW9uJ3MgcGFja2FnZS5qc29uIGZpbGVcbiAgICovXG4gIHBhY2thZ2VKU09OOiBhbnk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxufVxuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBNYWtlcjxDPiBpbXBsZW1lbnRzIElGb3JnZU1ha2VyIHtcbiAgcHVibGljIGNvbmZpZyE6IEM7XG5cbiAgcHVibGljIGFic3RyYWN0IG5hbWU6IHN0cmluZztcblxuICBwdWJsaWMgYWJzdHJhY3QgZGVmYXVsdFBsYXRmb3JtczogRm9yZ2VQbGF0Zm9ybVtdO1xuXG4gIHB1YmxpYyByZXF1aXJlZEV4dGVybmFsQmluYXJpZXM6IHN0cmluZ1tdID0gW107XG5cbiAgX19pc0VsZWN0cm9uRm9yZ2VNYWtlciE6IHRydWU7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb25maWdGZXRjaGVyOiBDIHwgKChhcmNoOiBGb3JnZUFyY2gpID0+IEMpID0ge30gYXMgQywgcHJvdGVjdGVkIHByb3ZpZGVkUGxhdGZvcm1zPzogRm9yZ2VQbGF0Zm9ybVtdKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfX2lzRWxlY3Ryb25Gb3JnZU1ha2VyJywge1xuICAgICAgdmFsdWU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICBnZXQgcGxhdGZvcm1zKCk6IEZvcmdlUGxhdGZvcm1bXSB7XG4gICAgaWYgKHRoaXMucHJvdmlkZWRQbGF0Zm9ybXMpIHJldHVybiB0aGlzLnByb3ZpZGVkUGxhdGZvcm1zO1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRQbGF0Zm9ybXM7XG4gIH1cblxuICAvLyBUT0RPOiBSZW1vdmUgdGhpcywgaXQgaXMgYW4gZXllLXNvcmUgYW5kIGlzIGEgbmFzdHkgaGFjayB0byBwcm92aWRlIGZvcmdlXG4gIC8vICAgICAgIHY1IHN0eWxlIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIG5ldyBBUElcbiAgcHJlcGFyZUNvbmZpZyh0YXJnZXRBcmNoOiBGb3JnZUFyY2gpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuY29uZmlnRmV0Y2hlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jb25maWcgPSAodGhpcy5jb25maWdGZXRjaGVyIGFzIHVua25vd24gYXMgKGFyY2g6IEZvcmdlQXJjaCkgPT4gQykodGFyZ2V0QXJjaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29uZmlnID0gdGhpcy5jb25maWdGZXRjaGVyIGFzIEM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VycyBtdXN0IGltcGxlbWVudCB0aGlzIG1ldGhvZCBhbmQgcmV0dXJuIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyXG4gICAqIHRoaXMgbWFrZXIgY2FuIGJlIHJ1biBvbiB0aGUgY3VycmVudCBwbGF0Zm9ybS4gIE5vcm1hbGx5IHRoaXMgaXMganVzdCBhIHByb2Nlc3MucGxhdGZvcm1cbiAgICogY2hlY2sgYnV0IGl0IGNhbiBiZSBhIGRlZXBlciBjaGVjayBmb3IgZGVwZW5kZW5jaWVzIGxpa2UgZmFrZS1yb290IG9yIG90aGVyXG4gICAqIHJlcXVpcmVkIGV4dGVybmFsIGJ1aWxkIHRvb2xzLlxuICAgKlxuICAgKiBJZiB0aGUgaXNzdWUgaXMgYSBtaXNzaW5nIGRlcGVuZGVuY3kgeW91IHNob3VsZCBsb2cgb3V0IGEgSEVMUEZVTCBlcnJvciBtZXNzYWdlXG4gICAqIHRlbGxpbmcgdGhlIGRldmVsb3BlciBleGFjdGx5IHdoYXQgaXMgbWlzc2luZyBhbmQgaWYgcG9zc2libGUgaG93IHRvIGdldCBpdC5cbiAgICovXG4gIGlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0oKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSA9PT0gTWFrZXIucHJvdG90eXBlLmlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWFrZXIgJHt0aGlzLm5hbWV9IGRpZCBub3QgaW1wbGVtZW50IHRoZSBpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtIG1ldGhvZGApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcnMgbXVzdCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgYW5kIHJldHVybiBhbiBhcnJheSBvZiBhYnNvbHV0ZSBwYXRoc1xuICAgKiB0byB0aGUgYXJ0aWZhY3RzIGdlbmVyYXRlZCBieSB5b3VyIG1ha2VyXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGFzeW5jIG1ha2Uob3B0czogTWFrZXJPcHRpb25zKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGlmICh0aGlzLm1ha2UgPT09IE1ha2VyLnByb3RvdHlwZS5tYWtlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ha2VyICR7dGhpcy5uYW1lfSBkaWQgbm90IGltcGxlbWVudCB0aGUgbWFrZSBtZXRob2RgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlcnNcbiAgICovXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhlIGRpcmVjdG9yeSBleGlzdHMgYW5kIGlzIGZvcmNlZCB0byBiZSBlbXB0eS5cbiAgICpcbiAgICogSS5lLiBJZiB0aGUgZGlyZWN0b3J5IGFscmVhZHkgZXhpc3RzIGl0IGlzIGRlbGV0ZWQgYW5kIHJlY3JlYXRlZCwgdGhpc1xuICAgKiBpcyBhIGRlc3RydWN0aXZlIG9wZXJhdGlvblxuICAgKi9cbiAgYXN5bmMgZW5zdXJlRGlyZWN0b3J5KGRpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMoZGlyKSkge1xuICAgICAgYXdhaXQgZnMucmVtb3ZlKGRpcik7XG4gICAgfVxuICAgIHJldHVybiBmcy5ta2RpcnMoZGlyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoZSBwYXRoIHRvIHRoZSBmaWxlIGV4aXN0cyBhbmQgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3RcbiAgICpcbiAgICogSS5lLiBJZiB0aGUgZmlsZSBhbHJlYWR5IGV4aXN0cyBpdCBpcyBkZWxldGVkIGFuZCB0aGUgcGF0aCBjcmVhdGVkXG4gICAqL1xuICBhc3luYyBlbnN1cmVGaWxlKGZpbGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKGZpbGUpKSB7XG4gICAgICBhd2FpdCBmcy5yZW1vdmUoZmlsZSk7XG4gICAgfVxuICAgIGF3YWl0IGZzLm1rZGlycyhwYXRoLmRpcm5hbWUoZmlsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGJpbmFyaWVzIGV4aXN0LCB3aGljaCBhcmUgcmVxdWlyZWQgZm9yIHRoZSBtYWtlciB0byBiZSB1c2VkLlxuICAgKi9cbiAgZXh0ZXJuYWxCaW5hcmllc0V4aXN0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnJlcXVpcmVkRXh0ZXJuYWxCaW5hcmllcy5ldmVyeSgoYmluYXJ5KSA9PiB3aGljaC5zeW5jKGJpbmFyeSwgeyBub3Rocm93OiB0cnVlIH0pICE9PSBudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IG9mIHRoZSBiaW5hcmllcyBkb24ndCBleGlzdC5cbiAgICovXG4gIGVuc3VyZUV4dGVybmFsQmluYXJpZXNFeGlzdCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuZXh0ZXJuYWxCaW5hcmllc0V4aXN0KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG1ha2UgZm9yICR7dGhpcy5uYW1lfSwgdGhlIGZvbGxvd2luZyBleHRlcm5hbCBiaW5hcmllcyBuZWVkIHRvIGJlIGluc3RhbGxlZDogJHt0aGlzLnJlcXVpcmVkRXh0ZXJuYWxCaW5hcmllcy5qb2luKCcsICcpfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIG1vZHVsZSBpcyBpbnN0YWxsZWQsIHVzZWQgZm9yIHRlc3RpbmcgaWYgb3B0aW9uYWwgZGVwZW5kZW5jaWVzXG4gICAqIGFyZSBpbnN0YWxsZWQgb3Igbm90XG4gICAqL1xuICBpc0luc3RhbGxlZChtb2R1bGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2xvYmFsLXJlcXVpcmUsIGltcG9ydC9uby1keW5hbWljLXJlcXVpcmVcbiAgICAgIHJlcXVpcmUobW9kdWxlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIFBhY2thZ2UgZG9lc24ndCBleGlzdCAtLSBtdXN0IG5vdCBiZSBpbnN0YWxsYWJsZSBvbiB0aGlzIHBsYXRmb3JtXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gc2VtdmVyLWZvcm1hdHRlZCB2ZXJzaW9uIHRvIGEgNC1wYXJ0IGRvdCBkZWxpbWl0ZWQgdmVyc2lvbiBudW1iZXIgd2l0aG91dFxuICAgKiBwcmVyZWxlYXNlIGluZm9ybWF0aW9uIGZvciB1c2UgaW4gV2luZG93cyBhcHBzLlxuICAgKi9cbiAgbm9ybWFsaXplV2luZG93c1ZlcnNpb24odmVyc2lvbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBub1ByZXJlbGVhc2UgPSB2ZXJzaW9uLnJlcGxhY2UoLy0uKi8sICcnKTtcbiAgICByZXR1cm4gYCR7bm9QcmVyZWxlYXNlfS4wYDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk1ha2VyIiwiY29uZmlnRmV0Y2hlciIsInByb3ZpZGVkUGxhdGZvcm1zIiwicmVxdWlyZWRFeHRlcm5hbEJpbmFyaWVzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJwbGF0Zm9ybXMiLCJkZWZhdWx0UGxhdGZvcm1zIiwicHJlcGFyZUNvbmZpZyIsInRhcmdldEFyY2giLCJjb25maWciLCJpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtIiwicHJvdG90eXBlIiwiRXJyb3IiLCJuYW1lIiwibWFrZSIsIm9wdHMiLCJlbnN1cmVEaXJlY3RvcnkiLCJkaXIiLCJmcyIsInBhdGhFeGlzdHMiLCJyZW1vdmUiLCJta2RpcnMiLCJlbnN1cmVGaWxlIiwiZmlsZSIsInBhdGgiLCJkaXJuYW1lIiwiZXh0ZXJuYWxCaW5hcmllc0V4aXN0IiwiZXZlcnkiLCJiaW5hcnkiLCJ3aGljaCIsInN5bmMiLCJub3Rocm93IiwiZW5zdXJlRXh0ZXJuYWxCaW5hcmllc0V4aXN0Iiwiam9pbiIsImlzSW5zdGFsbGVkIiwibW9kdWxlIiwicmVxdWlyZSIsImUiLCJub3JtYWxpemVXaW5kb3dzVmVyc2lvbiIsInZlcnNpb24iLCJub1ByZXJlbGVhc2UiLCJyZXBsYWNlIl0sIm1hcHBpbmdzIjoiOzs7OztBQUNlLEdBQVUsQ0FBVixRQUFVO0FBQ1IsR0FBTSxDQUFOLEtBQU07QUFDTCxHQUFPLENBQVAsTUFBTzs7Ozs7O01Bb0NLQSxLQUFLO2dCQVdiQyxhQUEyQyxHQUFHLENBQUMsQ0FBQyxFQUFpQkMsaUJBQW1DLENBQUUsQ0FBQzthQUF2R0QsYUFBMkMsR0FBM0NBLGFBQTJDO2FBQXNCQyxpQkFBbUMsR0FBbkNBLGlCQUFtQztRQVgzRyxJQWtJZCxDQTNIUUMsd0JBQXdCLEdBQWEsQ0FBQyxDQUFDO1FBSzVDQyxNQUFNLENB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