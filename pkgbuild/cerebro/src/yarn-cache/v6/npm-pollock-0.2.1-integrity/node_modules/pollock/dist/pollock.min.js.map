{"version":3,"file":"pollock.min.js","sources":["../src/pollock.js"],"sourcesContent":["/*\n * Copyright (C) 2018 Alasdair Mercer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n'use strict';\n\n/**\n * Assigns an abstract method with a given name to the specified <code>type</code> based on the <code>options</code>\n * provided which, when called, will result in an error containing a suitable error being thrown. The aim is to quickly\n * highlight to consumers of your API that they an abstract method has not been implemented in a fail-fast fashion.\n *\n * If the <code>typeName</code> option is specified, it will be used instead of the name of <code>type</code>. If\n * <code>type</code> has no name, for whatever reason, <code>\"&lt;anonymous&gt;\"</code> will be used.\n *\n * If the <code>static</code> option is enabled, the created abstract method will assigned directly to <code>type</code>\n * instead of <code>type.prototype</code>.\n *\n * While the default behaviour is synchronous in design, as it simply throws the error, it may be necessary to support\n * reporting the error using asynchronous patterns. The <code>callback</code> option can be specifed to indicate the\n * expected index of the callback function to be passed to the abstract method. This index can be negative if it should\n * be applied from the end of the argument list instead of the beginning. Once identified, the abstract method will\n * invoke the callback function with the error as the first argument. Alternatively, the <code>promise</code> option can\n * be enabled for the method to return a rejected ECMAScript 2015 <code>Promise</code> instead.\n *\n * Regardless of which asynchronous pattern is used, both options only indicate a preference. If no callback function is\n * found at the specified index or if the current environment does not support promises, the abstract method will fall\n * back on the default behaviour of simply throwing the error.\n *\n * @param {Function} type - the constructor function to which the abstract method is to be assigned\n * @param {string} methodName - the name of the abstract method to be assigned\n * @param {pollock~Options} [options] - the options to be used\n * @return {void}\n * @public\n */\nfunction pollock(type, methodName, options) {\n  if (!options) {\n    options = {};\n  }\n\n  function abstractMethod() {\n    var typeName = options.typeName || type.name || '<anonymous>';\n    var separator = options.static ? '.' : '#';\n    var error = new Error(typeName + separator + methodName + ' abstract method is not implemented');\n    var callback;\n\n    if (options.callback != null && (callback = findCallback(arguments, options.callback))) {\n      return callback(error);\n    } else if (options.promise && typeof Promise !== 'undefined') {\n      return Promise.reject(error);\n    }\n\n    throw error;\n  }\n\n  if (options.static) {\n    type[methodName] = abstractMethod;\n  } else {\n    type.prototype[methodName] = abstractMethod;\n  }\n}\n\nfunction findCallback(args, index) {\n  if (index < 0) {\n    index = args.length + index;\n  }\n  index = Math.max(index, 0);\n\n  var callback = args[index];\n\n  return typeof callback === 'function' ? callback : null;\n}\n\nmodule.exports = pollock;\n\n/**\n * The options that can be passed to <code>pollock</code>.\n *\n * @typedef {Object} pollock~Options\n * @property {number} [callback] - The index of callback function argument passed to the abstract method to which the\n * error should be passed as the first argument, where possible. If negative, the index will be taken from the end of\n * the arguments.\n * @property {boolean} [promise] - <code>true</code> to prefer that the abstract method to return a rejected ES2015\n * <code>Promise</code>, where supported, instead of throwing the error; otherwise <code>false</code>.\n * @property {boolean} [static] - <code>true</code> for the abstract method to be applied directly to <code>type</code>;\n * <code>false</code> for it to be applied to <code>type.prototype</code>.\n * @property {string} [typeName] - The name to be used in the error message instead of the one derived from\n * <code>type</code>.\n */\n"],"names":["type","methodName","options","abstractMethod","callback","typeName","name","separator","static","error","Error","args","index","length","Math","max","findCallback","arguments","promise","Promise","reject","prototype"],"mappings":";oMAoDA,SAAiBA,EAAMC,EAAYC,GAKjC,SAASC,IACP,IAGIC,EAHAC,EAAWH,EAAQG,UAAYL,EAAKM,MAAQ,cAC5CC,EAAYL,EAAQM,OAAS,IAAM,IACnCC,EAAQ,IAAIC,MAAML,EAAWE,EAAYN,EAAa,uCAG1D,GAAwB,MAApBC,EAAQE,WAAqBA,EAgBrC,SAAsBO,EAAMC,GACtBA,EAAQ,IACVA,EAAQD,EAAKE,OAASD,GAExBA,EAAQE,KAAKC,IAAIH,EAAO,GAExB,IAAIR,EAAWO,EAAKC,GAEpB,MAA2B,mBAAbR,EAA0BA,EAAW,KAxBLY,CAAaC,UAAWf,EAAQE,WAC1E,OAAOA,EAASK,GACX,GAAIP,EAAQgB,SAA8B,oBAAZC,QACnC,OAAOA,QAAQC,OAAOX,GAGxB,MAAMA,EAhBHP,IACHA,EAAU,IAkBRA,EAAQM,OACVR,EAAKC,GAAcE,EAEnBH,EAAKqB,UAAUpB,GAAcE"}