"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "StartOptions", {
    enumerable: true,
    get: function() {
        return _sharedTypes.StartOptions;
    }
});
exports.default = void 0;
var _asyncOra = require("@electron-forge/async-ora");
var _chalk = _interopRequireDefault(require("chalk"));
var _debug = _interopRequireDefault(require("debug"));
var _sharedTypes = require("@electron-forge/shared-types");
var _childProcess = require("child_process");
var _electronVersion = require("../util/electron-version");
var _forgeConfig = _interopRequireDefault(require("../util/forge-config"));
var _electronExecutable = _interopRequireDefault(require("../util/electron-executable"));
var _readPackageJson = require("../util/read-package-json");
var _rebuild = _interopRequireDefault(require("../util/rebuild"));
var _resolveDir = _interopRequireDefault(require("../util/resolve-dir"));
var _hook = require("../util/hook");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const d = (0, _debug).default('electron-forge:start');
var _default = async ({ dir =process.cwd() , appPath ='.' , interactive =false , enableLogging =false , args =[] , runAsNode =false , inspect =false , inspectBrk =false  })=>{
    _asyncOra.asyncOra.interactive = interactive;
    // Since the `start` command is meant to be long-living (i.e. run forever,
    // until interrupted) we should enable this to keep stdin flowing after ora
    // completes. For more context:
    // https://github.com/electron-userland/electron-forge/issues/2319
    _asyncOra.asyncOra.keepStdinFlowing = true;
    await (0, _asyncOra).asyncOra('Locating Application', async ()=>{
        const resolvedDir = await (0, _resolveDir).default(dir);
        if (!resolvedDir) {
            throw new Error('Failed to locate startable Electron application');
        }
        dir = resolvedDir;
    });
    const forgeConfig = await (0, _forgeConfig).default(dir);
    const packageJSON = await (0, _readPackageJson).readMutatedPackageJson(dir, forgeConfig);
    if (!packageJSON.version) {
        throw new Error(`Please set your application's 'version' in '${dir}/package.json'.`);
    }
    const platform = process.env.npm_config_platform || process.platform;
    const arch = process.env.npm_config_arch || process.arch;
    await (0, _rebuild).default(dir, await (0, _electronVersion).getElectronVersion(dir, packageJSON), platform, arch, forgeConfig.electronRebuildConfig);
    await (0, _hook).runHook(forgeConfig, 'generateAssets', platform, arch);
    let lastSpawned = null;
    const forgeSpawn = async ()=>{
        let electronExecPath = null;
        // If a plugin has taken over the start command let's stop here
        const spawnedPluginChild = await forgeConfig.pluginInterface.overrideStartLogic({
            dir,
            appPath,
            interactive,
            enableLogging,
            args,
            runAsNode,
            inspect,
            inspectBrk
        });
        let prefixArgs = [];
        if (typeof spawnedPluginChild === 'string') {
            electronExecPath = spawnedPluginChild;
        } else if (Array.isArray(spawnedPluginChild)) {
            [electronExecPath, ...prefixArgs] = spawnedPluginChild;
        } else if (spawnedPluginChild) {
            await (0, _hook).runHook(forgeConfig, 'postStart', spawnedPluginChild);
            return spawnedPluginChild;
        }
        if (!electronExecPath) {
            electronExecPath = await (0, _electronExecutable).default(dir, packageJSON);
        }
        d('Electron binary path:', electronExecPath);
        const spawnOpts = {
            cwd: dir,
            stdio: 'inherit',
            env: {
                ...process.env,
                ...enableLogging ? {
                    ELECTRON_ENABLE_LOGGING: 'true',
                    ELECTRON_ENABLE_STACK_DUMPING: 'true'
                } : {}
            }
        };
        if (runAsNode) {
            spawnOpts.env.ELECTRON_RUN_AS_NODE = 'true';
        } else {
            delete spawnOpts.env.ELECTRON_RUN_AS_NODE;
        }
        if (inspect) {
            args = [
                '--inspect'
            ].concat(args);
        }
        if (inspectBrk) {
            args = [
                '--inspect-brk'
            ].concat(args);
        }
        let spawned;
        await (0, _asyncOra).asyncOra('Launching Application', async ()=>{
            spawned = (0, _childProcess).spawn(electronExecPath, prefixArgs.concat([
                appPath
            ]).concat(args), spawnOpts);
        });
        await (0, _hook).runHook(forgeConfig, 'postStart', spawned);
        return spawned;
    };
    const forgeSpawnWrapper = async ()=>{
        const spawned = await forgeSpawn();
        // When the child app is closed we should stop listening for stdin
        if (spawned) {
            if (interactive && process.stdin.isPaused()) {
                process.stdin.resume();
            }
            spawned.on('exit', ()=>{
                if (spawned.restarted) {
                    return;
                }
                if (interactive && !process.stdin.isPaused()) {
                    process.stdin.pause();
                }
            });
        } else if (interactive && !process.stdin.isPaused()) {
            process.stdin.pause();
        }
        lastSpawned = spawned;
        return lastSpawned;
    };
    if (interactive) {
        process.stdin.on('data', async (data)=>{
            if (data.toString().trim() === 'rs' && lastSpawned) {
                // eslint-disable-next-line no-console
                console.info(_chalk.default.cyan('\nRestarting App\n'));
                lastSpawned.restarted = true;
                lastSpawned.kill('SIGTERM');
                lastSpawned.emit('restarted', await forgeSpawnWrapper());
            }
        });
        process.stdin.resume();
    }
    return forgeSpawnWrapper();
};
exports.default = _default;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvc3RhcnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXN5bmNPcmEgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvYXN5bmMtb3JhJztcbmltcG9ydCBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgRWxlY3Ryb25Qcm9jZXNzLCBGb3JnZUFyY2gsIEZvcmdlUGxhdGZvcm0sIFN0YXJ0T3B0aW9ucyB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IHsgc3Bhd24sIFNwYXduT3B0aW9ucyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuXG5pbXBvcnQgeyBnZXRFbGVjdHJvblZlcnNpb24gfSBmcm9tICcuLi91dGlsL2VsZWN0cm9uLXZlcnNpb24nO1xuaW1wb3J0IGdldEZvcmdlQ29uZmlnIGZyb20gJy4uL3V0aWwvZm9yZ2UtY29uZmlnJztcbmltcG9ydCBsb2NhdGVFbGVjdHJvbkV4ZWN1dGFibGUgZnJvbSAnLi4vdXRpbC9lbGVjdHJvbi1leGVjdXRhYmxlJztcbmltcG9ydCB7IHJlYWRNdXRhdGVkUGFja2FnZUpzb24gfSBmcm9tICcuLi91dGlsL3JlYWQtcGFja2FnZS1qc29uJztcbmltcG9ydCByZWJ1aWxkIGZyb20gJy4uL3V0aWwvcmVidWlsZCc7XG5pbXBvcnQgcmVzb2x2ZURpciBmcm9tICcuLi91dGlsL3Jlc29sdmUtZGlyJztcbmltcG9ydCB7IHJ1bkhvb2sgfSBmcm9tICcuLi91dGlsL2hvb2snO1xuXG5jb25zdCBkID0gZGVidWcoJ2VsZWN0cm9uLWZvcmdlOnN0YXJ0Jyk7XG5cbmV4cG9ydCB7IFN0YXJ0T3B0aW9ucyB9O1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyAoe1xuICBkaXIgPSBwcm9jZXNzLmN3ZCgpLFxuICBhcHBQYXRoID0gJy4nLFxuICBpbnRlcmFjdGl2ZSA9IGZhbHNlLFxuICBlbmFibGVMb2dnaW5nID0gZmFsc2UsXG4gIGFyZ3MgPSBbXSxcbiAgcnVuQXNOb2RlID0gZmFsc2UsXG4gIGluc3BlY3QgPSBmYWxzZSxcbiAgaW5zcGVjdEJyayA9IGZhbHNlLFxufTogU3RhcnRPcHRpb25zKTogUHJvbWlzZTxFbGVjdHJvblByb2Nlc3M+ID0+IHtcbiAgYXN5bmNPcmEuaW50ZXJhY3RpdmUgPSBpbnRlcmFjdGl2ZTtcbiAgLy8gU2luY2UgdGhlIGBzdGFydGAgY29tbWFuZCBpcyBtZWFudCB0byBiZSBsb25nLWxpdmluZyAoaS5lLiBydW4gZm9yZXZlcixcbiAgLy8gdW50aWwgaW50ZXJydXB0ZWQpIHdlIHNob3VsZCBlbmFibGUgdGhpcyB0byBrZWVwIHN0ZGluIGZsb3dpbmcgYWZ0ZXIgb3JhXG4gIC8vIGNvbXBsZXRlcy4gRm9yIG1vcmUgY29udGV4dDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWZvcmdlL2lzc3Vlcy8yMzE5XG4gIGFzeW5jT3JhLmtlZXBTdGRpbkZsb3dpbmcgPSB0cnVlO1xuXG4gIGF3YWl0IGFzeW5jT3JhKCdMb2NhdGluZyBBcHBsaWNhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZERpciA9IGF3YWl0IHJlc29sdmVEaXIoZGlyKTtcbiAgICBpZiAoIXJlc29sdmVkRGlyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2NhdGUgc3RhcnRhYmxlIEVsZWN0cm9uIGFwcGxpY2F0aW9uJyk7XG4gICAgfVxuICAgIGRpciA9IHJlc29sdmVkRGlyO1xuICB9KTtcblxuICBjb25zdCBmb3JnZUNvbmZpZyA9IGF3YWl0IGdldEZvcmdlQ29uZmlnKGRpcik7XG4gIGNvbnN0IHBhY2thZ2VKU09OID0gYXdhaXQgcmVhZE11dGF0ZWRQYWNrYWdlSnNvbihkaXIsIGZvcmdlQ29uZmlnKTtcblxuICBpZiAoIXBhY2thZ2VKU09OLnZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFBsZWFzZSBzZXQgeW91ciBhcHBsaWNhdGlvbidzICd2ZXJzaW9uJyBpbiAnJHtkaXJ9L3BhY2thZ2UuanNvbicuYCk7XG4gIH1cblxuICBjb25zdCBwbGF0Zm9ybSA9IHByb2Nlc3MuZW52Lm5wbV9jb25maWdfcGxhdGZvcm0gfHwgcHJvY2Vzcy5wbGF0Zm9ybTtcbiAgY29uc3QgYXJjaCA9IHByb2Nlc3MuZW52Lm5wbV9jb25maWdfYXJjaCB8fCBwcm9jZXNzLmFyY2g7XG5cbiAgYXdhaXQgcmVidWlsZChkaXIsIGF3YWl0IGdldEVsZWN0cm9uVmVyc2lvbihkaXIsIHBhY2thZ2VKU09OKSwgcGxhdGZvcm0gYXMgRm9yZ2VQbGF0Zm9ybSwgYXJjaCBhcyBGb3JnZUFyY2gsIGZvcmdlQ29uZmlnLmVsZWN0cm9uUmVidWlsZENvbmZpZyk7XG5cbiAgYXdhaXQgcnVuSG9vayhmb3JnZUNvbmZpZywgJ2dlbmVyYXRlQXNzZXRzJywgcGxhdGZvcm0sIGFyY2gpO1xuXG4gIGxldCBsYXN0U3Bhd25lZDogRWxlY3Ryb25Qcm9jZXNzIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3QgZm9yZ2VTcGF3biA9IGFzeW5jICgpID0+IHtcbiAgICBsZXQgZWxlY3Ryb25FeGVjUGF0aDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgICAvLyBJZiBhIHBsdWdpbiBoYXMgdGFrZW4gb3ZlciB0aGUgc3RhcnQgY29tbWFuZCBsZXQncyBzdG9wIGhlcmVcbiAgICBjb25zdCBzcGF3bmVkUGx1Z2luQ2hpbGQgPSBhd2FpdCBmb3JnZUNvbmZpZy5wbHVnaW5JbnRlcmZhY2Uub3ZlcnJpZGVTdGFydExvZ2ljKHtcbiAgICAgIGRpcixcbiAgICAgIGFwcFBhdGgsXG4gICAgICBpbnRlcmFjdGl2ZSxcbiAgICAgIGVuYWJsZUxvZ2dpbmcsXG4gICAgICBhcmdzLFxuICAgICAgcnVuQXNOb2RlLFxuICAgICAgaW5zcGVjdCxcbiAgICAgIGluc3BlY3RCcmssXG4gICAgfSk7XG4gICAgbGV0IHByZWZpeEFyZ3M6IHN0cmluZ1tdID0gW107XG4gICAgaWYgKHR5cGVvZiBzcGF3bmVkUGx1Z2luQ2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbGVjdHJvbkV4ZWNQYXRoID0gc3Bhd25lZFBsdWdpbkNoaWxkO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzcGF3bmVkUGx1Z2luQ2hpbGQpKSB7XG4gICAgICBbZWxlY3Ryb25FeGVjUGF0aCwgLi4ucHJlZml4QXJnc10gPSBzcGF3bmVkUGx1Z2luQ2hpbGQ7XG4gICAgfSBlbHNlIGlmIChzcGF3bmVkUGx1Z2luQ2hpbGQpIHtcbiAgICAgIGF3YWl0IHJ1bkhvb2soZm9yZ2VDb25maWcsICdwb3N0U3RhcnQnLCBzcGF3bmVkUGx1Z2luQ2hpbGQpO1xuICAgICAgcmV0dXJuIHNwYXduZWRQbHVnaW5DaGlsZDtcbiAgICB9XG5cbiAgICBpZiAoIWVsZWN0cm9uRXhlY1BhdGgpIHtcbiAgICAgIGVsZWN0cm9uRXhlY1BhdGggPSBhd2FpdCBsb2NhdGVFbGVjdHJvbkV4ZWN1dGFibGUoZGlyLCBwYWNrYWdlSlNPTik7XG4gICAgfVxuXG4gICAgZCgnRWxlY3Ryb24gYmluYXJ5IHBhdGg6JywgZWxlY3Ryb25FeGVjUGF0aCk7XG5cbiAgICBjb25zdCBzcGF3bk9wdHMgPSB7XG4gICAgICBjd2Q6IGRpcixcbiAgICAgIHN0ZGlvOiAnaW5oZXJpdCcsXG4gICAgICBlbnY6IHtcbiAgICAgICAgLi4ucHJvY2Vzcy5lbnYsXG4gICAgICAgIC4uLihlbmFibGVMb2dnaW5nXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIEVMRUNUUk9OX0VOQUJMRV9MT0dHSU5HOiAndHJ1ZScsXG4gICAgICAgICAgICAgIEVMRUNUUk9OX0VOQUJMRV9TVEFDS19EVU1QSU5HOiAndHJ1ZScsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB7fSksXG4gICAgICB9IGFzIE5vZGVKUy5Qcm9jZXNzRW52LFxuICAgIH07XG5cbiAgICBpZiAocnVuQXNOb2RlKSB7XG4gICAgICBzcGF3bk9wdHMuZW52LkVMRUNUUk9OX1JVTl9BU19OT0RFID0gJ3RydWUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgc3Bhd25PcHRzLmVudi5FTEVDVFJPTl9SVU5fQVNfTk9ERTtcbiAgICB9XG5cbiAgICBpZiAoaW5zcGVjdCkge1xuICAgICAgYXJncyA9IFsnLS1pbnNwZWN0JyBhcyBzdHJpbmcgfCBudW1iZXJdLmNvbmNhdChhcmdzKTtcbiAgICB9XG4gICAgaWYgKGluc3BlY3RCcmspIHtcbiAgICAgIGFyZ3MgPSBbJy0taW5zcGVjdC1icmsnIGFzIHN0cmluZyB8IG51bWJlcl0uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIGxldCBzcGF3bmVkITogRWxlY3Ryb25Qcm9jZXNzO1xuXG4gICAgYXdhaXQgYXN5bmNPcmEoJ0xhdW5jaGluZyBBcHBsaWNhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIHNwYXduZWQgPSBzcGF3bihcbiAgICAgICAgZWxlY3Ryb25FeGVjUGF0aCEsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBwcmVmaXhBcmdzLmNvbmNhdChbYXBwUGF0aF0pLmNvbmNhdChhcmdzIGFzIHN0cmluZ1tdKSxcbiAgICAgICAgc3Bhd25PcHRzIGFzIFNwYXduT3B0aW9uc1xuICAgICAgKSBhcyBFbGVjdHJvblByb2Nlc3M7XG4gICAgfSk7XG5cbiAgICBhd2FpdCBydW5Ib29rKGZvcmdlQ29uZmlnLCAncG9zdFN0YXJ0Jywgc3Bhd25lZCk7XG4gICAgcmV0dXJuIHNwYXduZWQ7XG4gIH07XG5cbiAgY29uc3QgZm9yZ2VTcGF3bldyYXBwZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgc3Bhd25lZCA9IGF3YWl0IGZvcmdlU3Bhd24oKTtcbiAgICAvLyBXaGVuIHRoZSBjaGlsZCBhcHAgaXMgY2xvc2VkIHdlIHNob3VsZCBzdG9wIGxpc3RlbmluZyBmb3Igc3RkaW5cbiAgICBpZiAoc3Bhd25lZCkge1xuICAgICAgaWYgKGludGVyYWN0aXZlICYmIHByb2Nlc3Muc3RkaW4uaXNQYXVzZWQoKSkge1xuICAgICAgICBwcm9jZXNzLnN0ZGluLnJlc3VtZSgpO1xuICAgICAgfVxuICAgICAgc3Bhd25lZC5vbignZXhpdCcsICgpID0+IHtcbiAgICAgICAgaWYgKHNwYXduZWQucmVzdGFydGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludGVyYWN0aXZlICYmICFwcm9jZXNzLnN0ZGluLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICBwcm9jZXNzLnN0ZGluLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaW50ZXJhY3RpdmUgJiYgIXByb2Nlc3Muc3RkaW4uaXNQYXVzZWQoKSkge1xuICAgICAgcHJvY2Vzcy5zdGRpbi5wYXVzZSgpO1xuICAgIH1cblxuICAgIGxhc3RTcGF3bmVkID0gc3Bhd25lZDtcbiAgICByZXR1cm4gbGFzdFNwYXduZWQ7XG4gIH07XG5cbiAgaWYgKGludGVyYWN0aXZlKSB7XG4gICAgcHJvY2Vzcy5zdGRpbi5vbignZGF0YScsIGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICBpZiAoZGF0YS50b1N0cmluZygpLnRyaW0oKSA9PT0gJ3JzJyAmJiBsYXN0U3Bhd25lZCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmluZm8oY2hhbGsuY3lhbignXFxuUmVzdGFydGluZyBBcHBcXG4nKSk7XG4gICAgICAgIGxhc3RTcGF3bmVkLnJlc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIGxhc3RTcGF3bmVkLmtpbGwoJ1NJR1RFUk0nKTtcbiAgICAgICAgbGFzdFNwYXduZWQuZW1pdCgncmVzdGFydGVkJywgYXdhaXQgZm9yZ2VTcGF3bldyYXBwZXIoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHJvY2Vzcy5zdGRpbi5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBmb3JnZVNwYXduV3JhcHBlcigpO1xufTtcbiJdLCJuYW1lcyI6WyJTdGFydE9wdGlvbnMiLCJkIiwiZGVidWciLCJkaXIiLCJwcm9jZXNzIiwiY3dkIiwiYXBwUGF0aCIsImludGVyYWN0aXZlIiwiZW5hYmxlTG9nZ2luZyIsImFyZ3MiLCJydW5Bc05vZGUiLCJpbnNwZWN0IiwiaW5zcGVjdEJyayIsImFzeW5jT3JhIiwia2VlcFN0ZGluRmxvd2luZyIsInJlc29sdmVkRGlyIiwicmVzb2x2ZURpciIsIkVycm9yIiwiZm9yZ2VDb25maWciLCJnZXRGb3JnZUNvbmZpZyIsInBhY2thZ2VKU09OIiwicmVhZE11dGF0ZWRQYWNrYWdlSnNvbiIsInZlcnNpb24iLCJwbGF0Zm9ybSIsImVudiIsIm5wbV9jb25maWdfcGxhdGZvcm0iLCJhcmNoIiwibnBtX2NvbmZpZ19hcmNoIiwicmVidWlsZCIsImdldEVsZWN0cm9uVmVyc2lvbiIsImVsZWN0cm9uUmVidWlsZENvbmZpZyIsInJ1bkhvb2siLCJsYXN0U3Bhd25lZCIsImZvcmdlU3Bhd24iLCJlbGVjdHJvbkV4ZWNQYXRoIiwic3Bhd25lZFBsdWdpbkNoaWxkIiwicGx1Z2luSW50ZXJmYWNlIiwib3ZlcnJpZGVTdGFydExvZ2ljIiwicHJlZml4QXJncyIsIkFycmF5IiwiaXNBcnJheSIsImxvY2F0ZUVsZWN0cm9uRXhlY3V0YWJsZSIsInNwYXduT3B0cyIsInN0ZGlvIiwiRUxFQ1RST05fRU5BQkxFX0xPR0dJTkciLCJFTEVDVFJPTl9FTkFCTEVfU1RBQ0tfRFVNUElORyIsIkVMRUNUUk9OX1JVTl9BU19OT0RFIiwiY29uY2F0Iiwic3Bhd25lZCIsInNwYXduIiwiZm9yZ2VTcGF3bldyYXBwZXIiLCJzdGRpbiIsImlzUGF1c2VkIiwicmVzdW1lIiwib24iLCJyZXN0YXJ0ZWQiLCJwYXVzZSIsImRhdGEiLCJ0b1N0cmluZyIsInRyaW0iLCJjb25zb2xlIiwiaW5mbyIsImNoYWxrIiwiY3lhbiIsImtpbGwiLCJlbWl0Il0s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