"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _asyncOra = require("@electron-forge/async-ora");
var _chalk = _interopRequireDefault(require("chalk"));
var _get = require("@electron/get");
var _makerBase = _interopRequireDefault(require("@electron-forge/maker-base"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _path = _interopRequireDefault(require("path"));
var _filenamify = _interopRequireDefault(require("filenamify"));
var _forgeConfig = _interopRequireDefault(require("../util/forge-config"));
var _hook = require("../util/hook");
var _messages = require("../util/messages");
var _parseArchs = _interopRequireDefault(require("../util/parse-archs"));
var _readPackageJson = require("../util/read-package-json");
var _resolveDir = _interopRequireDefault(require("../util/resolve-dir"));
var _outDir = _interopRequireDefault(require("../util/out-dir"));
var _electronVersion = require("../util/electron-version");
var _requireSearch = _interopRequireDefault(require("../util/require-search"));
var _package = _interopRequireDefault(require("./package"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class MakerImpl extends _makerBase.default {
    constructor(...args){
        super(...args);
        this.name = 'impl';
        this.defaultPlatforms = [];
    }
}
function generateTargets(forgeConfig, overrideTargets) {
    if (overrideTargets) {
        return overrideTargets.map((target)=>{
            if (typeof target === 'string') {
                return forgeConfig.makers.find((maker)=>maker.name === target
                ) || {
                    name: target
                };
            }
            return target;
        });
    }
    return forgeConfig.makers;
}
var _default = async ({ dir =process.cwd() , interactive =false , skipPackage =false , arch =(0, _get).getHostArch() , platform =process.platform , overrideTargets , outDir  })=>{
    _asyncOra.asyncOra.interactive = interactive;
    let forgeConfig;
    await (0, _asyncOra).asyncOra('Resolving Forge Config', async ()=>{
        const resolvedDir = await (0, _resolveDir).default(dir);
        if (!resolvedDir) {
            throw new Error('Failed to locate makeable Electron application');
        }
        dir = resolvedDir;
        forgeConfig = await (0, _forgeConfig).default(dir);
    });
    const actualOutDir = outDir || (0, _outDir).default(dir, forgeConfig);
    const actualTargetPlatform = platform;
    platform = platform === 'mas' ? 'darwin' : platform;
    if (![
        'darwin',
        'win32',
        'linux',
        'mas'
    ].includes(actualTargetPlatform)) {
        throw new Error(`'${actualTargetPlatform}' is an invalid platform. Choices are 'darwin', 'mas', 'win32' or 'linux'`);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const makers = {};
    let targets = generateTargets(forgeConfig, overrideTargets);
    let targetId = 0;
    for (const target of targets){
        /* eslint-disable @typescript-eslint/no-explicit-any */ let maker;
        // eslint-disable-next-line no-underscore-dangle
        if (target.__isElectronForgeMaker) {
            maker = target;
            /* eslint-enable @typescript-eslint/no-explicit-any */ if (!maker.platforms.includes(actualTargetPlatform)) continue;
        } else {
            const resolvableTarget = target;
            // non-false falsy values should be 'true'
            if (resolvableTarget.enabled === false) continue;
            if (!resolvableTarget.name) {
                throw new Error(`The following maker config is missing a maker name: ${JSON.stringify(resolvableTarget)}`);
            } else if (typeof resolvableTarget.name !== 'string') {
                throw new Error(`The following maker config has a maker name that is not a string: ${JSON.stringify(resolvableTarget)}`);
            }
            const MakerClass = (0, _requireSearch).default(dir, [
                resolvableTarget.name
            ]);
            if (!MakerClass) {
                throw new Error(`Could not find module with name: ${resolvableTarget.name}. Make sure it's listed in the devDependencies of your package.json`);
            }
            maker = new MakerClass(resolvableTarget.config, resolvableTarget.platforms || undefined);
            // eslint-disable-next-line no-continue
            if (!maker.platforms.includes(actualTargetPlatform)) continue;
        }
        if (!maker.isSupportedOnCurrentPlatform) {
            throw new Error([
                `Maker for target ${maker.name} is incompatible with this version of `,
                'electron-forge, please upgrade or contact the maintainer ',
                "(needs to implement 'isSupportedOnCurrentPlatform)')", 
            ].join(''));
        }
        if (!maker.isSupportedOnCurrentPlatform()) {
            throw new Error([
                `Cannot make for ${platform} and target ${maker.name}: the maker declared `,
                `that it cannot run on ${process.platform}`
            ].join(''));
        }
        maker.ensureExternalBinariesExist();
        makers[targetId] = maker;
        targetId += 1;
    }
    if (!skipPackage) {
        (0, _messages).info(interactive, _chalk.default.green('We need to package your application before we can make it'));
        await (0, _package).default({
            dir,
            interactive,
            arch,
            outDir: actualOutDir,
            platform: actualTargetPlatform
        });
    } else {
        (0, _messages).warn(interactive, _chalk.default.red('WARNING: Skipping the packaging step, this could result in an out of date build'));
    }
    targets = targets.filter((_, i)=>makers[i]
    );
    if (targets.length === 0) {
        throw new Error(`Could not find any make targets configured for the "${actualTargetPlatform}" platform.`);
    }
    (0, _messages).info(interactive, `Making for the following targets: ${_chalk.default.cyan(`${targets.map((_t, i)=>makers[i].name
    ).join(', ')}`)}`);
    const packageJSON = await (0, _readPackageJson).readMutatedPackageJson(dir, forgeConfig);
    const appName = (0, _filenamify).default(forgeConfig.packagerConfig.name || packageJSON.productName || packageJSON.name, {
        replacement: '-'
    });
    const outputs = [];
    await (0, _hook).runHook(forgeConfig, 'preMake');
    for (const targetArch of (0, _parseArchs).default(platform, arch, await (0, _electronVersion).getElectronVersion(dir, packageJSON))){
        const packageDir = _path.default.resolve(actualOutDir, `${appName}-${actualTargetPlatform}-${targetArch}`);
        if (!await _fsExtra.default.pathExists(packageDir)) {
            throw new Error(`Couldn't find packaged app at: ${packageDir}`);
        }
        targetId = 0;
        // eslint-disable-next-line no-underscore-dangle, @typescript-eslint/no-unused-vars
        for (const _target of targets){
            const maker = makers[targetId];
            targetId += 1;
            // eslint-disable-next-line no-loop-func
            await (0, _asyncOra).asyncOra(`Making for target: ${_chalk.default.green(maker.name)} - On platform: ${_chalk.default.cyan(actualTargetPlatform)} - For arch: ${_chalk.default.cyan(targetArch)}`, async ()=>{
                try {
                    /**
             * WARNING: DO NOT ATTEMPT TO PARALLELIZE MAKERS
             *
             * Currently it is assumed we have 1 maker per make call but that is
             * not enforced.  It is technically possible to have 1 maker be called
             * multiple times.  The "prepareConfig" method however implicitly
             * requires a lock that is not enforced.  There are two options:
             *
             *   * Provide makers a getConfig() method
             *   * Remove support for config being provided as a method
             *   * Change the entire API of maker from a single constructor to
             *     providing a MakerFactory
             */ maker.prepareConfig(targetArch);
                    const artifacts = await maker.make({
                        appName,
                        forgeConfig,
                        packageJSON,
                        targetArch,
                        dir: packageDir,
                        makeDir: _path.default.resolve(actualOutDir, 'make'),
                        targetPlatform: actualTargetPlatform
                    });
                    outputs.push({
                        artifacts,
                        packageJSON,
                        platform: actualTargetPlatform,
                        arch: targetArch
                    });
                } catch (err) {
                    if (err instanceof Error) {
                        // eslint-disable-next-line no-throw-literal
                        throw {
                            message: `An error occured while making for target: ${maker.name}`,
                            stack: `${err.message}\n${err.stack}`
                        };
                    } else if (err) {
                        throw err;
                    } else {
                        throw new Error(`An unknown error occured while making for target: ${maker.name}`);
                    }
                }
            });
        }
    }
    // If the postMake hooks modifies the locations / names of the outputs it must return
    // the new locations so that the publish step knows where to look
    return (0, _hook).runMutatingHook(forgeConfig, 'postMake', outputs);
};
exports.default = _default;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvbWFrZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3luY09yYSB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9hc3luYy1vcmEnO1xuaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCB7IGdldEhvc3RBcmNoIH0gZnJvbSAnQGVsZWN0cm9uL2dldCc7XG5pbXBvcnQgeyBJRm9yZ2VSZXNvbHZhYmxlTWFrZXIsIEZvcmdlQ29uZmlnLCBGb3JnZUFyY2gsIEZvcmdlUGxhdGZvcm0sIEZvcmdlTWFrZVJlc3VsdCB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IE1ha2VyQmFzZSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvbWFrZXItYmFzZSc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgZmlsZW5hbWlmeSBmcm9tICdmaWxlbmFtaWZ5JztcblxuaW1wb3J0IGdldEZvcmdlQ29uZmlnIGZyb20gJy4uL3V0aWwvZm9yZ2UtY29uZmlnJztcbmltcG9ydCB7IHJ1bkhvb2ssIHJ1bk11dGF0aW5nSG9vayB9IGZyb20gJy4uL3V0aWwvaG9vayc7XG5pbXBvcnQgeyBpbmZvLCB3YXJuIH0gZnJvbSAnLi4vdXRpbC9tZXNzYWdlcyc7XG5pbXBvcnQgcGFyc2VBcmNocyBmcm9tICcuLi91dGlsL3BhcnNlLWFyY2hzJztcbmltcG9ydCB7IHJlYWRNdXRhdGVkUGFja2FnZUpzb24gfSBmcm9tICcuLi91dGlsL3JlYWQtcGFja2FnZS1qc29uJztcbmltcG9ydCByZXNvbHZlRGlyIGZyb20gJy4uL3V0aWwvcmVzb2x2ZS1kaXInO1xuaW1wb3J0IGdldEN1cnJlbnRPdXREaXIgZnJvbSAnLi4vdXRpbC9vdXQtZGlyJztcbmltcG9ydCB7IGdldEVsZWN0cm9uVmVyc2lvbiB9IGZyb20gJy4uL3V0aWwvZWxlY3Ryb24tdmVyc2lvbic7XG5pbXBvcnQgcmVxdWlyZVNlYXJjaCBmcm9tICcuLi91dGlsL3JlcXVpcmUtc2VhcmNoJztcblxuaW1wb3J0IHBhY2thZ2VyIGZyb20gJy4vcGFja2FnZSc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jbGFzcyBNYWtlckltcGwgZXh0ZW5kcyBNYWtlckJhc2U8YW55PiB7XG4gIG5hbWUgPSAnaW1wbCc7XG5cbiAgZGVmYXVsdFBsYXRmb3JtcyA9IFtdO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxudHlwZSBNYWtlVGFyZ2V0ID0gSUZvcmdlUmVzb2x2YWJsZU1ha2VyIHwgTWFrZXJCYXNlPGFueT4gfCBzdHJpbmc7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVGFyZ2V0cyhmb3JnZUNvbmZpZzogRm9yZ2VDb25maWcsIG92ZXJyaWRlVGFyZ2V0cz86IE1ha2VUYXJnZXRbXSkge1xuICBpZiAob3ZlcnJpZGVUYXJnZXRzKSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlVGFyZ2V0cy5tYXAoKHRhcmdldCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmb3JnZUNvbmZpZy5tYWtlcnMuZmluZCgobWFrZXIpID0+IChtYWtlciBhcyBJRm9yZ2VSZXNvbHZhYmxlTWFrZXIpLm5hbWUgPT09IHRhcmdldCkgfHwgeyBuYW1lOiB0YXJnZXQgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZm9yZ2VDb25maWcubWFrZXJzO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1ha2VPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIHRoZSBhcHAgZnJvbSB3aGljaCBkaXN0cnVidXRhYmxlcyBhcmUgZ2VuZXJhdGVkXG4gICAqL1xuICBkaXI/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBzZW5zaWJsZSBkZWZhdWx0cyBvciBwcm9tcHQgdGhlIHVzZXIgdmlzdWFsbHlcbiAgICovXG4gIGludGVyYWN0aXZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc2tpcCB0aGUgcHJlLW1ha2UgcGFja2FnaW5nIHN0ZXBcbiAgICovXG4gIHNraXBQYWNrYWdlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIG1ha2UgdGFyZ2V0cyB0byBvdmVycmlkZSB5b3VyIGZvcmdlIGNvbmZpZ1xuICAgKi9cbiAgb3ZlcnJpZGVUYXJnZXRzPzogTWFrZVRhcmdldFtdO1xuICAvKipcbiAgICogVGhlIHRhcmdldCBhcmNoaXRlY3R1cmVcbiAgICovXG4gIGFyY2g/OiBGb3JnZUFyY2g7XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IHBsYXRmb3JtXG4gICAqL1xuICBwbGF0Zm9ybT86IEZvcmdlUGxhdGZvcm07XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgZ2VuZXJhdGVkIGRpc3RyaWJ1dGFibGVzXG4gICAqL1xuICBvdXREaXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jICh7XG4gIGRpciA9IHByb2Nlc3MuY3dkKCksXG4gIGludGVyYWN0aXZlID0gZmFsc2UsXG4gIHNraXBQYWNrYWdlID0gZmFsc2UsXG4gIGFyY2ggPSBnZXRIb3N0QXJjaCgpIGFzIEZvcmdlQXJjaCxcbiAgcGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtIGFzIEZvcmdlUGxhdGZvcm0sXG4gIG92ZXJyaWRlVGFyZ2V0cyxcbiAgb3V0RGlyLFxufTogTWFrZU9wdGlvbnMpOiBQcm9taXNlPEZvcmdlTWFrZVJlc3VsdFtdPiA9PiB7XG4gIGFzeW5jT3JhLmludGVyYWN0aXZlID0gaW50ZXJhY3RpdmU7XG5cbiAgbGV0IGZvcmdlQ29uZmlnITogRm9yZ2VDb25maWc7XG4gIGF3YWl0IGFzeW5jT3JhKCdSZXNvbHZpbmcgRm9yZ2UgQ29uZmlnJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHJlc29sdmVkRGlyID0gYXdhaXQgcmVzb2x2ZURpcihkaXIpO1xuICAgIGlmICghcmVzb2x2ZWREaXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvY2F0ZSBtYWtlYWJsZSBFbGVjdHJvbiBhcHBsaWNhdGlvbicpO1xuICAgIH1cbiAgICBkaXIgPSByZXNvbHZlZERpcjtcblxuICAgIGZvcmdlQ29uZmlnID0gYXdhaXQgZ2V0Rm9yZ2VDb25maWcoZGlyKTtcbiAgfSk7XG5cbiAgY29uc3QgYWN0dWFsT3V0RGlyID0gb3V0RGlyIHx8IGdldEN1cnJlbnRPdXREaXIoZGlyLCBmb3JnZUNvbmZpZyk7XG5cbiAgY29uc3QgYWN0dWFsVGFyZ2V0UGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgcGxhdGZvcm0gPSBwbGF0Zm9ybSA9PT0gJ21hcycgPyAnZGFyd2luJyA6IHBsYXRmb3JtO1xuICBpZiAoIVsnZGFyd2luJywgJ3dpbjMyJywgJ2xpbnV4JywgJ21hcyddLmluY2x1ZGVzKGFjdHVhbFRhcmdldFBsYXRmb3JtKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJyR7YWN0dWFsVGFyZ2V0UGxhdGZvcm19JyBpcyBhbiBpbnZhbGlkIHBsYXRmb3JtLiBDaG9pY2VzIGFyZSAnZGFyd2luJywgJ21hcycsICd3aW4zMicgb3IgJ2xpbnV4J2ApO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgbWFrZXJzOiBSZWNvcmQ8bnVtYmVyLCBNYWtlckJhc2U8YW55Pj4gPSB7fTtcblxuICBsZXQgdGFyZ2V0cyA9IGdlbmVyYXRlVGFyZ2V0cyhmb3JnZUNvbmZpZywgb3ZlcnJpZGVUYXJnZXRzKTtcblxuICBsZXQgdGFyZ2V0SWQgPSAwO1xuICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgIGxldCBtYWtlcjogTWFrZXJCYXNlPGFueT47XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXG4gICAgaWYgKCh0YXJnZXQgYXMgTWFrZXJCYXNlPGFueT4pLl9faXNFbGVjdHJvbkZvcmdlTWFrZXIpIHtcbiAgICAgIG1ha2VyID0gdGFyZ2V0IGFzIE1ha2VyQmFzZTxhbnk+O1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4gICAgICBpZiAoIW1ha2VyLnBsYXRmb3Jtcy5pbmNsdWRlcyhhY3R1YWxUYXJnZXRQbGF0Zm9ybSkpIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXNvbHZhYmxlVGFyZ2V0OiBJRm9yZ2VSZXNvbHZhYmxlTWFrZXIgPSB0YXJnZXQgYXMgSUZvcmdlUmVzb2x2YWJsZU1ha2VyO1xuICAgICAgLy8gbm9uLWZhbHNlIGZhbHN5IHZhbHVlcyBzaG91bGQgYmUgJ3RydWUnXG4gICAgICBpZiAocmVzb2x2YWJsZVRhcmdldC5lbmFibGVkID09PSBmYWxzZSkgY29udGludWU7XG5cbiAgICAgIGlmICghcmVzb2x2YWJsZVRhcmdldC5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZvbGxvd2luZyBtYWtlciBjb25maWcgaXMgbWlzc2luZyBhIG1ha2VyIG5hbWU6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2YWJsZVRhcmdldCl9YCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNvbHZhYmxlVGFyZ2V0Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZvbGxvd2luZyBtYWtlciBjb25maWcgaGFzIGEgbWFrZXIgbmFtZSB0aGF0IGlzIG5vdCBhIHN0cmluZzogJHtKU09OLnN0cmluZ2lmeShyZXNvbHZhYmxlVGFyZ2V0KX1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgTWFrZXJDbGFzcyA9IHJlcXVpcmVTZWFyY2g8dHlwZW9mIE1ha2VySW1wbD4oZGlyLCBbcmVzb2x2YWJsZVRhcmdldC5uYW1lXSk7XG4gICAgICBpZiAoIU1ha2VyQ2xhc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBtb2R1bGUgd2l0aCBuYW1lOiAke3Jlc29sdmFibGVUYXJnZXQubmFtZX0uIE1ha2Ugc3VyZSBpdCdzIGxpc3RlZCBpbiB0aGUgZGV2RGVwZW5kZW5jaWVzIG9mIHlvdXIgcGFja2FnZS5qc29uYCk7XG4gICAgICB9XG5cbiAgICAgIG1ha2VyID0gbmV3IE1ha2VyQ2xhc3MocmVzb2x2YWJsZVRhcmdldC5jb25maWcsIHJlc29sdmFibGVUYXJnZXQucGxhdGZvcm1zIHx8IHVuZGVmaW5lZCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgIGlmICghbWFrZXIucGxhdGZvcm1zLmluY2x1ZGVzKGFjdHVhbFRhcmdldFBsYXRmb3JtKSkgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCFtYWtlci5pc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFtcbiAgICAgICAgICBgTWFrZXIgZm9yIHRhcmdldCAke21ha2VyLm5hbWV9IGlzIGluY29tcGF0aWJsZSB3aXRoIHRoaXMgdmVyc2lvbiBvZiBgLFxuICAgICAgICAgICdlbGVjdHJvbi1mb3JnZSwgcGxlYXNlIHVwZ3JhZGUgb3IgY29udGFjdCB0aGUgbWFpbnRhaW5lciAnLFxuICAgICAgICAgIFwiKG5lZWRzIHRvIGltcGxlbWVudCAnaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSknKVwiLFxuICAgICAgICBdLmpvaW4oJycpXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghbWFrZXIuaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoW2BDYW5ub3QgbWFrZSBmb3IgJHtwbGF0Zm9ybX0gYW5kIHRhcmdldCAke21ha2VyLm5hbWV9OiB0aGUgbWFrZXIgZGVjbGFyZWQgYCwgYHRoYXQgaXQgY2Fubm90IHJ1biBvbiAke3Byb2Nlc3MucGxhdGZvcm19YF0uam9pbignJykpO1xuICAgIH1cblxuICAgIG1ha2VyLmVuc3VyZUV4dGVybmFsQmluYXJpZXNFeGlzdCgpO1xuXG4gICAgbWFrZXJzW3RhcmdldElkXSA9IG1ha2VyO1xuICAgIHRhcmdldElkICs9IDE7XG4gIH1cblxuICBpZiAoIXNraXBQYWNrYWdlKSB7XG4gICAgaW5mbyhpbnRlcmFjdGl2ZSwgY2hhbGsuZ3JlZW4oJ1dlIG5lZWQgdG8gcGFja2FnZSB5b3VyIGFwcGxpY2F0aW9uIGJlZm9yZSB3ZSBjYW4gbWFrZSBpdCcpKTtcbiAgICBhd2FpdCBwYWNrYWdlcih7XG4gICAgICBkaXIsXG4gICAgICBpbnRlcmFjdGl2ZSxcbiAgICAgIGFyY2gsXG4gICAgICBvdXREaXI6IGFjdHVhbE91dERpcixcbiAgICAgIHBsYXRmb3JtOiBhY3R1YWxUYXJnZXRQbGF0Zm9ybSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB3YXJuKGludGVyYWN0aXZlLCBjaGFsay5yZWQoJ1dBUk5JTkc6IFNraXBwaW5nIHRoZSBwYWNrYWdpbmcgc3RlcCwgdGhpcyBjb3VsZCByZXN1bHQgaW4gYW4gb3V0IG9mIGRhdGUgYnVpbGQnKSk7XG4gIH1cblxuICB0YXJnZXRzID0gdGFyZ2V0cy5maWx0ZXIoKF8sIGkpID0+IG1ha2Vyc1tpXSk7XG5cbiAgaWYgKHRhcmdldHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhbnkgbWFrZSB0YXJnZXRzIGNvbmZpZ3VyZWQgZm9yIHRoZSBcIiR7YWN0dWFsVGFyZ2V0UGxhdGZvcm19XCIgcGxhdGZvcm0uYCk7XG4gIH1cblxuICBpbmZvKGludGVyYWN0aXZlLCBgTWFraW5nIGZvciB0aGUgZm9sbG93aW5nIHRhcmdldHM6ICR7Y2hhbGsuY3lhbihgJHt0YXJnZXRzLm1hcCgoX3QsIGkpID0+IG1ha2Vyc1tpXS5uYW1lKS5qb2luKCcsICcpfWApfWApO1xuXG4gIGNvbnN0IHBhY2thZ2VKU09OID0gYXdhaXQgcmVhZE11dGF0ZWRQYWNrYWdlSnNvbihkaXIsIGZvcmdlQ29uZmlnKTtcbiAgY29uc3QgYXBwTmFtZSA9IGZpbGVuYW1pZnkoZm9yZ2VDb25maWcucGFja2FnZXJDb25maWcubmFtZSB8fCBwYWNrYWdlSlNPTi5wcm9kdWN0TmFtZSB8fCBwYWNrYWdlSlNPTi5uYW1lLCB7IHJlcGxhY2VtZW50OiAnLScgfSk7XG4gIGNvbnN0IG91dHB1dHM6IEZvcmdlTWFrZVJlc3VsdFtdID0gW107XG5cbiAgYXdhaXQgcnVuSG9vayhmb3JnZUNvbmZpZywgJ3ByZU1ha2UnKTtcblxuICBmb3IgKGNvbnN0IHRhcmdldEFyY2ggb2YgcGFyc2VBcmNocyhwbGF0Zm9ybSwgYXJjaCwgYXdhaXQgZ2V0RWxlY3Ryb25WZXJzaW9uKGRpciwgcGFja2FnZUpTT04pKSkge1xuICAgIGNvbnN0IHBhY2thZ2VEaXIgPSBwYXRoLnJlc29sdmUoYWN0dWFsT3V0RGlyLCBgJHthcHBOYW1lfS0ke2FjdHVhbFRhcmdldFBsYXRmb3JtfS0ke3RhcmdldEFyY2h9YCk7XG4gICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhwYWNrYWdlRGlyKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBwYWNrYWdlZCBhcHAgYXQ6ICR7cGFja2FnZURpcn1gKTtcbiAgICB9XG5cbiAgICB0YXJnZXRJZCA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBmb3IgKGNvbnN0IF90YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgICAgY29uc3QgbWFrZXIgPSBtYWtlcnNbdGFyZ2V0SWRdO1xuICAgICAgdGFyZ2V0SWQgKz0gMTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgYXdhaXQgYXN5bmNPcmEoXG4gICAgICAgIGBNYWtpbmcgZm9yIHRhcmdldDogJHtjaGFsay5ncmVlbihtYWtlci5uYW1lKX0gLSBPbiBwbGF0Zm9ybTogJHtjaGFsay5jeWFuKGFjdHVhbFRhcmdldFBsYXRmb3JtKX0gLSBGb3IgYXJjaDogJHtjaGFsay5jeWFuKHRhcmdldEFyY2gpfWAsXG4gICAgICAgIGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXQVJOSU5HOiBETyBOT1QgQVRURU1QVCBUTyBQQVJBTExFTElaRSBNQUtFUlNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBDdXJyZW50bHkgaXQgaXMgYXNzdW1lZCB3ZSBoYXZlIDEgbWFrZXIgcGVyIG1ha2UgY2FsbCBidXQgdGhhdCBpc1xuICAgICAgICAgICAgICogbm90IGVuZm9yY2VkLiAgSXQgaXMgdGVjaG5pY2FsbHkgcG9zc2libGUgdG8gaGF2ZSAxIG1ha2VyIGJlIGNhbGxlZFxuICAgICAgICAgICAgICogbXVsdGlwbGUgdGltZXMuICBUaGUgXCJwcmVwYXJlQ29uZmlnXCIgbWV0aG9kIGhvd2V2ZXIgaW1wbGljaXRseVxuICAgICAgICAgICAgICogcmVxdWlyZXMgYSBsb2NrIHRoYXQgaXMgbm90IGVuZm9yY2VkLiAgVGhlcmUgYXJlIHR3byBvcHRpb25zOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgKiBQcm92aWRlIG1ha2VycyBhIGdldENvbmZpZygpIG1ldGhvZFxuICAgICAgICAgICAgICogICAqIFJlbW92ZSBzdXBwb3J0IGZvciBjb25maWcgYmVpbmcgcHJvdmlkZWQgYXMgYSBtZXRob2RcbiAgICAgICAgICAgICAqICAgKiBDaGFuZ2UgdGhlIGVudGlyZSBBUEkgb2YgbWFrZXIgZnJvbSBhIHNpbmdsZSBjb25zdHJ1Y3RvciB0b1xuICAgICAgICAgICAgICogICAgIHByb3ZpZGluZyBhIE1ha2VyRmFjdG9yeVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtYWtlci5wcmVwYXJlQ29uZmlnKHRhcmdldEFyY2gpO1xuICAgICAgICAgICAgY29uc3QgYXJ0aWZhY3RzID0gYXdhaXQgbWFrZXIubWFrZSh7XG4gICAgICAgICAgICAgIGFwcE5hbWUsXG4gICAgICAgICAgICAgIGZvcmdlQ29uZmlnLFxuICAgICAgICAgICAgICBwYWNrYWdlSlNPTixcbiAgICAgICAgICAgICAgdGFyZ2V0QXJjaCxcbiAgICAgICAgICAgICAgZGlyOiBwYWNrYWdlRGlyLFxuICAgICAgICAgICAgICBtYWtlRGlyOiBwYXRoLnJlc29sdmUoYWN0dWFsT3V0RGlyLCAnbWFrZScpLFxuICAgICAgICAgICAgICB0YXJnZXRQbGF0Zm9ybTogYWN0dWFsVGFyZ2V0UGxhdGZvcm0sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgb3V0cHV0cy5wdXNoKHtcbiAgICAgICAgICAgICAgYXJ0aWZhY3RzLFxuICAgICAgICAgICAgICBwYWNrYWdlSlNPTixcbiAgICAgICAgICAgICAgcGxhdGZvcm06IGFjdHVhbFRhcmdldFBsYXRmb3JtLFxuICAgICAgICAgICAgICBhcmNoOiB0YXJnZXRBcmNoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBBbiBlcnJvciBvY2N1cmVkIHdoaWxlIG1ha2luZyBmb3IgdGFyZ2V0OiAke21ha2VyLm5hbWV9YCxcbiAgICAgICAgICAgICAgICBzdGFjazogYCR7ZXJyLm1lc3NhZ2V9XFxuJHtlcnIuc3RhY2t9YCxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW4gdW5rbm93biBlcnJvciBvY2N1cmVkIHdoaWxlIG1ha2luZyBmb3IgdGFyZ2V0OiAke21ha2VyLm5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBwb3N0TWFrZSBob29rcyBtb2RpZmllcyB0aGUgbG9jYXRpb25zIC8gbmFtZXMgb2YgdGhlIG91dHB1dHMgaXQgbXVzdCByZXR1cm5cbiAgLy8gdGhlIG5ldyBsb2NhdGlvbnMgc28gdGhhdCB0aGUgcHVibGlzaCBzdGVwIGtub3dzIHdoZXJlIHRvIGxvb2tcbiAgcmV0dXJuIHJ1bk11dGF0aW5nSG9vayhmb3JnZUNvbmZpZywgJ3Bvc3RNYWtlJywgb3V0cHV0cyk7XG59O1xuIl0sIm5hbWVzIjpbIk1ha2VySW1wbCIsIk1ha2VyQmFzZSIsIm5hbWUiLCJkZWZhdWx0UGxhdGZvcm1zIiwiZ2VuZXJhdGVUYXJnZXRzIiwiZm9yZ2VDb25maWciLCJvdmVycmlkZVRhcmdldHMiLCJtYXAiLCJ0YXJnZXQiLCJtYWtlcnMiLCJmaW5kIiwibWFrZXIiLCJkaXIiLCJwcm9jZXNzIiwiY3dkIiwiaW50ZXJhY3RpdmUiLCJza2lwUGFja2FnZSIsImFyY2giLCJnZXRIb3N0QXJjaCIsInBsYXRmb3JtIiwib3V0RGlyIiwiYXN5bmNPcmEiLCJyZXNvbHZlZERpciIsInJlc29sdmVEaXIiLCJFcnJvciIsImdldEZvcmdlQ29uZmlnIiwiYWN0dWFsT3V0RGlyIiwiZ2V0Q3VycmVudE91dERpciIsImFjdHVhbFRhcmdldFBsYXRmb3JtIiwiaW5jbHVkZXMiLCJ0YXJnZXRzIiwidGFyZ2V0SWQiLCJfX2lzRWxlY3Ryb25Gb3JnZU1ha2VyIiwicGxhdGZvcm1zIiwicmVzb2x2YWJsZVRhcmdldCIsImVuYWJsZWQiLCJKU09OIiwic3RyaW5naWZ5IiwiTWFrZXJDbGFzcyIsInJlcXVpcmVTZWFyY2giLCJjb25maWciLCJ1bmRlZmluZWQiLCJpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtIiwiam9pbiIsImVuc3VyZUV4dGVybmFsQmluYXJpZXNFeGlzdCIsImluZm8iLCJjaGFsayIsImdyZWVuIiwicGFja2FnZXIiLCJ3YXJuIiwicmVkIiwiZmlsdGVyIiwiXyIsImkiLCJsZW5ndGgiLCJjeWFuIiwiX3QiLCJwYWNrYWdlSlNPTiIsInJlYWRNdXRhdGVkUGFja2FnZUpzb24iLCJhcHBOYW1lIiwiZmlsZW5hbWlmeSIsInBhY2thZ2VyQ29uZmlnIiwicHJvZHVjdE5hbWUiLCJyZXBsYWNlbWVudCIsIm91dHB1dHMiLCJydW5Ib29rIiwidGFyZ2V0QXJjaCIsInBhcnNlQXJjaHMiLCJnZXRFbGVjdHJvblZlcnNpb24iLCJwYWNrYWdlRGlyIiwicGF0aCIsInJlc29sdmUiLCJmcyIsInBhdGhFeGlzdHMiLCJfdGFyZ2V0IiwicHJlcGFyZUNvbmZpZyIsImFydGlmYWN0cyIsIm1ha2UiLCJtYWtlRGlyIiwidGFyZ2V0UGxhdGZvcm0iLCJwdXNoIiwiZXJyIiwibWVzc2FnZSIsInN0YWNrIiwicnVuTXV0YXRpbmdIb29rIl0sIm1hcHBpbmdzIjoiOzs7OztBQUF5QixHQUEyQixDQUEzQixTQUEyQjtBQUNsQyxHQUFPLENBQVAsTUFBTztBQUNHLEdBQWUsQ0FBZixJQUFlO0FBRXJCLEdBQTRCLENBQTVCLFVBQTRCO0FBQ25DLEdBQVUsQ0FBVixRQUFVO0FBQ1IsR0FBTSxDQUFOLEtBQU07QUFDQSxHQUFZLENBQVosV0FBWTtBQUVSLEdB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