"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _asyncOra = require("@electron-forge/async-ora");
var _debug = _interopRequireDefault(require("debug"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _path = _interopRequireDefault(require("path"));
var _semver = _interopRequireDefault(require("semver"));
var _findTemplate = _interopRequireDefault(require("./init-scripts/find-template"));
var _initDirectory = _interopRequireDefault(require("./init-scripts/init-directory"));
var _initGit = _interopRequireDefault(require("./init-scripts/init-git"));
var _initNpm = _interopRequireDefault(require("./init-scripts/init-npm"));
var _installDependencies = _interopRequireWildcard(require("../util/install-dependencies"));
var _readPackageJson = require("../util/read-package-json");
var _forgeConfig = require("../util/forge-config");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};
        if (obj != null) {
            for(var key in obj){
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};
                    if (desc.get || desc.set) {
                        Object.defineProperty(newObj, key, desc);
                    } else {
                        newObj[key] = obj[key];
                    }
                }
            }
        }
        newObj.default = obj;
        return newObj;
    }
}
const d = (0, _debug).default('electron-forge:init');
async function validateTemplate(template, templateModule) {
    if (!templateModule.requiredForgeVersion) {
        throw new Error(`Cannot use a template (${template}) with this version of Electron Forge, as it does not specify its required Forge version.`);
    }
    const forgeVersion = (await (0, _readPackageJson).readRawPackageJson(_path.default.join(__dirname, '..', '..'))).version;
    if (!_semver.default.satisfies(forgeVersion, templateModule.requiredForgeVersion)) {
        throw new Error(`Template (${template}) is not compatible with this version of Electron Forge (${forgeVersion}), it requires ${templateModule.requiredForgeVersion}`);
    }
}
var _default = async ({ dir =process.cwd() , interactive =false , copyCIFiles =false , force =false , template ='base'  })=>{
    _asyncOra.asyncOra.interactive = interactive;
    d(`Initializing in: ${dir}`);
    await (0, _initDirectory).default(dir, force);
    await (0, _initGit).default(dir);
    const templateModule = await (0, _findTemplate).default(dir, template);
    await validateTemplate(template, templateModule);
    if (typeof templateModule.initializeTemplate === 'function') {
        await templateModule.initializeTemplate(dir, {
            copyCIFiles
        });
        const packageJSON = await (0, _readPackageJson).readRawPackageJson(dir);
        (0, _forgeConfig).setInitialForgeConfig(packageJSON);
        await _fsExtra.default.writeJson(_path.default.join(dir, 'package.json'), packageJSON, {
            spaces: 2
        });
    }
    await (0, _asyncOra).asyncOra('Installing Template Dependencies', async ()=>{
        d('installing dependencies');
        await (0, _installDependencies).default(dir, templateModule.dependencies || []);
        d('installing devDependencies');
        await (0, _installDependencies).default(dir, templateModule.devDependencies || [], _installDependencies.DepType.DEV);
    });
    await (0, _initNpm).default(dir);
};
exports.default = _default;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvaW5pdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3luY09yYSB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9hc3luYy1vcmEnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCB7IEZvcmdlVGVtcGxhdGUgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2Uvc2hhcmVkLXR5cGVzJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcblxuaW1wb3J0IGZpbmRUZW1wbGF0ZSBmcm9tICcuL2luaXQtc2NyaXB0cy9maW5kLXRlbXBsYXRlJztcbmltcG9ydCBpbml0RGlyZWN0b3J5IGZyb20gJy4vaW5pdC1zY3JpcHRzL2luaXQtZGlyZWN0b3J5JztcbmltcG9ydCBpbml0R2l0IGZyb20gJy4vaW5pdC1zY3JpcHRzL2luaXQtZ2l0JztcbmltcG9ydCBpbml0TlBNIGZyb20gJy4vaW5pdC1zY3JpcHRzL2luaXQtbnBtJztcbmltcG9ydCBpbnN0YWxsRGVwTGlzdCwgeyBEZXBUeXBlIH0gZnJvbSAnLi4vdXRpbC9pbnN0YWxsLWRlcGVuZGVuY2llcyc7XG5pbXBvcnQgeyByZWFkUmF3UGFja2FnZUpzb24gfSBmcm9tICcuLi91dGlsL3JlYWQtcGFja2FnZS1qc29uJztcbmltcG9ydCB7IHNldEluaXRpYWxGb3JnZUNvbmZpZyB9IGZyb20gJy4uL3V0aWwvZm9yZ2UtY29uZmlnJztcblxuY29uc3QgZCA9IGRlYnVnKCdlbGVjdHJvbi1mb3JnZTppbml0Jyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5pdE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHBhdGggdG8gdGhlIGFwcCB0byBiZSBpbml0aWFsaXplZFxuICAgKi9cbiAgZGlyPzogc3RyaW5nO1xuICAvKipcbiAgICogV2hldGhlciB0byB1c2Ugc2Vuc2libGUgZGVmYXVsdHMgb3IgcHJvbXB0IHRoZSB1c2VyIHZpc3VhbGx5XG4gICAqL1xuICBpbnRlcmFjdGl2ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGNvcHkgVHJhdmlzIGFuZCBBcHBWZXlvciBDSSBmaWxlc1xuICAgKi9cbiAgY29weUNJRmlsZXM/OiBib29sZWFuO1xuICAvKipcbiAgICogV2hldGhlciB0byBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgZGlyZWN0b3J5XG4gICAqL1xuICBmb3JjZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaGUgY3VzdG9tIHRlbXBsYXRlIHRvIHVzZS4gSWYgbGVmdCBlbXB0eSwgdGhlIGRlZmF1bHQgdGVtcGxhdGUgaXMgdXNlZFxuICAgKi9cbiAgdGVtcGxhdGU/OiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlVGVtcGxhdGUodGVtcGxhdGU6IHN0cmluZywgdGVtcGxhdGVNb2R1bGU6IEZvcmdlVGVtcGxhdGUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKCF0ZW1wbGF0ZU1vZHVsZS5yZXF1aXJlZEZvcmdlVmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHVzZSBhIHRlbXBsYXRlICgke3RlbXBsYXRlfSkgd2l0aCB0aGlzIHZlcnNpb24gb2YgRWxlY3Ryb24gRm9yZ2UsIGFzIGl0IGRvZXMgbm90IHNwZWNpZnkgaXRzIHJlcXVpcmVkIEZvcmdlIHZlcnNpb24uYCk7XG4gIH1cblxuICBjb25zdCBmb3JnZVZlcnNpb24gPSAoYXdhaXQgcmVhZFJhd1BhY2thZ2VKc29uKHBhdGguam9pbihfX2Rpcm5hbWUsICcuLicsICcuLicpKSkudmVyc2lvbjtcbiAgaWYgKCFzZW12ZXIuc2F0aXNmaWVzKGZvcmdlVmVyc2lvbiwgdGVtcGxhdGVNb2R1bGUucmVxdWlyZWRGb3JnZVZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRlbXBsYXRlICgke3RlbXBsYXRlfSkgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGlzIHZlcnNpb24gb2YgRWxlY3Ryb24gRm9yZ2UgKCR7Zm9yZ2VWZXJzaW9ufSksIGl0IHJlcXVpcmVzICR7dGVtcGxhdGVNb2R1bGUucmVxdWlyZWRGb3JnZVZlcnNpb259YFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKHsgZGlyID0gcHJvY2Vzcy5jd2QoKSwgaW50ZXJhY3RpdmUgPSBmYWxzZSwgY29weUNJRmlsZXMgPSBmYWxzZSwgZm9yY2UgPSBmYWxzZSwgdGVtcGxhdGUgPSAnYmFzZScgfTogSW5pdE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgYXN5bmNPcmEuaW50ZXJhY3RpdmUgPSBpbnRlcmFjdGl2ZTtcblxuICBkKGBJbml0aWFsaXppbmcgaW46ICR7ZGlyfWApO1xuXG4gIGF3YWl0IGluaXREaXJlY3RvcnkoZGlyLCBmb3JjZSk7XG4gIGF3YWl0IGluaXRHaXQoZGlyKTtcbiAgY29uc3QgdGVtcGxhdGVNb2R1bGUgPSBhd2FpdCBmaW5kVGVtcGxhdGUoZGlyLCB0ZW1wbGF0ZSk7XG5cbiAgYXdhaXQgdmFsaWRhdGVUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGVtcGxhdGVNb2R1bGUpO1xuXG4gIGlmICh0eXBlb2YgdGVtcGxhdGVNb2R1bGUuaW5pdGlhbGl6ZVRlbXBsYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXdhaXQgdGVtcGxhdGVNb2R1bGUuaW5pdGlhbGl6ZVRlbXBsYXRlKGRpciwgeyBjb3B5Q0lGaWxlcyB9KTtcbiAgICBjb25zdCBwYWNrYWdlSlNPTiA9IGF3YWl0IHJlYWRSYXdQYWNrYWdlSnNvbihkaXIpO1xuICAgIHNldEluaXRpYWxGb3JnZUNvbmZpZyhwYWNrYWdlSlNPTik7XG4gICAgYXdhaXQgZnMud3JpdGVKc29uKHBhdGguam9pbihkaXIsICdwYWNrYWdlLmpzb24nKSwgcGFja2FnZUpTT04sIHsgc3BhY2VzOiAyIH0pO1xuICB9XG5cbiAgYXdhaXQgYXN5bmNPcmEoJ0luc3RhbGxpbmcgVGVtcGxhdGUgRGVwZW5kZW5jaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgIGQoJ2luc3RhbGxpbmcgZGVwZW5kZW5jaWVzJyk7XG4gICAgYXdhaXQgaW5zdGFsbERlcExpc3QoZGlyLCB0ZW1wbGF0ZU1vZHVsZS5kZXBlbmRlbmNpZXMgfHwgW10pO1xuICAgIGQoJ2luc3RhbGxpbmcgZGV2RGVwZW5kZW5jaWVzJyk7XG4gICAgYXdhaXQgaW5zdGFsbERlcExpc3QoZGlyLCB0ZW1wbGF0ZU1vZHVsZS5kZXZEZXBlbmRlbmNpZXMgfHwgW10sIERlcFR5cGUuREVWKTtcbiAgfSk7XG5cbiAgYXdhaXQgaW5pdE5QTShkaXIpO1xufTtcbiJdLCJuYW1lcyI6WyJkIiwiZGVidWciLCJ2YWxpZGF0ZVRlbXBsYXRlIiwidGVtcGxhdGUiLCJ0ZW1wbGF0ZU1vZHVsZSIsInJlcXVpcmVkRm9yZ2VWZXJzaW9uIiwiRXJyb3IiLCJmb3JnZVZlcnNpb24iLCJyZWFkUmF3UGFja2FnZUpzb24iLCJwYXRoIiwiam9pbiIsIl9fZGlybmFtZSIsInZlcnNpb24iLCJzZW12ZXIiLCJzYXRpc2ZpZXMiLCJkaXIiLCJwcm9jZXNzIiwiY3dkIiwiaW50ZXJhY3RpdmUiLCJjb3B5Q0lGaWxlcyIsImZvcmNlIiwiYXN5bmNPcmEiLCJpbml0RGlyZWN0b3J5IiwiaW5pdEdpdCIsImZpbmRUZW1wbGF0ZSIsImluaXRpYWxpemVUZW1wbGF0ZSIsInBhY2thZ2VKU09OIiwic2V0SW5pdGlhbEZvcmdlQ29uZmlnIiwiZnMiLCJ3cml0ZUpzb24iLCJzcGFjZXMiLCJpbnN0YWxsRGVwTGlzdCIsImRlcGVuZGVuY2llcyIsImRldkRlcGVuZGVuY2llcyIsIkRlcFR5cGUiLCJERVYiLCJpbml0TlBNIl0sIm1hcHBpbmdzIjoiOzs7OztBQUF5QixHQUEyQixDQUEzQixTQUEyQjtBQUNsQyxHQUFPLENBQVAsTUFBTztBQUVWLEdBQVUsQ0FBVixRQUFVO0FBQ1IsR0FBTSxDQUFOLEtBQU07QUFDSixHQUFRLENBQVIsT0FBUTtBQUVGLEdBQThCLENB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