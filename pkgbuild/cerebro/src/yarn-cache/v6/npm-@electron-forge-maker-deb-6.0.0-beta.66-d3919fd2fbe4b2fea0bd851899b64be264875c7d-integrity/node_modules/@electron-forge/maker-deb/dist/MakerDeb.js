"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "MakerDebConfig", {
    enumerable: true,
    get: function() {
        return _config.MakerDebConfig;
    }
});
exports.debianArch = debianArch;
exports.default = void 0;
var _makerBase = _interopRequireDefault(require("@electron-forge/maker-base"));
var _path = _interopRequireDefault(require("path"));
var _config = require("./Config");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function debianArch(nodeArch) {
    switch(nodeArch){
        case 'ia32':
            return 'i386';
        case 'x64':
            return 'amd64';
        case 'armv7l':
            return 'armhf';
        case 'arm':
            return 'armel';
        default:
            return nodeArch;
    }
}
class MakerDeb extends _makerBase.default {
    isSupportedOnCurrentPlatform() {
        return this.isInstalled('electron-installer-debian');
    }
    async make({ dir , makeDir , targetArch  }) {
        // eslint-disable-next-line global-require, import/no-unresolved, node/no-missing-require
        const installer = require('electron-installer-debian');
        const outDir = _path.default.resolve(makeDir, 'deb', targetArch);
        await this.ensureDirectory(outDir);
        const { packagePaths  } = await installer({
            options: {},
            ...this.config,
            arch: debianArch(targetArch),
            src: dir,
            dest: outDir,
            rename: undefined
        });
        return packagePaths;
    }
    constructor(...args){
        super(...args);
        this.name = 'deb';
        this.defaultPlatforms = [
            'linux'
        ];
        this.requiredExternalBinaries = [
            'dpkg',
            'fakeroot'
        ];
    }
}
exports.default = MakerDeb;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NYWtlckRlYi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTWFrZXJCYXNlLCB7IE1ha2VyT3B0aW9ucyB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9tYWtlci1iYXNlJztcbmltcG9ydCB7IEZvcmdlQXJjaCwgRm9yZ2VQbGF0Zm9ybSB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9zaGFyZWQtdHlwZXMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7IE1ha2VyRGViQ29uZmlnIH0gZnJvbSAnLi9Db25maWcnO1xuXG5leHBvcnQgZnVuY3Rpb24gZGViaWFuQXJjaChub2RlQXJjaDogRm9yZ2VBcmNoKTogc3RyaW5nIHtcbiAgc3dpdGNoIChub2RlQXJjaCkge1xuICAgIGNhc2UgJ2lhMzInOlxuICAgICAgcmV0dXJuICdpMzg2JztcbiAgICBjYXNlICd4NjQnOlxuICAgICAgcmV0dXJuICdhbWQ2NCc7XG4gICAgY2FzZSAnYXJtdjdsJzpcbiAgICAgIHJldHVybiAnYXJtaGYnO1xuICAgIGNhc2UgJ2FybSc6XG4gICAgICByZXR1cm4gJ2FybWVsJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5vZGVBcmNoO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ha2VyRGViIGV4dGVuZHMgTWFrZXJCYXNlPE1ha2VyRGViQ29uZmlnPiB7XG4gIG5hbWUgPSAnZGViJztcblxuICBkZWZhdWx0UGxhdGZvcm1zOiBGb3JnZVBsYXRmb3JtW10gPSBbJ2xpbnV4J107XG5cbiAgcmVxdWlyZWRFeHRlcm5hbEJpbmFyaWVzOiBzdHJpbmdbXSA9IFsnZHBrZycsICdmYWtlcm9vdCddO1xuXG4gIGlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbnN0YWxsZWQoJ2VsZWN0cm9uLWluc3RhbGxlci1kZWJpYW4nKTtcbiAgfVxuXG4gIGFzeW5jIG1ha2UoeyBkaXIsIG1ha2VEaXIsIHRhcmdldEFyY2ggfTogTWFrZXJPcHRpb25zKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnbG9iYWwtcmVxdWlyZSwgaW1wb3J0L25vLXVucmVzb2x2ZWQsIG5vZGUvbm8tbWlzc2luZy1yZXF1aXJlXG4gICAgY29uc3QgaW5zdGFsbGVyID0gcmVxdWlyZSgnZWxlY3Ryb24taW5zdGFsbGVyLWRlYmlhbicpO1xuXG4gICAgY29uc3Qgb3V0RGlyID0gcGF0aC5yZXNvbHZlKG1ha2VEaXIsICdkZWInLCB0YXJnZXRBcmNoKTtcblxuICAgIGF3YWl0IHRoaXMuZW5zdXJlRGlyZWN0b3J5KG91dERpcik7XG4gICAgY29uc3QgeyBwYWNrYWdlUGF0aHMgfSA9IGF3YWl0IGluc3RhbGxlcih7XG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgYXJjaDogZGViaWFuQXJjaCh0YXJnZXRBcmNoKSxcbiAgICAgIHNyYzogZGlyLFxuICAgICAgZGVzdDogb3V0RGlyLFxuICAgICAgcmVuYW1lOiB1bmRlZmluZWQsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGFja2FnZVBhdGhzO1xuICB9XG59XG5cbmV4cG9ydCB7IE1ha2VyRGViQ29uZmlnIH07XG4iXSwibmFtZXMiOlsiTWFrZXJEZWJDb25maWciLCJkZWJpYW5BcmNoIiwibm9kZUFyY2giLCJNYWtlckRlYiIsIk1ha2VyQmFzZSIsImlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0iLCJpc0luc3RhbGxlZCIsIm1ha2UiLCJkaXIiLCJtYWtlRGlyIiwidGFyZ2V0QXJjaCIsImluc3RhbGxlciIsInJlcXVpcmUiLCJvdXREaXIiLCJwYXRoIiwicmVzb2x2ZSIsImVuc3VyZURpcmVjdG9yeSIsInBhY2thZ2VQYXRocyIsIm9wdGlvbnMiLCJjb25maWciLCJhcmNoIiwic3JjIiwiZGVzdCIsInJlbmFtZSIsInVuZGVmaW5lZCIsIm5hbWUiLCJkZWZhdWx0UGxhdGZvcm1zIiwicmVxdWlyZWRFeHRlcm5hbEJpbmFyaWVzIl0sIm1hcHBpbmdzIjoiOzs7OytCQW9EU0EsQ0FBYzs7O2VBQWRBLE9BQWM7OztRQTlDUEMsVUFBVSxHQUFWQSxVQUFVOztBQU5jLEdBQTRCLENBQTVCLFVBQTRCO0FBRW5ELEdBQU0sQ0FBTixLQUFNO0FBRVEsR0FBVSxDQUFWLE9BQVU7Ozs7OztTQUV6QkEsVUFBVSxDQUFDQyxRQUFtQixFQUFVLENBQUM7SUFDdkQsTUFBTSxDQUFFQSxRQUFRO1FBQ2QsSUFBSSxDQUFDLENBQU07WUFDVCxNQUFNLENBQUMsQ0FBTTtRQUNmLElBQUksQ0FBQyxDQUFLO1lBQ1IsTUFBTSxDQUFDLENBQU87UUFDaEIsSUFBSSxDQUFDLENBQVE7WUFDWCxNQUFNLENBQUMsQ0FBTztRQUNoQixJQUFJLENBQUMsQ0FBSztZQUNSLE1BQU0sQ0FBQyxDQUFPOztZQUVkLE1BQU0sQ0FBQ0EsUUFBUTs7QUFFckIsQ0FBQztNQUVvQkMsUUFBUSxTQUFTQyxVQUFTO0lBTzdDQyw0QkFBNEIsR0FBWSxDQUFDO1FBQ3ZDLE1BQU0sQ0FBQyxJQUFJLENBQUNDLFdBQVcsQ0FBQyxDQUEyQjtJQUNyRCxDQUFDO1VBRUtDLElBQUksQ0FBQyxDQUFDLENBQUNDLEdBQUcsR0FBRUMsT0FBTyxHQUFFQyxVQUFVLEVBQWUsQ0FBQyxFQUFxQixDQUFDO1FBQ3pFLEVBQXlGLEFBQXpGLHVGQUF5RjtRQUN6RixLQUFLLENBQUNDLFNBQVMsR0FBR0MsT0FBTyxDQUFDLENBQTJCO1FBRXJELEtBQUssQ0FBQ0MsTUFBTSxHQUFHQyxLQUFJLFNBQUNDLE9BQU8sQ0FBQ04sT0FBTyxFQUFFLENBQUssTUFBRUMsVUFBVTtRQUV0RCxLQUFLLENBQUMsSUFBSSxDQUFDTSxlQUFlLENBQUNILE1BQU07UUFDakMsS0FBSyxDQUFDLENBQUMsQ0FBQ0ksWUFBWSxFQUFDLENBQUMsR0FBRyxLQUFLLENBQUNOLFNBQVMsQ0FBQyxDQUFDO1lBQ3hDTyxPQUFPLEVBQUUsQ0FBQyxDQUFDO2VBQ1IsSUFBSSxDQUFDQyxNQUFNO1lBQ2RDLElBQUksRUFBRW5CLFVBQVUsQ0FBQ1MsVUFBVTtZQUMzQlcsR0FBRyxFQUFFYixHQUFHO1lBQ1JjLElBQUksRUFBRVQsTUFBTTtZQUNaVSxNQUFNLEVBQUVDLFNBQVM7UUFDbkIsQ0FBQztRQUVELE1BQU0sQ0FBQ1AsWUFBWTtJQUNyQixDQUFDOzs7UUE1QlksSUE2QmQsQ0E1QkNRLElBQUksR0FBRyxDQUFLO1FBREMsSUE2QmQsQ0ExQkNDLGdCQUFnQixHQUFvQixDQUFDO1lBQUEsQ0FBTztRQUFBLENBQUM7UUFIaEMsSUE2QmQsQ0F4QkNDLHdCQUF3QixHQUFhLENBQUM7WUFBQSxDQUFNO1lBQUUsQ0FBVTtRQUFBLENBQUM7OztrQkFMdEN4QixRQUFRIn0=