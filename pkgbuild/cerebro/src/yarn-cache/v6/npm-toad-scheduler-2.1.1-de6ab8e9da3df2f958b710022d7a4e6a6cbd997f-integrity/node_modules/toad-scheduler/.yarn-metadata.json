{
  "manifest": {
    "name": "toad-scheduler",
    "version": "2.1.1",
    "license": "MIT",
    "description": "In-memory Node.js and browser job scheduler",
    "maintainers": [
      {
        "name": "Igor Savin",
        "email": "kibertoad@gmail.com"
      }
    ],
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "scripts": {
      "build": "tsc",
      "test": "jest --config=jest.config.json",
      "test:coverage": "jest --config=jest.config.json --coverage",
      "test:karma": "karma start --single-run --browsers ChromeHeadless karma.conf.js",
      "lint": "eslint \"lib/**/*.ts\" \"test/**/*.ts\"",
      "format": "prettier --write \"{lib,test}/**/*.{js,ts}\" index.ts",
      "prepublishOnly": "npm run build"
    },
    "devDependencies": {
      "@types/jest": "^28.1.8",
      "@types/node": "^18.11.17",
      "@typescript-eslint/eslint-plugin": "^5.47.0",
      "@typescript-eslint/parser": "^5.47.0",
      "eslint": "^8.30.0",
      "eslint-config-prettier": "^8.5.0",
      "eslint-plugin-prettier": "^4.2.1",
      "jasmine-core": "^4.5.0",
      "jest": "^28.1.3",
      "karma": "^6.4.1",
      "karma-chrome-launcher": "^3.1.1",
      "karma-jasmine": "^5.1.0",
      "karma-typescript": "^5.5.3",
      "prettier": "^2.8.1",
      "ts-jest": "^28.0.8",
      "typescript": "4.9.4"
    },
    "homepage": "https://github.com/kibertoad/toad-scheduler",
    "repository": {
      "type": "git",
      "url": "git://github.com/kibertoad/toad-scheduler.git"
    },
    "keywords": [
      "schedule",
      "scheduler",
      "in-memory",
      "browser",
      "job",
      "task"
    ],
    "files": [
      "README.md",
      "LICENSE",
      "dist/*"
    ],
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-toad-scheduler-2.1.1-de6ab8e9da3df2f958b710022d7a4e6a6cbd997f-integrity/node_modules/toad-scheduler/package.json",
    "readmeFilename": "README.md",
    "readme": "# toad-scheduler\n\n[![NPM Version][npm-image]][npm-url]\n[![NPM Downloads][downloads-image]][downloads-url]\n[![Build Status](https://github.com/kibertoad/toad-scheduler/workflows/ci/badge.svg)](https://github.com/kibertoad/toad-scheduler/actions)\n[![Coverage Status](https://coveralls.io/repos/kibertoad/toad-scheduler/badge.svg?branch=main)](https://coveralls.io/r/kibertoad/toad-scheduler?branch=main)\n\nIn-memory TypeScript job scheduler that repeatedly executes given tasks within specified intervals of time (e. g. \"each 20 seconds\").\n\nNode.js 12+ and modern browsers are supported\n\n## Getting started\n\nFirst install the package:\n\n```bash\nnpm i toad-scheduler\n```\n\nNext, set up your jobs:\n\n```js\nconst { ToadScheduler, SimpleIntervalJob, Task } = require('toad-scheduler')\n\nconst scheduler = new ToadScheduler()\n\nconst task = new Task('simple task', () => { counter++ })\nconst job = new SimpleIntervalJob({ seconds: 20, }, task)\n\nscheduler.addSimpleIntervalJob(job)\n\n// when stopping your app\nscheduler.stop()\n```\n\n\n## Usage with async tasks\n\nIn order to avoid unhandled rejections, make sure to use AsyncTask if your task is asynchronous:\n\n```js\nconst { ToadScheduler, SimpleIntervalJob, AsyncTask } = require('toad-scheduler')\n\nconst scheduler = new ToadScheduler()\n\nconst task = new AsyncTask(\n    'simple task', \n    () => { return db.pollForSomeData().then((result) => { /* continue the promise chain */ }) },\n    (err: Error) => { /* handle error here */ }\n)\nconst job = new SimpleIntervalJob({ seconds: 20, }, task)\n\nscheduler.addSimpleIntervalJob(job)\n\n// when stopping your app\nscheduler.stop()\n```\n\nNote that in order to avoid memory leaks, it is recommended to use promise chains instead of async/await inside task definition. See [talk on common Promise mistakes](https://www.youtube.com/watch?v=XV-u_Ow47s0) for more details.\n\n## Asynchronous error handling\n\nNote that your error handlers can be asynchronous and return a promise. In such case an additional catch block will be attached to them, and should\nthere be an error while trying to resolve that promise, and logging error will be logged using the default error handler (`console.error`).\n\n## Preventing task run overruns\n\nIn case you want to prevent second instance of a task from being fired up while first one is still executing, you can use `preventOverrun` options:\n```js\nimport { ToadScheduler, SimpleIntervalJob, Task } from 'toad-scheduler';\n\nconst scheduler = new ToadScheduler();\n\nconst task = new Task('simple task', () => {\n    // if this task runs long, second one won't be started until this one concludes\n\tconsole.log('Task triggered');\n});\n\nconst job = new SimpleIntervalJob(\n\t{ seconds: 20, runImmediately: true },\n\ttask,\n    { \n        id: 'id_1',\n        preventOverrun: true,\n    }\n);\n\n//create and start jobs\nscheduler.addSimpleIntervalJob(job);\n```\n\n## Using IDs and ES6-style imports\n\nYou can attach IDs to tasks to identify them later. This is helpful in projects that run a lot of tasks and especially if you want to target some of the tasks specifically (e. g. in order to stop or restart them, or to check their status).\n\n```js\nimport { ToadScheduler, SimpleIntervalJob, Task } from 'toad-scheduler';\n\nconst scheduler = new ToadScheduler();\n\nconst task = new Task('simple task', () => {\n\tconsole.log('Task triggered');\n});\n\nconst job1 = new SimpleIntervalJob(\n\t{ seconds: 20, runImmediately: true },\n\ttask,\n    { id: 'id_1' }\n);\n\nconst job2 = new SimpleIntervalJob(\n\t{ seconds: 15, runImmediately: true },\n\ttask,\n    { id: 'id_2' }\n);\n\n//create and start jobs\nscheduler.addSimpleIntervalJob(job1);\nscheduler.addSimpleIntervalJob(job2);\n\n// stop job with ID: id_2\nscheduler.stopById('id_2');\n\n// remove job with ID: id_1\nscheduler.removeById('id_1');\n\n// check status of jobs\nconsole.log(scheduler.getById('id_1').getStatus()); // returns Error (job not found)\n\nconsole.log(scheduler.getById('id_2').getStatus()); // returns \"stopped\" and can be started again\n\n```\n\n## Usage in clustered environments\n\n`toad-scheduler` does not persist its state by design, and has no out-of-the-box concurrency management features. In case it is necessary\nto prevent parallel execution of jobs in clustered environment, it is highly recommended to use [redis-semaphore](https://github.com/swarthy/redis-semaphore) in your tasks.\n\nHere is an example:\n\n```ts\nimport { randomUUID } from 'crypto'\n\nimport type Redis from 'ioredis'\nimport { Mutex } from 'redis-semaphore'\nimport type { LockOptions } from 'redis-semaphore'\nimport { AsyncTask } from 'toad-scheduler';\n\nexport type BackgroundJobConfiguration = {\n    jobId: string\n}\n\nexport type LockConfiguration = {\n    lockName?: string\n    refreshInterval?: number\n    lockTimeout: number\n}\n\nexport abstract class AbstractBackgroundJob {\n    public readonly jobId: string\n    protected readonly redis: Redis\n\n    protected constructor(\n        options: BackgroundJobConfiguration,\n        redis: Redis,\n    ) {\n        this.jobId = options.jobId\n        this.redis = redis\n    }\n\n    protected abstract processInternal(executionUuid: string): Promise<void>\n\n    async process() {\n        const uuid = randomUUID()\n\n        try {\n            await this.processInternal(uuid)\n        } catch (err) {\n            console.error(logObject)\n        }\n    }\n\n    protected getJobMutex(key: string, options: LockOptions) {\n        return new Mutex(this.redis, this.getJobLockName(key), options)\n    }\n\n    protected async tryAcquireExclusiveLock(lockConfiguration: LockConfiguration) {\n        const mutex = this.getJobMutex(lockConfiguration.lockName ?? 'exclusive', {\n            acquireAttemptsLimit: 1,\n            refreshInterval: lockConfiguration.refreshInterval,\n            lockTimeout: lockConfiguration.lockTimeout,\n        })\n\n        const lock = await mutex.tryAcquire()\n        // If someone else already has this lock, skip\n        if (!lock) {\n            return\n        }\n\n        return mutex\n    }\n\n    protected getJobLockName(key: string) {\n        return `${this.jobId}:locks:${key}`\n    }\n}\n\nfunction createTask(job: AbstractBackgroundJob): AsyncTask {\n    return new AsyncTask(\n        job.jobId,\n        () => {\n            return job.process()\n        },\n    )\n}\n```\n\n## API for schedule\n\n* `days?: number` - how many days to wait before executing the job for the next time;\n* `hours?: number` - how many hours to wait before executing the job for the next time;\n* `minutes?: number` - how many minutes to wait before executing the job for the next time;\n* `seconds?: number` - how many seconds to wait before executing the job for the next time;\n* `milliseconds?: number` - how many milliseconds to wait before executing the job for the next time;\n* `runImmediately?: boolean` - if set to true, in addition to being executed on a given interval, job will also be executed immediately when added or restarted. \n\n## API for jobs\n\n* `start(): void` - starts, or restarts (if it's already running) the job;\n* `stop(): void` - stops the job. Can be restarted again with `start` command;\n* `getStatus(): JobStatus` - returns the status of the job, which is one of: `running`, `stopped`.\n\n## API for scheduler\n\n* `addSimpleIntervalJob(job: SimpleIntervalJob): void` - registers and starts a new job;\n* `addLongIntervalJob(job: SimpleIntervalJob): void` - registers and starts a new job with support for intervals longer than 24.85 days;\n* `addIntervalJob(job: SimpleIntervalJob | LongIntervalJob): void` - registers and starts new interval-based job;\n* `stop(): void` - stops all jobs, registered in the scheduler;\n* `getById(id: string): Job` - returns the job with a given id.\n* `existsById(id: string): boolean` - returns true if job with given id exists, false otherwise.\n* `stopById(id: string): void` - stops the job with a given id.\n* `removeById(id: string): Job | undefined` - stops the job with a given id and removes it from the scheduler. If no such job exists, returns `undefined`, otherwise returns the job.\n* `startById(id: string): void` - starts, or restarts (if it's already running) the job with a given id.\n\n[npm-image]: https://img.shields.io/npm/v/toad-scheduler.svg\n[npm-url]: https://npmjs.org/package/toad-scheduler\n[downloads-image]: https://img.shields.io/npm/dm/toad-scheduler.svg\n[downloads-url]: https://npmjs.org/package/toad-scheduler\n",
    "licenseText": "MIT License\n\nCopyright (c) 2021 Igor Savin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/toad-scheduler/-/toad-scheduler-2.1.1.tgz#de6ab8e9da3df2f958b710022d7a4e6a6cbd997f",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/toad-scheduler/-/toad-scheduler-2.1.1.tgz",
    "hash": "de6ab8e9da3df2f958b710022d7a4e6a6cbd997f",
    "integrity": "sha512-XOeke4vAj3P93hayxmHI734RjsBMqbwotMIPQJ/jVwNMYk+LHpbClvHs4R4PWXXR2GIkmMA518JDkYfBiWWtEQ==",
    "registry": "npm",
    "packageName": "toad-scheduler",
    "cacheIntegrity": "sha512-XOeke4vAj3P93hayxmHI734RjsBMqbwotMIPQJ/jVwNMYk+LHpbClvHs4R4PWXXR2GIkmMA518JDkYfBiWWtEQ== sha1-3mq46do98vlYtxACLXpOamy9mX8="
  },
  "registry": "npm",
  "hash": "de6ab8e9da3df2f958b710022d7a4e6a6cbd997f"
}