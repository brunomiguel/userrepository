{
  "manifest": {
    "name": "saxes",
    "description": "An evented streaming XML parser in JavaScript",
    "author": {
      "name": "Louis-Dominique Dubeau",
      "email": "ldd@lddubeau.com"
    },
    "version": "6.0.0",
    "main": "saxes.js",
    "types": "saxes.d.ts",
    "license": "ISC",
    "engines": {
      "node": ">=v12.22.7"
    },
    "scripts": {
      "tsc": "tsc",
      "copy": "cp -p README.md build/dist && sed -e'/\"private\": true/d' package.json > build/dist/package.json",
      "build": "npm run tsc && npm run copy",
      "test": "npm run build && mocha --delay",
      "lint": "eslint --ignore-path .gitignore '**/*.ts' '**/*.js'",
      "lint-fix": "npm run lint -- --fix",
      "posttest": "npm run lint",
      "typedoc": "typedoc --tsconfig tsconfig.json --name saxes --out build/docs/ --listInvalidSymbolLinks --excludePrivate --excludeNotExported",
      "build-docs": "npm run typedoc",
      "gh-pages": "npm run build-docs && mkdir -p build && (cd build; rm -rf gh-pages; git clone .. --branch gh-pages gh-pages) && mkdir -p build/gh-pages/latest && find build/gh-pages/latest -type f -delete && cp -rp build/docs/* build/gh-pages/latest && find build/gh-pages -type d -empty -delete",
      "self:publish": "cd build/dist && npm_config_tag=`simple-dist-tag` npm publish",
      "version": "conventional-changelog -p angular -i CHANGELOG.md -s && git add CHANGELOG.md",
      "postversion": "npm run test && npm run self:publish",
      "postpublish": "git push origin --follow-tags"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/lddubeau/saxes.git"
    },
    "devDependencies": {
      "@commitlint/cli": "^14.1.0",
      "@commitlint/config-angular": "^14.1.0",
      "@types/chai": "^4.2.22",
      "@types/mocha": "^9.0.0",
      "@types/node": "^16.11.6",
      "@typescript-eslint/eslint-plugin": "^5.3.0",
      "@typescript-eslint/eslint-plugin-tslint": "^5.3.0",
      "@typescript-eslint/parser": "^5.3.0",
      "@xml-conformance-suite/js": "^3.0.0",
      "@xml-conformance-suite/mocha": "^3.0.0",
      "@xml-conformance-suite/test-data": "^3.0.0",
      "chai": "^4.3.4",
      "conventional-changelog-cli": "^2.1.1",
      "eslint": "^8.2.0",
      "eslint-config-lddubeau-base": "^6.1.0",
      "eslint-config-lddubeau-ts": "^2.0.2",
      "eslint-import-resolver-typescript": "^2.5.0",
      "eslint-plugin-import": "^2.25.2",
      "eslint-plugin-jsx-a11y": "^6.4.1",
      "eslint-plugin-prefer-arrow": "^1.2.3",
      "eslint-plugin-react": "^7.26.1",
      "eslint-plugin-simple-import-sort": "^7.0.0",
      "husky": "^7.0.4",
      "mocha": "^9.1.3",
      "renovate-config-lddubeau": "^1.0.0",
      "simple-dist-tag": "^1.0.2",
      "ts-node": "^10.4.0",
      "tsd": "^0.18.0",
      "tslint": "^6.1.3",
      "tslint-microsoft-contrib": "^6.2.0",
      "typedoc": "^0.22.8",
      "typescript": "^4.4.4"
    },
    "dependencies": {
      "xmlchars": "^2.2.0"
    },
    "husky": {
      "hooks": {
        "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
      }
    },
    "_registry": "npm",
    "_loc": "/home/brunomiguel/userrepository/pkgbuild/cerebro/src/yarn-cache/v6/npm-saxes-6.0.0-fe5b4a4768df4f14a201b1ba6a65c1f3d9988cc5-integrity/node_modules/saxes/package.json",
    "readmeFilename": "README.md",
    "readme": "# saxes\n\nA sax-style non-validating parser for XML.\n\nSaxes is a fork of [sax](https://github.com/isaacs/sax-js) 1.2.4. All mentions\nof sax in this project's documentation are references to sax 1.2.4.\n\nDesigned with [node](http://nodejs.org/) in mind, but should work fine in the\nbrowser or other CommonJS implementations.\n\nSaxes does not support Node versions older than 10.\n\n## Notable Differences from Sax.\n\n* Saxes aims to be much stricter than sax with regards to XML\n  well-formedness. Sax, even in its so-called \"strict mode\", is not strict. It\n  silently accepts structures that are not well-formed XML. Projects that need\n  better compliance with well-formedness constraints cannot use sax as-is.\n\n  Consequently, saxes does not support HTML, or pseudo-XML, or bad XML. Saxes\n  will report well-formedness errors in all these cases but it won't try to\n  extract data from malformed documents like sax does.\n\n* Saxes is much much faster than sax, mostly because of a substantial redesign\n  of the internal parsing logic. The speed improvement is not merely due to\n  removing features that were supported by sax. That helped a bit, but saxes\n  adds some expensive checks in its aim for conformance with the XML\n  specification. Redesigning the parsing logic is what accounts for most of the\n  performance improvement.\n\n* Saxes does not aim to support antiquated platforms. We will not pollute the\n  source or the default build with support for antiquated platforms. If you want\n  support for IE 11, you are welcome to produce a PR that adds a *new build*\n  transpiled to ES5.\n\n* Saxes handles errors differently from sax: it provides a default onerror\n  handler which throws. You can replace it with your own handler if you want. If\n  your handler does nothing, there is no `resume` method to call.\n\n* There's no `Stream` API. A revamped API may be introduced later. (It is still\n  a \"streaming parser\" in the general sense that you write a character stream to\n  it.)\n\n* Saxes does not have facilities for limiting the size the data chunks passed to\n  event handlers. See the FAQ entry for more details.\n\n## Conformance\n\nSaxes supports:\n\n* [XML 1.0 fifth edition](https://www.w3.org/TR/2008/REC-xml-20081126/)\n* [XML 1.1 second edition](https://www.w3.org/TR/2006/REC-xml11-20060816/)\n* [Namespaces in XML 1.0 (Third Edition)](https://www.w3.org/TR/2009/REC-xml-names-20091208/).\n* [Namespaces in XML 1.1 (Second Edition)](https://www.w3.org/TR/2006/REC-xml-names11-20060816/).\n\n## Limitations\n\nThis is a non-validating parser so it only verifies whether the document is\nwell-formed. We do aim to raise errors for all malformed constructs\nencountered. However, this parser does not thorougly parse the contents of\nDTDs. So most malformedness errors caused by errors **in DTDs** cannot be\nreported.\n\n## Regarding `<!DOCTYPE` and `<!ENTITY`\n\nThe parser will handle the basic XML entities in text nodes and attribute\nvalues: `&amp; &lt; &gt; &apos; &quot;`. It's possible to define additional\nentities in XML by putting them in the DTD. This parser doesn't do anything with\nthat. If you want to listen to the `doctype` event, and then fetch the\ndoctypes, and read the entities and add them to `parser.ENTITIES`, then be my\nguest.\n\n## Documentation\n\nThe source code contains JSDOC comments. Use them. What follows is a brief\nsummary of what is available. The final authority is the source code.\n\n**PAY CLOSE ATTENTION TO WHAT IS PUBLIC AND WHAT IS PRIVATE.**\n\nThe move to TypeScript makes it so that everything is now formally private,\nprotected, or public.\n\nIf you use anything not public, that's at your own peril.\n\nIf there's a mistake in the documentation, raise an issue. If you just assume,\nyou may assume incorrectly.\n\n## Summary Usage Information\n\n### Example\n\n```javascript\nvar saxes = require(\"./lib/saxes\"),\n  parser = new saxes.SaxesParser();\n\nparser.on(\"error\", function (e) {\n  // an error happened.\n});\nparser.on(\"text\", function (t) {\n  // got some text.  t is the string of text.\n});\nparser.on(\"opentag\", function (node) {\n  // opened a tag.  node has \"name\" and \"attributes\"\n});\nparser.on(\"end\", function () {\n  // parser stream is done, and ready to have more stuff written to it.\n});\n\nparser.write('<xml>Hello, <who name=\"world\">world</who>!</xml>').close();\n```\n\n### Constructor Arguments\n\nSettings supported:\n\n* `xmlns` - Boolean. If `true`, then namespaces are supported. Default\n  is `false`.\n\n* `position` - Boolean. If `false`, then don't track line/col/position. Unset is\n  treated as `true`. Default is unset. Currently, setting this to `false` only\n  results in a cosmetic change: the errors reported do not contain position\n  information. sax-js would literally turn off the position-computing logic if\n  this flag was set to false. The notion was that it would optimize\n  execution. In saxes at least it turns out that continually testing this flag\n  causes a cost that offsets the benefits of turning off this logic.\n\n* `fileName` - String. Set a file name for error reporting. This is useful only\n  when tracking positions. You may leave it unset.\n\n* `fragment` - Boolean. If `true`, parse the XML as an XML fragment. Default is\n  `false`.\n\n* `additionalNamespaces` - A plain object whose key, value pairs define\n   namespaces known before parsing the XML file. It is not legal to pass\n   bindings for the namespaces `\"xml\"` or `\"xmlns\"`.\n\n* `defaultXMLVersion` - The default version of the XML specification to use if\n  the document contains no XML declaration. If the document does contain an XML\n  declaration, then this setting is ignored. Must be `\"1.0\"` or `\"1.1\"`. The\n  default is `\"1.0\"`.\n\n* `forceXMLVersion` - Boolean. A flag indicating whether to force the XML\n  version used for parsing to the value of ``defaultXMLVersion``. When this flag\n  is ``true``, ``defaultXMLVersion`` must be specified. If unspecified, the\n  default value of this flag is ``false``.\n\n  Example: suppose you are parsing a document that has an XML declaration\n  specifying XML version 1.1.\n\n  If you set ``defaultXMLVersion`` to ``\"1.0\"`` without setting\n  ``forceXMLVersion`` then the XML declaration will override the value of\n  ``defaultXMLVersion`` and the document will be parsed according to XML 1.1.\n\n  If you set ``defaultXMLVersion`` to ``\"1.0\"`` and set ``forceXMLVersion`` to\n  ``true``, then the XML declaration will be ignored and the document will be\n  parsed according to XML 1.0.\n\n### Methods\n\n`write` - Write bytes onto the stream. You don't have to pass the whole document\nin one `write` call. You can read your source chunk by chunk and call `write`\nwith each chunk.\n\n`close` - Close the stream. Once closed, no more data may be written until it is\ndone processing the buffer, which is signaled by the `end` event.\n\n### Properties\n\nThe parser has the following properties:\n\n`line`, `column`, `columnIndex`, `position` - Indications of the position in the\nXML document where the parser currently is looking. The `columnIndex` property\ncounts columns as if indexing into a JavaScript string, whereas the `column`\nproperty counts Unicode characters.\n\n`closed` - Boolean indicating whether or not the parser can be written to.  If\nit's `true`, then wait for the `ready` event to write again.\n\n`opt` - Any options passed into the constructor.\n\n`xmlDecl` - The XML declaration for this document. It contains the fields\n`version`, `encoding` and `standalone`. They are all `undefined` before\nencountering the XML declaration. If they are undefined after the XML\ndeclaration, the corresponding value was not set by the declaration. There is no\nevent associated with the XML declaration. In a well-formed document, the XML\ndeclaration may be preceded only by an optional BOM. So by the time any event\ngenerated by the parser happens, the declaration has been processed if present\nat all. Otherwise, you have a malformed document, and as stated above, you\ncannot rely on the parser data!\n\n### Error Handling\n\nThe parser continues to parse even upon encountering errors, and does its best\nto continue reporting errors. You should heed all errors reported. After an\nerror, however, saxes may interpret your document incorrectly. For instance\n``<foo a=bc=\"d\"/>`` is invalid XML. Did you mean to have ``<foo a=\"bc=d\"/>`` or\n``<foo a=\"b\" c=\"d\"/>`` or some other variation?  For the sake of continuing to\nprovide errors, saxes will continue parsing the document, but the structure it\nreports may be incorrect. It is only after the errors are fixed in the document\nthat saxes can provide a reliable interpretation of the document.\n\nThat leaves you with two rules of thumb when using saxes:\n\n* Pay attention to the errors that saxes report. The default `onerror` handler\n  throws, so by default, you cannot miss errors.\n\n* **ONCE AN ERROR HAS BEEN ENCOUNTERED, STOP RELYING ON THE EVENT HANDLERS OTHER\n  THAN `onerror`.** As explained above, when saxes runs into a well-formedness\n  problem, it makes a guess in order to continue reporting more errors. The guess\n  may be wrong.\n\n### Events\n\nTo listen to an event, override `on<eventname>`. The list of supported events\nare also in the exported `EVENTS` array.\n\nSee the JSDOC comments in the source code for a description of each supported\nevent.\n\n### Parsing XML Fragments\n\nThe XML specification does not define any method by which to parse XML\nfragments. However, there are usage scenarios in which it is desirable to parse\nfragments. In order to allow this, saxes provides three initialization options.\n\nIf you pass the option `fragment: true` to the parser constructor, the parser\nwill expect an XML fragment. It essentially starts with a parsing state\nequivalent to the one it would be in if `parser.write(\"<foo\">)` had been called\nright after initialization. In other words, it expects content which is\nacceptable inside an element. This also turns off well-formedness checks that\nare inappropriate when parsing a fragment.\n\nThe option `additionalNamespaces` allows you to define additional prefix-to-URI\nbindings known before parsing starts. You would use this over `resolvePrefix` if\nyou have at the ready a series of namespaces bindings to use.\n\nThe option `resolvePrefix` allows you to pass a function which saxes will use if\nit is unable to resolve a namespace prefix by itself. You would use this over\n`additionalNamespaces` in a context where getting a complete list of defined\nnamespaces is onerous.\n\nNote that you can use `additionalNamespaces` and `resolvePrefix` together if you\nwant. `additionalNamespaces` applies before `resolvePrefix`.\n\nThe options `additionalNamespaces` and `resolvePrefix` are really meant to be\nused for parsing fragments. However, saxes won't prevent you from using them\nwith `fragment: false`. Note that if you do this, your document may parse\nwithout errors and yet be malformed because the document can refer to namespaces\nwhich are not defined *in* the document.\n\nOf course, `additionalNamespaces` and `resolvePrefix` are used only if `xmlns`\nis `true`. If you are parsing a fragment that does not use namespaces, there's\nno point in setting these options.\n\n### Performance Tips\n\n* saxes works faster on files that use newlines (``\\u000A``) as end of line\n  markers than files that use other end of line markers (like ``\\r`` or\n  ``\\r\\n``). The XML specification requires that conformant applications behave\n  as if all characters that are to be treated as end of line characters are\n  converted to ``\\u000A`` prior to parsing. The optimal code path for saxes is a\n  file in which all end of line characters are already ``\\u000A``.\n\n* Don't split Unicode strings you feed to saxes across surrogates. When you\n  naively split a string in JavaScript, you run the risk of splitting a Unicode\n  character into two surrogates. e.g.  In the following example ``a`` and ``b``\n  each contain half of a single Unicode character: ``const a = \"\\u{1F4A9}\"[0];\n  const b = \"\\u{1F4A9}\"[1]`` If you feed such split surrogates to versions of\n  saxes prior to 4, you'd get errors. Saxes version 4 and over are able to\n  detect when a chunk of data ends with a surrogate and carry over the surrogate\n  to the next chunk. However this operation entails slicing and concatenating\n  strings. If you can feed your data in a way that does not split surrogates,\n  you should do it. (Obviously, feeding all the data at once with a single write\n  is fastest.)\n\n* Don't set event handlers you don't need. Saxes has always aimed to avoid doing\n  work that will just be tossed away but future improvements hope to do this\n  more aggressively. One way saxes knows whether or not some data is needed is\n  by checking whether a handler has been set for a specific event.\n\n## FAQ\n\nQ. Why has saxes dropped support for limiting the size of data chunks passed to\nevent handlers?\n\nA. With sax you could set ``MAX_BUFFER_LENGTH`` to cause the parser to limit the\nsize of data chunks passed to event handlers. So if you ran into a span of text\nabove the limit, multiple ``text`` events with smaller data chunks were fired\ninstead of a single event with a large chunk.\n\nHowever, that functionality had some problematic characteristics. It had an\narbitrary default value. It was library-wide so all parsers created from a\nsingle instance of the ``sax`` library shared it. This could potentially cause\nconflicts among libraries running in the same VM but using sax for different\npurposes.\n\nThese issues could have been easily fixed, but there were larger issues. The\nbuffer limit arbitrarily applied to some events but not others. It would split\n``text``, ``cdata`` and ``script`` events. However, if a ``comment``,\n``doctype``, ``attribute`` or ``processing instruction`` were more than the\nlimit, the parser would generate an error and you were left picking up the\npieces.\n\nIt was not intuitive to use. You'd think setting the limit to 1K would prevent\nchunks bigger than 1K to be passed to event handlers. But that was not the\ncase. A comment in the source code told you that you might go over the limit if\nyou passed large chunks to ``write``. So if you want a 1K limit, don't pass 64K\nchunks to ``write``. Fair enough. You know what limit you want so you can\ncontrol the size of the data you pass to ``write``. So you limit the chunks to\n``write`` to 1K at a time. Even if you do this, your event handlers may get data\nchunks that are 2K in size. Suppose on the previous ``write`` the parser has\njust finished processing an open tag, so it is ready for text. Your ``write``\npasses 1K of text. You are not above the limit yet, so no event is generated\nyet. The next ``write`` passes another 1K of text. It so happens that sax checks\nbuffer limits only once per ``write``, after the chunk of data has been\nprocessed. Now you've hit the limit and you get a ``text`` event with 2K of\ndata. So even if you limit your ``write`` calls to the buffer limit you've set,\nyou may still get events with chunks at twice the buffer size limit you've\nspecified.\n\nWe may consider reinstating an equivalent functionality, provided that it\naddresses the issues above and does not cause a huge performance drop for\nuse-case scenarios that don't need it.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/saxes/-/saxes-6.0.0.tgz#fe5b4a4768df4f14a201b1ba6a65c1f3d9988cc5",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/saxes/-/saxes-6.0.0.tgz",
    "hash": "fe5b4a4768df4f14a201b1ba6a65c1f3d9988cc5",
    "integrity": "sha512-xAg7SOnEhrm5zI3puOOKyy1OMcMlIJZYNJY7xLBwSze0UjhPLnWfj2GF2EpT0jmzaJKIWKHLsaSSajf35bcYnA==",
    "registry": "npm",
    "packageName": "saxes",
    "cacheIntegrity": "sha512-xAg7SOnEhrm5zI3puOOKyy1OMcMlIJZYNJY7xLBwSze0UjhPLnWfj2GF2EpT0jmzaJKIWKHLsaSSajf35bcYnA== sha1-/ltKR2jfTxSiAbG6amXB89mYjMU="
  },
  "registry": "npm",
  "hash": "fe5b4a4768df4f14a201b1ba6a65c1f3d9988cc5"
}